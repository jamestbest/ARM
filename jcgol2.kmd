KMD
00000000:             ; ;;  This is my second rendition of JCGOL in ARM assembly for Komodo
00000000:             ; ;;  
00000000:             ; ;;  This will attempt to follow the ARM 32bit calling convention 
00000000:             ; ;;      R0-3 are argument registers, scratch
00000000:             ; ;;      R4-10 are local variable registers and should be saved before use in a function
00000000:             ; ;;      R11 - FP
00000000:             ; ;;      R12 - IPC
00000000:             ; ;;      R13 - SP
00000000:             ; ;;      R14 - LR
00000000:             ; ;;      R15 - PC
00000000:             ; ;;
00000000:             ; ;;  The plan
00000000:             ; ;;  - Create a simple `heap` allocator for the grid and input
00000000:             ; ;;  - Ask the user
00000000:             ; ;;      |-Use default? Y - skip below
00000000:             ; ;;      |-dims of the grid
00000000:             ; ;;      |   `-Will need a way to get a string input and convert to an integer (make sure to cat
                      ; ch -ve)
00000000:             ; ;;      |-slow mode
00000000:             ; ;;      `-erase mode
00000000:             ; ;;  - ask for generation mode
00000000:             ; ;;      |-If random ask for seed
00000000:             ; ;;      |   `-For generation roll the seed to create a pseudorandom value for each `pixel`
00000000:             ; ;;      `-If draw then get them to draw the grid one `pixel` at a time
00000000:             ; ;;  - Allocate two grids, the pointers to which will swap after a frame. One is used to count t
                      ; he neighbours the other for the new cell value.
00000000:             ; ;;  - loop
00000000:             ; ;;      |-count neighbours
00000000:             ; ;;      |-update inactive grid
00000000:             ; ;;      |-swap grids
00000000:             ; ;;      |-draw active grid
00000000:             ; ;;      `-goto loop
00000000:             ; 
00000000:             ; 
00000000:             ; ;;SINGLE STEP mode allows you to save the current state of the board into a list, also give it 
                      ; a name
00000000:             ; ;;At the main menu you can load a saved grid
00000000:             ; 
00000000:             ; ;;Save info struct
00000000:             ; ;;  -address of grid [4 BYTES]
00000000:             ; ;;  -char* to the name [4 BYTES]
00000000:             ; 
00000000:             ; 
00000000:             ; ;;  CURRENT ISSUES/TODOS
00000000:             ; ;;  |-More testing of malloc & free need to be done
00000000:             ; ;;  |-Think about minimising the fragmentation of the heap - find the best free block instead o
                      ; f the first
00000000:             ; ;;  `-
00000000:             ; max_addr    EQU  0x100000
00000000:             ; stack_size  EQU  0x10000
00000000:             ; nlchar      EQU  10
00000000:             ; backspace   EQU  8
00000000:             ; minBuffSize EQU  8
00000000:             ; enter       EQU  nlchar
00000000:             ; minSaveSize EQU  8
00000000:             ; sizeofSaveI EQU  8
00000000:             ; 
00000000:             ; _start
00000000:             ;     ;;prepare the stack
00000000: E3A0D601    ;     ldr R13, =max_addr
00000004: E3A0E000    ;     mov R14, #0 ;; allow for `returning` from _start
00000008: E92D4000    ;     push {R14}
0000000C:             ; 
0000000C:             ;     ;;[[temp]] clean the heap
0000000C: EB00007D    ;     bl heapclean
00000010:             ; 
00000010:             ;     ;;setup heap
00000010: E28F007C    ;     adrl R0, heapstart
00000014: E2800A01    ; 
00000018: E58F0A88    ;     str R0, heaphead
0000001C: EB00023B    ;     bl setupHeap
00000020:             ; 
00000020: E3A0000E    ;     mov R0, #14
00000024: EB000244    ;     bl malloc
00000028:             ; 
00000028: EB000002    ;     bl main
0000002C:             ; 
0000002C: E8BD4000    ;     pop {R14}
00000030: EF000002    ;     swi 2
00000034: E1A0F00E    ;     mov R15, R14
00000038:             ; 
00000038:             ; main
00000038: E92D4FF0    ;     push {fp, R14, R4-R10} ;;8 registers saved
0000003C:             ; 
0000003C: E28DB01C    ;     add fp, sp, #28 ;;(r - 1) * 4
00000040: E24DD008    ;     sub sp, sp, #8 ;;reserve 8bytes on the stack for the pointer to the list of saved grids + t
                      ; he maxSize of the array
00000044:             ; 
00000044: E3A00008    ;     ldr R0, =minSaveSize
00000048: E58D0000    ;     str R0, [sp, #0]
0000004C:             ; 
0000004C:             ;     ;;minsize * sizeof(SaveInfo)
0000004C: E3A01008    ;     ldr R1, =sizeofSaveI
00000050: E0000190    ;     mul R0, R0, R1
00000054: EB000238    ;     bl malloc ;;allocate the array on the heap
00000058:             ; 
00000058: E58D0004    ;     str R0, [sp, #4] ;;store the address
0000005C:             ; 
0000005C: E28F0095    ;     adrl R0, welcomemsg
00000060: E2800C0A    ; 
00000064: EF000003    ;     swi 3
00000068:             ; 
00000068: E28F00BA    ;     adrl R0, welcome2msg
0000006C: E2800C0A    ; 
00000070: EF000003    ;     swi 3
00000074:             ; 
00000074:             ; mainchoice
00000074: EF000001    ;     swi 1
00000078: E3800020    ;     orr R0, R0, #32
0000007C: E350006E    ;     cmp R0, #'n' ;;new board generation
00000080: 0A000007    ;     beq newboard
00000084:             ; 
00000084: E350006C    ;     cmp R0, #'l' ;;load a saved board
00000088: 0A00000F    ;     beq loadboard
0000008C:             ; 
0000008C: E3500071    ;     cmp R0, #'q' ;;quit
00000090: 0A00002A    ;     beq mainEnd
00000094:             ; 
00000094: E28F00DA    ;     adrl R0, mainchoicefail
00000098: E2800C0A    ; 
0000009C: EF000003    ;     swi 3
000000A0:             ; 
000000A0: EAFFFFF3    ;     b mainchoice
000000A4:             ; 
000000A4:             ;     ;;R4 will hold the active grid, R5 will hold the passive grid
000000A4:             ;     ;;Active is used to count neighbours, passive is used to place updated values in 
000000A4:             ;     ;;either can be drawn, just drawn in a different position
000000A4:             ; 
000000A4:             ; newboard
000000A4: E3A00001    ;     mov R0, #1;;should get dims
000000A8: EB00015A    ;     bl setupOptions
000000AC:             ; 
000000AC: EB0000F2    ;     bl setupGrid
000000B0:             ;     
000000B0: E59F4A34    ;     ldr R4, gridA
000000B4: E59F5A34    ;     ldr R5, gridB
000000B8:             ; 
000000B8: E3540000    ;     cmp R4, #0
000000BC: 0A00001C    ;     beq gridFail
000000C0: E3550000    ;     cmp R5, #0
000000C4: 0A00001A    ;     beq gridFail
000000C8:             ; 
000000C8: EAFFFFFF    ;     b mainloopstart
000000CC:             ; 
000000CC:             ; loadboard
000000CC:             ; ;;display the saved grids
000000CC:             ; ;;ask for the index
000000CC:             ; ;;load the grids with the saved info
000000CC:             ; ;;ask the user for the settings
000000CC:             ; ;;b to mainloopstart
000000CC:             ; 
000000CC:             ; ;;update loop
000000CC:             ; ;;    - loop
000000CC:             ; ;;      |-count neighbours
000000CC:             ; ;;      |-update inactive grid
000000CC:             ; ;;      |-swap grids
000000CC:             ; ;;      |-draw grid
000000CC:             ; ;;      |-[slow?] - slow() - loops for some time to increase waiting time
000000CC:             ; ;;      |-[step?] - step() - waits for input, s and q will have effects
000000CC:             ; ;;      |-[erase?] - erase() - \b until grid is gone
000000CC:             ; ;;      `-goto loop
000000CC:             ; mainloopstart
000000CC:             ;     ;;load the slow, step, and erase booleans
000000CC: E5DF6A21    ;     ldrb R6, slow_b
000000D0: E5DF7A1C    ;     ldrb R7, erase_b
000000D4: E5DF8A1A    ;     ldrb R8, step_b
000000D8:             ; 
000000D8:             ;     ;;(width * height) * 2 + 1 + height
000000D8: E5DF0A17    ;     ldrb R0, width
000000DC: E5DF1A14    ;     ldrb R1, height
000000E0: E0000190    ;     mul R0, R0, R1
000000E4: E1A00080    ;     mov R0, R0, lsl #1
000000E8: E2800001    ;     add R0, R0, #1
000000EC: E0800001    ;     add R0, R0, R1
000000F0: E1A09000    ;     mov R9, R0      ;;R9 holds the itterations for erase, so it doesn't have to calc it every t
                      ; ime
000000F4:             ; 
000000F4:             ; mainloop
000000F4: E1A00004    ;     mov R0, R4
000000F8: E1A01005    ;     mov R1, R5
000000FC: EB0001B2    ;     bl updategrid
00000100:             ; 
00000100: E1A00004    ;     mov R0, R4
00000104: EB000126    ;     bl drawgrid
00000108:             ; 
00000108: E3580001    ;     cmp R8, #1
0000010C: 0B000011    ;     bleq step
00000110:             ; 
00000110: E3560001    ;     cmp R6, #1
00000114: 0B000030    ;     bleq slow
00000118:             ; 
00000118: E3570001    ;     cmp R7, #1
0000011C: 01A00009    ;     moveq R0, R9
00000120: 0B000025    ;     bleq erase
00000124:             ; 
00000124: E1A00004    ;     mov R0, R4
00000128: E1A04005    ;     mov R4, R5
0000012C: E1A05000    ;     mov R5, R0 ;;SWAP the active and passive
00000130:             ; 
00000130: EAFFFFEF    ;     b mainloop
00000134:             ; 
00000134:             ; gridFail
00000134: E28F001B    ;     adrl R0, gridfailmsg
00000138: E2800C0F    ; 
0000013C: EF000003    ;     swi 3
00000140:             ; 
00000140:             ; mainEnd
00000140:             ;     ;;need to free all of the memory, saved grids (grids + names) + current grids
00000140:             ; 
00000140: E24BD018    ;     sub sp, fp, #24 ;;???
00000144: E8BD47F0    ;     pop {R14, R4-R10}
00000148: E1A0F00E    ;     mov R15, R14
0000014C:             ; 
0000014C:             ; newline
0000014C: E3A0000A    ;     ldr R0, =nlchar
00000150: EF000000    ;     swi 0
00000154:             ; 
00000154: E1A0F00E    ;     mov R15, R14
00000158:             ; 
00000158:             ; step
00000158:             ; ;;INP --
00000158:             ; ;;OUT in R0 is 1 if should return to main menu, else 0
00000158:             ; 
00000158:             ; ;;get user input
00000158:             ; ;;if q -> jump to main menu
00000158:             ; ;;if s -> ask for name, bl saveGrid with name
00000158: E92D41F0    ;     push {R14, R4-R8}
0000015C:             ; 
0000015C: EF000001    ;     swi 1
00000160:             ; 
00000160: E3500071    ;     cmp R0, #'q'
00000164: 0A00000F    ;     beq stependfail ;;bad name, shame I can't change it eh
00000168:             ; 
00000168: E3500073    ;     cmp R0, #'s'
0000016C: 1A00000F    ;     bne stependsucc
00000170:             ; 
00000170: E28F0EC9    ;     adrl R0, askname
00000174: E2800000    ; 
00000178: EF000003    ;     swi 3
0000017C:             ; 
0000017C: E3A0000A    ;     ldr R0, =enter
00000180: E3E01000    ;     mov R1, #-1
00000184: E3A02001    ;     mov R2, #1
00000188: EB00007F    ;     bl getstring
0000018C:             ; 
0000018C: EB00000A    ;     bl saveGrid
00000190:             ; 
00000190: E28F0045    ;     adrl R0, savedchoice
00000194: E2800B03    ; 
00000198: EF000003    ;     swi 3
0000019C:             ; 
0000019C: E3500059    ;     cmp R0, #'Y'
000001A0: 0A000000    ;     beq stependfail
000001A4: EA000001    ;     b stependsucc
000001A8:             ; 
000001A8:             ; stependfail
000001A8: E3A00001    ;     mov R0, #1
000001AC: EA000000    ;     b stepend
000001B0:             ; 
000001B0:             ; stependsucc
000001B0: E3A00000    ;     mov R0, #0
000001B4:             ; 
000001B4:             ; stepend
000001B4: E8BD41F0    ;     pop {R14, R4-R8}
000001B8: E1A0F00E    ;     mov R15, R14
000001BC:             ; 
000001BC:             ; saveGrid
000001BC:             ; ;;
000001BC:             ; 
000001BC:             ; erase
000001BC:             ; ;;INP in R0 is the itters
000001BC:             ; ;;for (width * height + 1) * 2 + 1
000001BC:             ; ;;      print('\b')
000001BC: E1A01000    ;     mov R1, R0
000001C0:             ; 
000001C0:             ; eraseloop
000001C0: E3510000    ;     cmp R1, #0
000001C4: 0A000003    ;     beq eraseend
000001C8:             ; 
000001C8: E3A00008    ;     ldr R0, =backspace
000001CC: EF000000    ;     swi 0
000001D0:             ; 
000001D0: E2411001    ;     sub R1, R1, #1
000001D4: EAFFFFF9    ;     b eraseloop
000001D8:             ; 
000001D8:             ; eraseend
000001D8: E1A0F00E    ;     mov R15, R14
000001DC:             ; 
000001DC:             ; slow
000001DC: E3A010FF    ;     mov R1, #0xFF
000001E0: E1A01081    ;     mov R1, R1, lsl #1
000001E4:             ; 
000001E4:             ; slowloop
000001E4: E3510000    ;     cmp R1, #0
000001E8: 0A000005    ;     beq slowend
000001EC:             ; 
000001EC: E3A00020    ;     mov R0, #' '
000001F0: EF000000    ;     swi 0
000001F4: E3A00008    ;     ldr R0, =backspace
000001F8: EF000000    ;     swi 0
000001FC:             ; 
000001FC: E2411001    ;     sub R1, R1, #1
00000200: EAFFFFF7    ;     b slowloop
00000204:             ; 
00000204:             ; slowend
00000204: E1A0F00E    ;     mov R15, R14
00000208:             ; 
00000208:             ; heapclean
00000208:             ; ;;zero out all memory in the heap (debugging uses)
00000208: E28F0FA1    ;     adrl R0, heapstart
0000020C: E2800B03    ; 
00000210: E3A01601    ;     ldr R1, =max_addr ;;stores the end of the heap
00000214: E3A02801    ;     ldr R2, =stack_size
00000218: E0411002    ;     sub R1, R1, R2 ;; R1 = max_addr - stack_size which should be the heap end
0000021C: E3C11003    ;     and R1, R1, #-4 ;;align to 4 byte boundry just in case
00000220: E3A03000    ;     mov R3, #0
00000224:             ; heapcleanloop ;;starting at heapstart
00000224: E1500001    ;     cmp R0, R1
00000228: 0A000002    ;     beq heapcleanend
0000022C: E5003000    ;     str R3, [R0] ;;store 0 in loc
00000230: E2800004    ;     add R0, R0, #4 ;;inc by a word
00000234: EAFFFFFA    ;     b heapcleanloop
00000238:             ; heapcleanend
00000238: E1A0F00E    ;     mov R15, R14
0000023C:             ; 
0000023C:             ; 
0000023C:             ; strlen
0000023C:             ; ;;INP in R0 is the address of the string
0000023C:             ; ;;OUT in R0 is the length of the null terminated string
0000023C:             ; 
0000023C:             ; ;;len = 0
0000023C:             ; ;;while(inp[len] != \0) {len++;}
0000023C:             ; ;;return len
0000023C:             ; 
0000023C: E3A01000    ;     mov R1, #0 ;;len
00000240: E3500000    ;     cmp R0, #0
00000244: 0A000004    ;     beq strlenend
00000248:             ; 
00000248:             ; strlenloop
00000248: E7D02001    ;     ldrb R2, [R0, R1]
0000024C: E3520000    ;     cmp R2, #0
00000250: 0A000001    ;     beq strlenend
00000254: E2811001    ;     add R1, R1, #1
00000258: EAFFFFFA    ;     b strlenloop
0000025C:             ; 
0000025C:             ; strlenend
0000025C: E1A00001    ;     mov R0, R1
00000260: E1A0F00E    ;     mov R15, R14
00000264:             ; 
00000264:             ; strtoi
00000264:             ; ;;INP in R0 is the address of the string
00000264:             ; ;;OUT in R0 is the value created
00000264:             ; ;;OUT in R1 is the err code
00000264:             ; ;;
00000264:             ; ;;ERR codes
00000264:             ; ;;  0 is success
00000264:             ; ;;  1 is attempted -ve
00000264:             ; ;;  2 is use of non-numeric characters
00000264:             ; ;;  3 is value out of range of integer
00000264:             ; ;;  4 is null string given
00000264:             ; 
00000264:             ; ;;  example inp
00000264:             ; ;;  12234       len = 5
00000264:             ; ;;      ^-find end
00000264:             ; ;;  tot = 0
00000264:             ; ;;  for i from end to 0:
00000264:             ; ;;      tot += inp[i] * (10 ** (len(inp) - i - 1))
00000264:             ; ;;  +some checks for valid input
00000264:             ; 
00000264:             ; ;;This will take in an address to the start of a string and attempt to convert it into an integ
                      ; er
00000264:             ; ;;String is only valid when all characters are numerical
00000264:             ; ;;For now it does not accept -ve numbers
00000264:             ; 
00000264: E92D41F0    ;     push {R14, R4-R8}
00000268: E1A04000    ;     mov R4, R0  ;;R4 holds the addr
0000026C:             ; 
0000026C: E3500000    ;     cmp R0, #0
00000270: 03A01004    ;     moveq R1, #4
00000274: 0A00001E    ;     beq strtoiendfail ;;null given so err code = 4 and end
00000278:             ; 
00000278: EBFFFFEF    ;     bl strlen
0000027C: E1A05000    ;     mov R5, R0  ;;R5 holds the len of the string
00000280:             ; 
00000280: E3550000    ;     cmp R5, #0
00000284: 0A00001C    ;     beq strtoiendsucc ;;if len(string) == 0 then return 0
00000288:             ; 
00000288: E5D46000    ;     ldrb R6, [R4, #0]
0000028C: E356002D    ;     cmp R6, #45
00000290: 0A000012    ;     beq strtoifailminus
00000294:             ; 
00000294: E3A06000    ;     mov R6, #0  ;;R6 holds the total
00000298: E3A07001    ;     mov R7, #1  ;;R7 holds the **
0000029C: E2458001    ;     sub R8, R5, #1  ;;R8 is i which starts at end (len - 1)
000002A0: E3A0300A    ;     mov R3, #10 ;;mul to **
000002A4:             ; 
000002A4:             ; strtoiloop
000002A4: E3580000    ;     cmp R8, #0
000002A8: BA00000A    ;     blt strtoilend
000002AC:             ; 
000002AC: E7D42008    ;     ldrb R2, [R4, R8]
000002B0: E2422030    ;     sub R2, R2, #48
000002B4:             ; 
000002B4: E3520000    ;     cmp R2, #0
000002B8: BA00000C    ;     blt strtoifailnonnum
000002BC: E3520009    ;     cmp R2, #9
000002C0: CA00000A    ;     bgt strtoifailnonnum
000002C4:             ; 
000002C4: E0266792    ;     mla R6, R2, R7, R6 ;;total = (inp[i] * (**)) + total -> total += inp[i] * (**)
000002C8: 6A000006    ;     bvs strtoifailoutrange
000002CC: E0070397    ;     mul R7, R7, R3
000002D0:             ; 
000002D0: E2488001    ;     sub R8, R8, #1
000002D4:             ; 
000002D4: EAFFFFF2    ;     b strtoiloop
000002D8:             ; 
000002D8:             ; 
000002D8:             ; ;;branches are expensive - should this just be rep RET? probably doesn't matter at this scale
000002D8:             ; strtoilend
000002D8: E1A00006    ;     mov R0, R6
000002DC: EA000006    ;     b strtoiendsucc
000002E0:             ; 
000002E0:             ; strtoifailminus
000002E0: E3A01001    ;     mov R1, #1
000002E4: EA000002    ;     b strtoiendfail
000002E8:             ; 
000002E8:             ; strtoifailoutrange
000002E8: E3A01003    ;     mov R1, #3
000002EC: EA000000    ;     b strtoiendfail
000002F0:             ; 
000002F0:             ; strtoifailnonnum
000002F0: E3A01002    ;     mov R1, #2
000002F4:             ; 
000002F4:             ; strtoiendfail
000002F4: E3A00000    ;     mov R0, #0
000002F8: EA000000    ;     b strtoiend
000002FC:             ; 
000002FC:             ; strtoiendsucc
000002FC: E3A01000    ;     mov R1, #0
00000300:             ; 
00000300:             ; strtoiend
00000300: E8BD41F0    ;     pop {R14, R4-R8}
00000304: E1A0F00E    ;     mov R15, R14
00000308:             ; 
00000308:             ; memcpy
00000308:             ; ;;INP in R0 is the addr of src
00000308:             ; ;;INP in R1 is the addr of dst
00000308:             ; ;;INP in R2 is the number of bytes to copy
00000308:             ; 
00000308:             ; ;;check if src and dst are alliged
00000308:             ; ;;If different then write bytes
00000308:             ; ;;If same then go to 4byte boundry
00000308:             ; ;;  Write words of bytes2copy / 4
00000308:             ; ;;  Write remaining bytes
00000308: E92D41F0    ;     push {R14, R4-R8}
0000030C:             ; 
0000030C: E2004003    ;     and R4, R0, #0b11
00000310: E2015003    ;     and R5, R1, #0b11
00000314:             ; 
00000314: E1540005    ;     cmp R4, R5
00000318: 1A00000E    ;     bne memcpyallbytes
0000031C:             ; 
0000031C:             ;     ;;If they are the same then cpy R4 bytes and then do words
0000031C: E0422004    ;     sub R2, R2, R4;; bytes2cpy -= bytes we are about to write
00000320: E1A03004    ;     mov R3, R4
00000324: EB00000E    ;     bl memcpybytes
00000328:             ; 
00000328:             ;     ;;Now find the number of words that can be written i.e. bytes2cpy / 4 (bytes2cpy >> 2)
00000328: E3C23003    ;     and R3, R2, #-4 ;;the number of bytes to write that make up the words
0000032C: E3A04000    ;     mov R4, #0 ;;i
00000330:             ; memcpywordsloop
00000330: E1540003    ;     cmp R4, R3
00000334: 0A000003    ;     beq memcpywordslend
00000338:             ; 
00000338: E7906004    ;     ldr R6, [R0, R4]
0000033C: E7816004    ;     str R6, [R1, R4]
00000340:             ;     
00000340: E2844004    ;     add R4, R4, #4
00000344:             ; 
00000344: EAFFFFF9    ;     b memcpywordsloop
00000348:             ;     
00000348:             ; memcpywordslend
00000348:             ; ;;Now copy the remaining bytes
00000348: E2022003    ;     and R2, R2, #0b11
0000034C: E1A03002    ;     mov R3, R2
00000350: EB000003    ;     bl memcpybytes
00000354: EA00000A    ;     b memcpyend
00000358:             ; 
00000358:             ; memcpyallbytes
00000358: E1A03002    ;     mov R3, R2
0000035C: EB000000    ;     bl memcpybytes
00000360: EA000007    ;     b memcpyend
00000364:             ; 
00000364:             ; memcpybytes
00000364:             ; ;;This is an internal function to memcpy and so doesn't follow the calling convention, it also 
                      ; assumes values are in place from memcpy
00000364:             ; ;;for (int i = 0; i < byte2cpy; i++) {
00000364:             ; ;;      *(dst + i) = *(src + i)
00000364:             ; ;;INP in R3 is the number of bytes to copy
00000364: E3A05000    ;     mov R5, #0 ;;i
00000368:             ; memcpybytesloop
00000368: E1550003    ;     cmp R5, R3
0000036C: 0A000003    ;     beq memcpybyteslend ;;i < bytes2cpy
00000370:             ; 
00000370: E7D04005    ;     ldrb R4, [R0, R5]
00000374: E7C14005    ;     strb R4, [R1, R5] ;;dst[i] = src[i]
00000378:             ; 
00000378: E2855001    ;     add R5, R5, #1 ;;i++
0000037C:             ; 
0000037C: EAFFFFF9    ;     b memcpybytesloop
00000380:             ; 
00000380:             ; memcpybyteslend
00000380: E1A0F00E    ;     mov R15, R14
00000384:             ; 
00000384:             ; memcpyend
00000384: E8BD41F0    ;     pop {R14, R4-R8}
00000388: E1A0F00E    ;     mov R15, R14
0000038C:             ; 
0000038C:             ; getstring
0000038C:             ; ;;INP in R0 the terminator character
0000038C:             ; ;;INP in R1 the max number of characters or -1 for no max
0000038C:             ; ;;INP in R2 boolean (non-0/0) for if letters should be printed out as well
0000038C:             ; ;;RET in R0 a ptr to the memory address
0000038C:             ; ;;
0000038C:             ; ;;Dynamically allocate memory to support large string
0000038C:             ; 
0000038C:             ; ;;buff = malloc(minBytes)
0000038C:             ; ;;while (input != terminator && pos < maxchars) 
0000038C:             ; ;;  buff[pos] = input
0000038C:             ; ;;  putchar(input)
0000038C:             ; ;;  if (pos > buffSize)
0000038C:             ; ;;      nBuff = malloc(buffSize << 1)
0000038C:             ; ;;      memcpy from buff to nBuff
0000038C:             ; ;;      free buff
0000038C:             ; ;;      buff = nBuff
0000038C:             ; 
0000038C: E92D47F0    ;     push {R14, R4-R10}
00000390:             ; 
00000390: E1A08000    ;     mov R8, R0 ;;now holds terminator
00000394: E1A09001    ;     mov R9, R1 ;;nax chars
00000398: E3590000    ;     cmp R9, #0
0000039C: 0A00002F    ;     beq getstringEnd
000003A0:             ;     ;sub R9, R9, #1 ;;reduce by 1 to use later
000003A0: E1A0A002    ;     mov R10, R2 ;;print bool
000003A4:             ; 
000003A4: E3A06008    ;     ldr R6, =minBuffSize ;;R6 will hold the current size of the buffer
000003A8: E1A00006    ;     mov R0, R6
000003AC: EB000162    ;     bl malloc
000003B0: E1A04000    ;     mov R4, R0 ;;R4 is the address of the buffer
000003B4:             ; 
000003B4: E3A05000    ;     mov R5, #0 ;;R5 is the loop counter/index into buffer
000003B8:             ; getstringloop
000003B8: E1550009    ;     cmp R5, R9 ;;position - maxsize
000003BC:             ;                       ;;pos 2 means 3 characters written
000003BC: AA000019    ;     bge getstringlend ;;if position >= maxsize
000003C0:             ; 
000003C0: EF000001    ;     swi 1 ;;get input
000003C4: E1500008    ;     cmp R0, R8 ;;is input == terminator character
000003C8: 0A000016    ;     beq getstringlend
000003CC:             ; 
000003CC: E3790001    ;     cmp R9, #-1
000003D0: 0AFFFFFF    ;     beq skipMax
000003D4:             ;     
000003D4:             ; skipMax
000003D4: E1550006    ;     cmp R5, R6
000003D8: E92D0001    ;     push {R0}
000003DC: AA000005    ;     bge getstringresize
000003E0:             ; 
000003E0:             ; getstringlcont
000003E0: E8BD0001    ;     pop {R0}
000003E4: E7C40005    ;     strb R0, [R4, R5] ;;buff[pos] = input
000003E8:             ; 
000003E8: E35A0000    ;     cmp R10, #0
000003EC: 1F000000    ;     swine 0 ;;output the character to the screen if R10 is not 0
000003F0:             ; 
000003F0: E2855001    ;     add R5, R5, #1
000003F4:             ; 
000003F4: EAFFFFEF    ;     b getstringloop
000003F8:             ; 
000003F8:             ; getstringresize
000003F8:             ;     ;;r6 will hold new buffer
000003F8: E1A00086    ;     mov R0, R6, lsl #1
000003FC: EB00014E    ;     bl malloc
00000400: E1A07000    ;     mov R7, R0
00000404:             ; 
00000404: E1A00004    ;     mov R0, R4 ;;old buff
00000408: E1A01007    ;     mov R1, R7 ;;newBuff
0000040C: E1A02005    ;     mov R2, R5 ;;bytes to write
00000410: EBFFFFBC    ;     bl memcpy
00000414:             ; 
00000414: E1A00004    ;     mov R0, R4
00000418: EB000171    ;     bl free
0000041C: E1A04007    ;     mov R4, R7
00000420:             ; 
00000420: E1A06086    ;     mov R6, R6, lsl #1
00000424:             ; 
00000424: EAFFFFED    ;     b getstringlcont
00000428:             ; 
00000428:             ; getstringlend
00000428:             ;     ;;need to add a \0
00000428:             ;     ;;need to check if the buffer is completely full -> resize buffer to +1? (will be aligned t
                      ; o 8 in malloc!) then copy
00000428:             ;     ;;I could have the buffers always leave a space open for the \0? but this is kind of an edg
                      ; e case?
00000428: E1550006    ;     cmp R5, R6 ;;position to size of buffer
0000042C: 0A000000    ;     beq getstringResizeEnd
00000430:             ; 
00000430: EA00000A    ;     b getstringEnd
00000434:             ; 
00000434:             ; getstringResizeEnd
00000434: E2860001    ;     add R0, R6, #1
00000438: EB00013F    ;     bl malloc
0000043C: E1A07000    ;     mov R7, R0
00000440:             ; 
00000440: E1A00004    ;     mov R0, R4;;old buff
00000444: E1A01007    ;     mov R1, R7;;new buff
00000448: E1A02005    ;     mov R2, R5;;bytes2write
0000044C: EBFFFFAD    ;     bl memcpy
00000450:             ; 
00000450: E1A00004    ;     mov R0, R4
00000454: EB000162    ;     bl free
00000458: E1A04007    ;     mov R4, R7
0000045C:             ; 
0000045C: E2866001    ;     add R6, R6, #1 ;;not needed
00000460:             ; 
00000460:             ; getstringEnd
00000460: E3A00000    ;     mov R0, #0
00000464: E7C40005    ;     strb R0, [R4, R5]
00000468:             ; 
00000468: E1A00004    ;     mov R0, R4
0000046C:             ; 
0000046C: E8BD47F0    ;     pop {R14, R4-R10}
00000470: E1A0F00E    ;     mov R15, R14
00000474:             ; 
00000474:             ; tolower
00000474:             ; ;;INP in R0 is a character
00000474:             ; ;;OUT in R0 is the character.lower()
00000474: E3800020    ;     orr R0, R0, #32
00000478: E1A0F00E    ;     mov R15, R14
0000047C:             ; 
0000047C:             ; setupGrid
0000047C:             ; ;;INP --
0000047C:             ; ;;RET --
0000047C:             ; ;;The values addresses of the grids will now be set, can still be 0
0000047C:             ; ;; ask for generation mode
0000047C:             ; ;;      |-If random ask for seed
0000047C:             ; ;;      |   `-For generation roll the seed to create a pseudorandom value for each `pixel`
0000047C:             ; ;;      `-If draw then get them to draw the grid one `pixel` at a time
0000047C: E92D47F0    ;     push {R14, R4-R10}
00000480:             ; 
00000480:             ;     ;;generate the main grid
00000480: E5DF666F    ;     ldrb R6, width
00000484: E5DF766C    ;     ldrb R7, height
00000488:             ; 
00000488: E0000796    ;     mul R0, R6, R7 ;;width * height = num of bytes to malloc
0000048C:             ; 
0000048C: E1A05000    ;     mov R5, R0
00000490: EB000129    ;     bl malloc
00000494: E1A04000    ;     mov R4, R0
00000498: E58F464C    ;     str R4, gridA
0000049C:             ; 
0000049C: E1A00005    ;     mov R0, R5
000004A0: EB000125    ;     bl malloc
000004A4: E58F0644    ;     str R0, gridB
000004A8:             ; 
000004A8: E3550000    ;     cmp R5, #0
000004AC: 0A00003A    ;     beq setupGridFail
000004B0: E3540000    ;     cmp R4, #0
000004B4: 0A000038    ;     beq setupGridFail
000004B8:             ; 
000004B8:             ;     ;;R4 holds the gridA addr
000004B8:             ;     ;;R6 holds the width
000004B8:             ;     ;;R7 holds the height
000004B8:             ; 
000004B8: E28F0FAB    ;     adrl R0, askgenoption
000004BC: E2800B02    ; 
000004C0: EF000003    ;     swi 3
000004C4:             ; setupGridAsk
000004C4: EF000001    ;     swi 1
000004C8: E3800020    ;     orr R0, R0, #32
000004CC:             ; 
000004CC: E1A01000    ;     mov R1, R0
000004D0: EBFFFF1D    ;     bl newline
000004D4:             ; 
000004D4: E3510064    ;     cmp R1, #'d'
000004D8: 0A000005    ;     beq setupdrawing
000004DC:             ; 
000004DC: E3510072    ;     cmp R1, #'r'
000004E0: 0A000005    ;     beq setuprandom
000004E4:             ; 
000004E4: E28F00B9    ;     adrl R0, setupGrdFailmsg
000004E8: E2800C0A    ; 
000004EC: EF000003    ;     swi 3
000004F0: EAFFFFF3    ;     b setupGridAsk
000004F4:             ; 
000004F4:             ; setupdrawing
000004F4: E3A09000    ;     mov R9, #0
000004F8: EA000006    ;     b setupstart
000004FC:             ; 
000004FC:             ; setuprandom
000004FC: E3A00000    ;     mov R0, #0
00000500: E3A01004    ;     mov R1, #4
00000504: E3A02001    ;     mov R2, #1
00000508: EBFFFF9F    ;     bl getstring
0000050C:             ; 
0000050C: E1A08000    ;     mov R8, R0
00000510:             ; 
00000510: EBFFFF0D    ;     bl newline
00000514:             ; 
00000514: E3A09001    ;     mov R9, #1
00000518:             ; 
00000518:             ; setupstart
00000518:             ; ;;This is probably not a good way to do it as there is more branching in the middle of a loop t
                      ; hat is executed alot
00000518:             ; ;;I'm doing it this way `not because it is easy, but because I though it would be easy`
00000518:             ; ;;Reduces the need for writing another loop :)
00000518:             ; ;;R9 holds the mode (1 for random, 0 for draw)
00000518:             ; ;;R8 will hold the seed for random
00000518:             ; ;;for row from 0 to height - 1
00000518:             ; ;;  for col from 0 to width - 1
00000518:             ; ;;      if (random)
00000518:             ; ;;          grid[row][col] = ((seed rol 1) || row) && 1
00000518:             ; ;;      else
00000518:             ; ;;          grid[row][col] = input() == 1
00000518: E3A05000    ;     mov R5, #0 ;; row
0000051C:             ; setuprowloop
0000051C: E1550007    ;     cmp R5, R7
00000520: 0A00001D    ;     beq setuprowlend
00000524:             ; 
00000524: E3A0A000    ;     mov R10, #0 ;;col
00000528:             ; setupcolloop
00000528: E15A0006    ;     cmp R10, R6
0000052C: 0A000018    ;     beq setupcollend
00000530:             ; 
00000530: E3590001    ;     cmp R9, #1
00000534: 0A000000    ;     beq dorandom
00000538: EA000004    ;     b dodraw
0000053C:             ; 
0000053C:             ; ;;dorandom and dodraw will get their value for this position and then place it in R2
0000053C:             ; ;;R3 is free at this point
0000053C:             ; dorandom
0000053C:             ;     ;;seed in R8
0000053C: E1A080E8    ;     mov R8, R8, ror #1
00000540: E00A3005    ;     and R3, R10, R5
00000544: E0288003    ;     eor R8, R8, R3
00000548: E2082001    ;     and R2, R8, #1
0000054C: EA000009    ;     b setupcollcont
00000550:             ; dodraw
00000550:             ;     ;;get input, validate 1 or 0
00000550:             ;     ;;if invalid print error loop back
00000550:             ;     ;;-_- I've just realised I want to print the grid each time as well R0-R3 are scratch
00000550: EF000001    ;     swi 1
00000554:             ; 
00000554: E3500031    ;     cmp R0, #'1'
00000558: 0A000005    ;     beq dodrawsucc
0000055C: E3500030    ;     cmp R0, #'0'
00000560: 0A000003    ;     beq dodrawsucc
00000564:             ; 
00000564: E28F00C6    ;     adrl R0, drawfailmsg
00000568: E2800C0A    ; 
0000056C: EF000003    ;     swi 3
00000570:             ; 
00000570: EAFFFFF6    ;     b dodraw
00000574:             ; 
00000574:             ; dodrawsucc
00000574: E2402030    ;     sub R2, R0, #48 ;;could be xor?
00000578:             ; 
00000578:             ; setupcollcont
00000578:             ;     ;;place the value in R2 into the grid[row][col]
00000578:             ;     ;;row * width + col
00000578:             ; 
00000578: E023A695    ;     mla R3, R5, R6, R10 ;;R3 = row * width + col
0000057C: E7C42003    ;     strb R2, [R4, R3] ;;grid offset by R3
00000580:             ; 
00000580: E3590000    ;     cmp R9, #0
00000584: 01A00004    ;     moveq R0, R4
00000588: 0B000005    ;     bleq drawgrid ;;print the new state of the grid if this is drawing mode
0000058C:             ; 
0000058C: E28AA001    ;     add R10, R10, #1
00000590: EAFFFFE4    ;     b setupcolloop
00000594:             ; setupcollend
00000594: E2855001    ;     add R5, R5, #1
00000598: EAFFFFDF    ;     b setuprowloop
0000059C:             ; setuprowlend
0000059C:             ;     ;;grid has been setup
0000059C:             ; 
0000059C:             ; setupGridFail
0000059C:             ; setupGridEnd
0000059C: E8BD47F0    ;     pop {R14, R4-R10}
000005A0: E1A0F00E    ;     mov R15, R14
000005A4:             ; 
000005A4:             ; 
000005A4:             ; ;;[[TODO]] the heap may not be blank (when heapclean is removed) and so need to 0 the mem. Mayb
                      ; e add option to malloc or add calloc (not the same)
000005A4:             ; drawgrid
000005A4:             ; ;;INP in R0 is the grid address to draw
000005A4:             ; 
000005A4:             ; ;;for row from 0 to height - 1
000005A4:             ; ;;  for col from 0 to width - 1
000005A4:             ; ;;      print('X' if grid[row][col] else '_')
000005A4:             ; ;;  print(newline)
000005A4:             ; ;;print(newline)
000005A4: E92D01F0    ;     push {R4-R8}
000005A8:             ; 
000005A8: E1A06000    ;     mov R6, R0
000005AC:             ; 
000005AC: E5DF4543    ;     ldrb R4, width
000005B0: E5DF5540    ;     ldrb R5, height
000005B4:             ; 
000005B4: E3A02000    ;     mov R2, #0 ;;row
000005B8:             ; drawgridrowloop
000005B8: E1520005    ;     cmp R2, R5
000005BC: 0A000011    ;     beq drawgridrowlend
000005C0:             ; 
000005C0: E3A01000    ;     mov R1, #0 ;;col
000005C4:             ; drawgridcolloop
000005C4: E1510004    ;     cmp R1, R4
000005C8: 0A000009    ;     beq drawgridcollend
000005CC:             ; 
000005CC: E0231492    ;     mla R3, R2, R4, R1 ;;R3 = row * width + col
000005D0: E7D63003    ;     ldrb R3, [R6, R3]
000005D4:             ; 
000005D4: E3530001    ;     cmp R3, #1
000005D8: 03A00058    ;     moveq R0, #'X'
000005DC: 13A0002D    ;     movne R0, #'-'
000005E0:             ; 
000005E0: EF000000    ;     swi 0
000005E4:             ; 
000005E4: E3A00020    ;     mov R0, #' '
000005E8: EF000000    ;     swi 0
000005EC:             ; 
000005EC: E2811001    ;     add R1, R1, #1
000005F0: EAFFFFF3    ;     b drawgridcolloop
000005F4:             ; 
000005F4:             ; drawgridcollend
000005F4: E3A01000    ;     mov R1, #0
000005F8: E2822001    ;     add R2, R2, #1
000005FC: E3A0000A    ;     mov R0, #10
00000600: EF000000    ;     swi 0
00000604: EAFFFFEB    ;     b drawgridrowloop
00000608:             ; 
00000608:             ; drawgridrowlend
00000608: E3A0000A    ;     mov R0, #10
0000060C: EF000000    ;     swi 0
00000610:             ; drawgridend
00000610: E8BD01F0    ;     pop {R4-R8}
00000614: E1A0F00E    ;     mov R15, R14
00000618:             ; 
00000618:             ; 
00000618:             ; setupOptions
00000618:             ; ;;INP in R0 is 1 if should ask for dims 0 for skip
00000618: E92D4010    ;     push {R14, R4}
0000061C: E1A04000    ;     mov R4, R0
00000620:             ; 
00000620: E28F00ED    ;     adrl R0, askdefaults ;;ask q
00000624: E2800C06    ; 
00000628: EF000003    ;     swi 3
0000062C: EF000001    ;     swi 1   ;;get character answer
00000630: EF000000    ;     swi 0
00000634: E3500059    ;     cmp R0, #'Y'
00000638: E3A0000A    ;     ldr R0, =nlchar
0000063C: EF000000    ;     swi 0
00000640:             ; 
00000640: 1A00000A    ;     bne setupCustom
00000644:             ; 
00000644: E28F00D3    ;     adrl R0, usingDefault
00000648: E2800B02    ; 
0000064C: EF000003    ;     swi 3
00000650:             ; 
00000650: E3A00000    ;     mov R0, #0
00000654: E5CF0498    ;     strb R0, erase_b
00000658: E5CF0495    ;     strb R0, slow_b
0000065C: E3A00012    ;     mov R0, #18
00000660: E5CF048F    ;     strb R0, width
00000664: E5CF048C    ;     strb R0, height
00000668:             ; 
00000668: E8BD4010    ;     pop {R14, R4}
0000066C: E1A0F00E    ;     mov R15, R14 ;;RET
00000670:             ; 
00000670:             ; setupCustom
00000670:             ; ;;ask for erase, slow, step, and conditionally dims
00000670:             ; 
00000670:             ; ;;ask step
00000670:             ; ;;ask erase
00000670:             ; ;;if (!step)
00000670:             ; ;;  if erase
00000670:             ; ;;      print(recommend slow)
00000670:             ; ;;  ask slow
00000670:             ; 
00000670: E3A01001    ;     mov R1, #1
00000674:             ; 
00000674: E28F0FBF    ;     adrl R0, askstep
00000678: E2800B01    ; 
0000067C: EF000003    ;     swi 3
00000680: EF000001    ;     swi 1
00000684: EF000000    ;     swi 0 
00000688: E3500059    ;     cmp R0, #'Y' 
0000068C: E3A0000A    ;     ldr R0, =nlchar
00000690: EF000000    ;     swi 0
00000694: 13A01000    ;     movne R1, #0
00000698: E5CF1456    ;     strb R1, step_b
0000069C:             ; 
0000069C: E3A01001    ;     mov R1, #1
000006A0:             ; 
000006A0: E28F009F    ;     adrl R0, askerase
000006A4: E2800C06    ; 
000006A8: EF000003    ;     swi 3
000006AC: EF000001    ;     swi 1
000006B0: EF000000    ;     swi 0
000006B4: E3500059    ;     cmp R0, #'Y'
000006B8: E3A0000A    ;     ldr R0, =nlchar
000006BC: EF000000    ;     swi 0
000006C0: 13A01000    ;     movne R1, #0
000006C4: E5CF1428    ;     strb R1, erase_b
000006C8:             ; 
000006C8: E5DF0426    ;     ldrb R0, step_b
000006CC: E3500001    ;     cmp R0, #1
000006D0: 0A00000F    ;     beq setupCustomskipslow
000006D4:             ; 
000006D4: E3510001    ;     cmp R1, #1 ;;if erase is on
000006D8: E28F004B    ;     adrl R0, warneraseslow
000006DC: E2800C07    ; 
000006E0: 0F000003    ;     swieq 3
000006E4:             ; 
000006E4: E3A01001    ;     mov R1, #1
000006E8:             ;  
000006E8: E28F0E67    ;     adrl R0, askslow
000006EC: E2800000    ; 
000006F0: EF000003    ;     swi 3
000006F4: EF000001    ;     swi 1
000006F8: EF000000    ;     swi 0 
000006FC: E3500059    ;     cmp R0, #'Y' 
00000700: E3A0000A    ;     ldr R0, =nlchar
00000704: EF000000    ;     swi 0
00000708: 13A01000    ;     movne R1, #0
0000070C: E5CF13E1    ;     strb R1, slow_b
00000710:             ; 
00000710: EA000001    ;     b setupCustomDimsCheck
00000714:             ; 
00000714:             ; setupCustomskipslow
00000714: E3A00000    ;     mov R0, #0
00000718: E5CF03D5    ;     strb R0, slow_b
0000071C:             ;     
0000071C:             ; setupCustomDimsCheck
0000071C: E3540000    ;     cmp R4, #0
00000720: 0A000027    ;     beq customend
00000724:             ; 
00000724: E28F003D    ;     adrl R0, askwid
00000728: E2800C07    ; 
0000072C: EF000003    ;     swi 3
00000730:             ;     
00000730:             ; getwid
00000730: E3A0000A    ;     ldr R0, =enter
00000734: E3A01002    ;     mov R1, #2
00000738: E3A02001    ;     mov R2, #1
0000073C: EBFFFF12    ;     bl getstring
00000740:             ; 
00000740: EBFFFEC7    ;     bl strtoi
00000744:             ; 
00000744: E1A01000    ;     mov R1, R0
00000748:             ; 
00000748: EBFFFE7F    ;     bl newline
0000074C:             ; 
0000074C: E351001E    ;     cmp R1, #30
00000750: CA000003    ;     bgt getwidFail
00000754: E3510000    ;     cmp R1, #0
00000758: DA000001    ;     ble getwidFail
0000075C:             ; 
0000075C: E5CF1393    ;     strb R1, width
00000760:             ; 
00000760: EA000003    ;     b getheisetup
00000764:             ; 
00000764:             ; getwidFail
00000764: E28F003A    ;     adrl R0, getwidfailmsg
00000768: E2800C07    ; 
0000076C: EF000003    ;     swi 3
00000770:             ; 
00000770: EAFFFFEE    ;     b getwid
00000774:             ; 
00000774:             ; getheisetup
00000774: E28F000B    ;     adrl R0, askhei
00000778: E2800C07    ; 
0000077C: EF000003    ;     swi 3
00000780:             ; 
00000780:             ; gethei
00000780: E3A0000A    ;     ldr R0, =enter
00000784: E3A01002    ;     mov R1, #2
00000788: E3A02001    ;     mov R2, #1
0000078C: EBFFFEFE    ;     bl getstring
00000790:             ; 
00000790: EBFFFEB3    ;     bl strtoi
00000794:             ; 
00000794: E1A01000    ;     mov R1, R0
00000798:             ; 
00000798: EBFFFE6B    ;     bl newline
0000079C:             ; 
0000079C: E351001E    ;     cmp R1, #30
000007A0: CA000003    ;     bgt getheiFail
000007A4: E3510000    ;     cmp R1, #0
000007A8: DA000001    ;     ble getheiFail
000007AC:             ; 
000007AC: E5CF1344    ;     strb R1, height
000007B0:             ; 
000007B0: EA000003    ;     b customend
000007B4:             ; 
000007B4:             ; getheiFail
000007B4: E28F0026    ;     adrl R0, getheifailmsg
000007B8: E2800C07    ; 
000007BC: EF000003    ;     swi 3
000007C0:             ; 
000007C0: EAFFFFEE    ;     b gethei
000007C4:             ; 
000007C4:             ; customend
000007C4: E8BD4010    ;     pop {R14, R4}
000007C8: E1A0F00E    ;     mov R15, R14 ;;RET
000007CC:             ; 
000007CC:             ; 
000007CC:             ; updategrid
000007CC:             ; ;;INP in R0 is the active grid
000007CC:             ; ;;INP in R1 is the passive grid
000007CC:             ; ;;passive grid is the one being updated based on the value in the activeGrid
000007CC:             ; ;;RET --
000007CC:             ; ;;for row from 0 to height - 1
000007CC:             ; ;;  for col from 0 to width - 1
000007CC:             ; ;;      int n = countNeighbours(activeGrid, row, col)
000007CC:             ; ;;      int s = activeGrid[row][col]
000007CC:             ; ;;      
000007CC:             ; ;;      if (s == alive)
000007CC:             ; ;;          passiveGrid[row][col] = n == 3 or n == 2
000007CC:             ; ;;      else
000007CC:             ; ;;          passiveGrid[row][col] = n == 3
000007CC:             ; 
000007CC:             ; ;;  R4 holds the row
000007CC:             ; ;;  R5 holds the col
000007CC:             ; ;;  R6 holds the width
000007CC:             ; ;;  R7 holds the height
000007CC:             ; ;;  R8 holds the active grid
000007CC:             ; ;;  R9 holds the passive grid
000007CC:             ; 
000007CC: E92D47F0    ;     push {R14, R4-R10}
000007D0:             ; 
000007D0: E5DF631F    ;     ldrb R6, width
000007D4: E5DF731C    ;     ldrb R7, height
000007D8:             ; 
000007D8: E1A08000    ;     mov R8, R0
000007DC: E1A09001    ;     mov R9, R1
000007E0:             ; 
000007E0: E3A04000    ;     mov R4, #0 ;;row
000007E4:             ; updategridrowloop
000007E4: E1540007    ;     cmp R4, R7
000007E8: 0A00001A    ;     beq updategridrowlend
000007EC:             ; 
000007EC: E3A05000    ;     mov R5, #0 ;;col
000007F0:             ; updategridcolloop
000007F0: E1550006    ;     cmp R5, R6
000007F4: 0A000014    ;     beq updategridccollend
000007F8:             ; 
000007F8: E1A00008    ;     mov R0, R8
000007FC: E1A01004    ;     mov R1, R4
00000800: E1A02005    ;     mov R2, R5
00000804: EB000015    ;     bl countneighbours
00000808:             ; 
00000808: E0215694    ;     mla R1, R4, R6, R5 ;;R1 = row * width + col
0000080C: E7D82001    ;     ldrb R2, [R8, R1] ;;grid[R1]
00000810:             ;     ;;R0 holds the n count
00000810: E3520000    ;     cmp R2, #0
00000814: 0A000006    ;     beq updatedead
00000818:             ; 
00000818:             ; updatealive
00000818: E3A03000    ;     mov R3, #0
0000081C: E3500003    ;     cmp R0, #3
00000820: 03A03001    ;     moveq R3, #1
00000824: E3500002    ;     cmp R0, #2
00000828: 03A03001    ;     moveq R3, #1
0000082C: E7C93001    ;     strb R3, [R9, R1]
00000830: EA000003    ;     b updatelcont
00000834:             ; 
00000834:             ; updatedead
00000834: E3A03001    ;     mov R3, #1
00000838: E3500003    ;     cmp R0, #3
0000083C: 13A03000    ;     movne R3, #0
00000840: E7C93001    ;     strb R3, [R9, R1]
00000844:             ; 
00000844:             ; updatelcont
00000844: E2855001    ;     add R5, R5, #1
00000848: EAFFFFE8    ;     b updategridcolloop
0000084C:             ; 
0000084C:             ; updategridccollend
0000084C: E3A05000    ;     mov R5, #0
00000850: E2844001    ;     add R4, R4, #1
00000854: EAFFFFE2    ;     b updategridrowloop
00000858:             ; 
00000858:             ; updategridrowlend
00000858:             ; updategridend
00000858: E8BD47F0    ;     pop {R14, R4-R10}
0000085C: E1A0F00E    ;     mov R15, R14
00000860:             ; 
00000860:             ; 
00000860:             ; countneighbours
00000860:             ; ;;INP in R0 is the activeGrid
00000860:             ; ;;INP in R1 is the row
00000860:             ; ;;INP in R2 is the col
00000860:             ; ;;OUT in R0 is the number of neighbours
00000860:             ; 
00000860:             ; ;;offsets = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
00000860:             ; ;;tot = 0
00000860:             ; ;;for offset in offsets
00000860:             ; ;;  if (isinrange(row + offset[0], col + offset[1]))
00000860:             ; ;;      tot += grid[row + offset[0]][col + offset[1]]
00000860:             ; ;;return tot
00000860: E92D4FF0    ;     push {R14, R4-R11} ;;I used the fp before I knew it wasn't a general purpose one, its fine 
                      ; in this context anyway
00000864:             ; 
00000864: E28F4D09    ;     adrl R4, offsets ;;holds the offset
00000868:             ; 
00000868: E1A07000    ;     mov R7, R0
0000086C: E1A08001    ;     mov R8, R1
00000870: E1A09002    ;     mov R9, R2
00000874: E3A0A000    ;     mov R10, #0 ;;R10 holds the total
00000878: E5DFB277    ;     ldrb R11, width;;R11 holds the width of the grid
0000087C:             ; 
0000087C: E3A03000    ;     mov R3, #0
00000880:             ; 
00000880:             ; countneighboursloop
00000880: E3530008    ;     cmp R3, #8 ;;change this ccheck to be for R4
00000884: 0A00000F    ;     beq countneighbourslend
00000888:             ; 
00000888: E4945004    ;     ldr R5, [R4], #4
0000088C: E4946004    ;     ldr R6, [R4], #4
00000890:             ; 
00000890: E0880005    ;     add R0, R8, R5
00000894: E0891006    ;     add R1, R9, R6
00000898:             ; 
00000898: E2833001    ;     add R3, R3, #1
0000089C:             ; 
0000089C: E92D0008    ;     push {R3} ;;I should probably be using a local var on the stack, but I don't yet know how t
                      ; o setup a stack frame properly
000008A0: EB00000B    ;     bl isinrange
000008A4: E8BD0008    ;     pop {R3}
000008A8:             ; 
000008A8: E3500000    ;     cmp R0, #0
000008AC: 0A000004    ;     beq countneighboursskipadd
000008B0:             ; 
000008B0: E0880005    ;     add R0, R8, R5 ;;new row
000008B4: E0891006    ;     add R1, R9, R6 ;;new col ;;can assume that R0, R1 haven't changed as isinrange doesn't edit
                      ;  them, but I'm going to for now
000008B8:             ; 
000008B8: E0201B90    ;     mla R0, R0, R11, R1 ;;find offset
000008BC: E7D70000    ;     ldrb R0, [R7, R0]
000008C0: E08AA000    ;     add R10, R10, R0 ;;tot += grid[newrow][newcol]
000008C4:             ; 
000008C4:             ; countneighboursskipadd
000008C4: EAFFFFED    ;     b countneighboursloop
000008C8:             ; 
000008C8:             ; countneighbourslend
000008C8:             ; countneighboursend
000008C8: E1A0000A    ;     mov R0, R10
000008CC: E8BD4FF0    ;     pop {R14, R4-R11}
000008D0: E1A0F00E    ;     mov R15, R14
000008D4:             ; 
000008D4:             ; 
000008D4:             ; isinrange
000008D4:             ; ;;INP in R0 is the row
000008D4:             ; ;;INP in R1 is the col
000008D4:             ; ;;Uses defined width and height
000008D4:             ; ;;RET in R0 is 1 if is in range else 0
000008D4: E3A02001    ;     mov R2, #1 ;;is valid unless...
000008D8:             ; 
000008D8: E3500000    ;     cmp R0, #0
000008DC: BA000009    ;     blt isinrangefail
000008E0:             ; 
000008E0: E3510000    ;     cmp R1, #0
000008E4: BA000007    ;     blt isinrangefail
000008E8:             ; 
000008E8: E5DF3207    ;     ldrb R3, width
000008EC: E1510003    ;     cmp R1, R3
000008F0: AA000004    ;     bge isinrangefail
000008F4:             ; 
000008F4: E5DF31FC    ;     ldrb R3, height
000008F8: E1500003    ;     cmp R0, R3
000008FC: AA000001    ;     bge isinrangefail
00000900:             ; 
00000900: E3A00001    ;     mov R0, #1
00000904: EA000000    ;     b isinrangeend
00000908:             ; 
00000908:             ; isinrangefail
00000908: E3A00000    ;     mov R0, #0
0000090C:             ; 
0000090C:             ; isinrangeend
0000090C: E1A0F00E    ;     mov R15, R14
00000910:             ; 
00000910:             ; 
00000910:             ; ;; The heap will be a linked list of free blocks - unlike the Comodo version which stores both 
                      ; free & taken blocks 
00000910:             ; ;; This is an idea I'm stealing from the C programming book
00000910:             ; ;; Crate structure
00000910:             ; ;;  |-ptr to next crate (1 word)
00000910:             ; ;;  |-ptr to prev crate (1 word)
00000910:             ; ;;  `-Size (bytes)      (1 word)
00000910:             ; ;; 
00000910:             ; 
00000910:             ; ;;  Traversal of the heap
00000910:             ; ;;  Unlink in my Comodo implimentation the heap is not a linked list of all Crates (free or not
                      ; )
00000910:             ; ;;  That made traversing the heap for debugging purposes very easy, in this case taken crates d
                      ; o not point to the next
00000910:             ; ;;  Instead could start at head and then just go to addr + sizeof(Crate) + size. This should ta
                      ; ke us to the next crate, free or not
00000910:             ; ;;  
00000910:             ; setupHeap
00000910:             ; ;;NO INP
00000910:             ; ;;NO OUT
00000910:             ;     ;;we have the heapstart
00000910:             ;     ;;the end of the heap will be 0x100000 (it will overlap with the stack :) )
00000910: E59F0190    ;     ldr R0, heaphead ;;stores the mem addr of the start of the heap
00000914: E3A01601    ;     ldr R1, =max_addr ;;stores the end of the heap
00000918: E3A02801    ;     ldr R2, =stack_size
0000091C: E0411002    ;     sub R1, R1, R2
00000920:             ; 
00000920: E0411000    ;     sub R1, R1, R0  ;;HEAPEND - HEAPSTART = TOTAL STORAGE (bytes)
00000924: E241100C    ;     sub R1, R1, #12 ;;SIZE -= SIZEOF(CRATE) (12 bytes)
00000928: E5801008    ;     str R1, [R0, #8] ;;set the size of the crate
0000092C: E3A01000    ;     mov R1, #0
00000930: E5801004    ;     str R1, [R0, #4] ;;set the prev ptr
00000934: E5801000    ;     str R1, [R0, #0] ;;set the next ptr
00000938:             ; 
00000938: E1A0F00E    ;     mov R15, R14
0000093C:             ; 
0000093C:             ; ;; The heap is a linked list of free Crates and so find the header and then go though until one
                      ;  satifies the size requirement
0000093C:             ; ;;  end if next is 0
0000093C:             ; ;;  once found either take over the crate or split it into two new crates
0000093C:             ; ;;  align the bytes amount to 8 byte boundry
0000093C:             ; malloc
0000093C:             ; ;;INP into R0 bytes to allocate
0000093C:             ; ;;OUT into R0 the ptr to the memory or 0 for no memory allocated
0000093C:             ;     ;;step 1 align the bytes
0000093C:             ;     ;;1001010 & 0111 = 0000010 ;2
0000093C:             ;     ;;if 0 goto alignend
0000093C:             ;     ;;1001010 + (8 - 2)
0000093C: E92D0010    ;     push {R4}
00000940:             ; 
00000940: E2001007    ;     and R1, R0, #0b0111
00000944: E3510000    ;     cmp R1, #0
00000948: 0A000002    ;     beq mallignend
0000094C: E3A03008    ;     mov R3, #0b1000
00000950: E0432001    ;     sub R2, R3, R1
00000954: E0800002    ;     add R0, R0, R2
00000958:             ; 
00000958:             ; mallignend
00000958: E59F1148    ;     ldr R1, heaphead ;;stores a ptr to the first block
0000095C:             ;     
0000095C:             ; checkcrate
0000095C: E5912008    ;     ldr R2, [R1, #8] ;;Size of the crate
00000960: E1500002    ;     cmp R0, R2 ;;bytes needed - bytes in crate
00000964: DA000006    ;     ble foundcrate
00000968: E5912000    ;     ldr R2, [R1, #0] ;;get the next ptr
0000096C: E3520000    ;     cmp R2, #0
00000970: 0A000001    ;     beq nocrates
00000974: E1A01002    ;     mov R1, R2 ;;swap the current crate with the next crate
00000978: EAFFFFF7    ;     b checkcrate
0000097C:             ; nocrates
0000097C: E3A00000    ;     mov R0, #0
00000980: EA000015    ;     b mallocEnd
00000984:             ; 
00000984:             ; foundcrate
00000984:             ;     ;;Once a crate that we can use has been found we need to either split the crate or use the 
                      ; crate
00000984:             ;     ;;We should use the whole crate only when its size < bytesneeded + CrateHeader + 8
00000984:             ;     ;;This would give the edge case crate 8 bytes
00000984:             ;     
00000984:             ;     ;;R1 holds the found crate ptr
00000984:             ;     ;;R0 is the bytes requested and aligned
00000984: E2802014    ;     add R2, R0, #20 ;;A crate header is 12 bytes + the extra 8 bytes minimum
00000988: E5913008    ;     ldr R3, [R1, #8]
0000098C: E1530002    ;     cmp R3, R2
00000990: BA00000C    ;     blt usecrate
00000994:             ; splitcrate
00000994:             ;     ;;In this case we have a large crate that should be split up.
00000994:             ;     ;;ATM the crate will just be split up to where the requested memory is at the end of the fr
                      ; ee Crate.
00000994:             ; 
00000994: E5913008    ;     ldr R3, [R1, #8] ;;The size of the toSplit Crate
00000998: E0433000    ;     sub R3, R3, R0 ;; size - bytesRequested
0000099C: E243300C    ;     sub R3, R3, #12 ;; size - bytesRequested - sizeof(Crate)
000009A0: E5813008    ;     str R3, [R1, #8] ;;toSplit->size = newSize
000009A4:             ; 
000009A4: E0833001    ;     add R3, R3, R1 ;; newSize + toSplit.addr
000009A8: E283400C    ;     add R4, R3, #12 ;; newSize + toSplit.addr + sizeof(Crate) = position of new Crate
000009AC:             ; 
000009AC:             ;     ;;Setup the header for the newCrate
000009AC: E3A02000    ;     mov R2, #0
000009B0: E5842000    ;     str R2, [R4, #0] ;;next = 0
000009B4: E5842004    ;     str R2, [R4, #4] ;;prev = 0
000009B8: E5840008    ;     str R0, [R4, #8] ;;size = requested and aligned
000009BC:             ; 
000009BC:             ;     ;;MAYBE: can the crates that are taken have a smaller header than those that are free. Take
                      ; n crates need not store the next, prev free nodes
000009BC:             ;     ;;This may complicate things as size would need to be moved around and the size from taken 
                      ; to free would be different. 
000009BC:             ; 
000009BC: E284400C    ;     add R4, R4, #12
000009C0:             ; 
000009C0: E1A00004    ;     mov R0, R4
000009C4:             ; 
000009C4: EA000004    ;     b mallocEnd
000009C8:             ; 
000009C8:             ; usecrate
000009C8:             ;     ;; Simplest option as we can just remove it from the list
000009C8:             ;     ;; c1 <-> c2 <-> c3 ==> c1 <-> c3
000009C8: E5912000    ;     ldr R2, [R1, #0] ;;next ptr
000009CC: E5913004    ;     ldr R3, [R1, #4] ;;prev ptr
000009D0: E5823004    ;     str R3, [R2, #4] ;;Store c1 into c3's previous
000009D4: E5832000    ;     str R2, [R3, #0] ;;Store c3 into c1's next
000009D8:             ; 
000009D8: E1A00001    ;     mov R0, R1 ;;move the found crate's address into the return register ;;The crate header is 
                      ; no longer needed
000009DC:             ; 
000009DC:             ; mallocEnd
000009DC: E8BD0010    ;     pop {R4}
000009E0: E1A0F00E    ;     mov R15, R14
000009E4:             ; 
000009E4:             ; free
000009E4:             ; ;;INP in R0 is the mem addr of the data to be freed
000009E4:             ; ;;OUT in R0 is the success code - 0 for mem freed, ¬0 for error ;;probably won't be currently 
                      ; used `=(- -)=' 
000009E4:             ;     ;;In order to free memory we need to add it back to the linked list
000009E4:             ;     ;;Following K&R's version the linked list will be ordered by address this will make finding
                      ;  consecutive memory locations that should be combined easier
000009E4:             ; 
000009E4:             ;     ;;The inputted address of the crate is the address given in malloc and so the start of the 
                      ; crate is that addr - sizeof(Crate) (#12)
000009E4:             ; 
000009E4:             ;     ;;heapHead = first Crate
000009E4:             ;     ;;current = heapHead
000009E4:             ;     ;;while (toFree.addr > current.addr)
000009E4:             ;     ;;  current = current.next
000009E4:             ;     ;;
000009E4:             ;     ;;//Add the toFree Crate inbetween the current and its previous i.e.  A<->B<->C, toFree = D
                      ;  (addr < C, addr > B) ==> A<->B<->D<->C
000009E4:             ;     ;;current->prev->next = toFree
000009E4:             ;     ;;toFree->prev = current.prev
000009E4:             ;     ;;current->prev = toFree
000009E4:             ;     ;;toFree->next = current
000009E4:             ; 
000009E4:             ;     ;; Crate structure
000009E4:             ;     ;;  |-ptr to next crate (1 word)
000009E4:             ;     ;;  |-ptr to prev crate (1 word)
000009E4:             ;     ;;  `-Size (bytes)      (1 word)
000009E4:             ; 
000009E4: E92D01F0    ;     push {R4-R8}
000009E8:             ; 
000009E8: E59F10B8    ;     ldr R1, heaphead ;;R1 will hold the current
000009EC: E240000C    ;     sub R0, R0, #12 ;;subtract sizeof(Crate) to get header pointer
000009F0:             ; freeloop
000009F0: E5912000    ;     ldr R2, [R1, #0] ;;load the ptr to the next
000009F4: E1520000    ;     cmp R2, R0 ;;compare the address of the toFree to the address of current->next
000009F8:             ; 
000009F8: AA000003    ;     bge freelend ;;current->next.addr >= toFree.addr
000009FC:             ; 
000009FC: E3520000    ;     cmp R2, #0 ;;If there are no more Crates to the right then this could be a new Crate at the
                      ;  end or |F|T| it should merge left 
00000A00: 0A000009    ;     beq freelendEnd
00000A04:             ; 
00000A04: E1A01002    ;     mov R1, R2 ;;current = current.next
00000A08:             ; 
00000A08: EAFFFFF8    ;     b freeloop
00000A0C:             ; 
00000A0C:             ; freelend
00000A0C:             ;     ;; R1 holds the current (left)
00000A0C:             ;     ;; R2 holds the c->next (right)
00000A0C: E5912000    ;     ldr R2, [R1, #0]
00000A10:             ; 
00000A10:             ;     ;;Setup the ptrs for the crates this will help later on   left<->toFree<->right ;;left,righ
                      ; t can be 0
00000A10:             ;     ;;We're just adding the new crate to the linked list
00000A10:             ;     ;;current->next->prev = toFree
00000A10:             ;     ;;toFree->next = current->next
00000A10:             ;     ;;current->next = toFree
00000A10:             ;     ;;toFree->prev = current
00000A10:             ; 
00000A10: E5913000    ;     ldr R3, [R1, #0] ;;holds current->next
00000A14: E3530000    ;     cmp R3, #0
00000A18: 15830004    ;     strne R0, [R3, #4] ;;current->next->prev = toFree
00000A1C: E5803000    ;     str R3, [R0, #0] ;;toFree->next = current->next
00000A20: E5810000    ;     str R0, [R1, #0] ;;current->next = toFree
00000A24: E5801004    ;     str R1, [R0, #4] ;;toFree->prev = current
00000A28:             ; 
00000A28: EA000001    ;     b freeMergeCheck
00000A2C:             ; 
00000A2C:             ; freelendEnd
00000A2C:             ; ;;If there are no more Crates to the right then this could be a new Crate at the end or |F|T| i
                      ; t should merge left 
00000A2C:             ; ;;Found a crate (current) that is to the left of the crate as we ran out of ->next ptrs
00000A2C:             ; ;;Need to set current->next = toFree
00000A2C:             ; ;;            toFree->prev = current
00000A2C: E5801004    ;     str R1, [R0, #4] ;;toFree->prev = current
00000A30: E5810000    ;     str R0, [R1, #0] ;;current->next = toFree
00000A34:             ; 
00000A34:             ; freeMergeCheck
00000A34:             ;     ;;We have a ptr to current. This should be the closest Crate to the left of toFree
00000A34:             ;     ;;We also have the next Crate (null or not) which is to the right of toFree
00000A34:             ;     ;;Both of these crates MAY need to be merged but could also have taken crates in between
00000A34:             ;     ;;First is to check if the crates are adjacent
00000A34:             ;     ;;  If they are NOT then create a newCrate
00000A34:             ;     ;;  If they are     then merge both
00000A34:             ;     ;;  If only one     then merge either left or right
00000A34:             ; 
00000A34:             ;     ;;R1 will be left
00000A34:             ;     ;;R2 will be right
00000A34:             ; 
00000A34: E3510000    ;     cmp R1, #0
00000A38: 01A01000    ;     moveq R1, R0 ;;If there is no left crate then left=toFree
00000A3C: E3520000    ;     cmp R2, #0
00000A40: 01A02000    ;     moveq R2, R0 ;;If there is no right crate (more likely) then right=toFree
00000A44:             ; 
00000A44:             ; verifyLeft
00000A44:             ;     ;;Check if the left is adjacent
00000A44:             ;     ;;It will be if (left.addr + sizeof(Crate) + left.size == toFree.addr)
00000A44:             ; 
00000A44: E5913008    ;     ldr R3, [R1, #8]
00000A48: E283300C    ;     add R3, R3, #12 ;;12 is sizeof(Crate) + toFree.size
00000A4C: E0833001    ;     add R3, R3, R1 ;;left.addr + left->size ??
00000A50:             ; 
00000A50: E1530000    ;     cmp R3, R0
00000A54: 11A01000    ;     movne R1, R0
00000A58:             ; 
00000A58:             ; verifyRight
00000A58:             ;     ;;Going from toFree to Right
00000A58: E5903008    ;     ldr R3, [R0, #8] ;;get size of toFree
00000A5C: E283300C    ;     add R3, R3, #12 ;;12 is sizeof(Crate) + toFree.size
00000A60: E0833000    ;     add R3, R3, R0 ;; + toFree.addr
00000A64:             ; 
00000A64: E1530002    ;     cmp R3, R2
00000A68: 11A02000    ;     movne R2, R0
00000A6C:             ; 
00000A6C:             ; merge
00000A6C:             ;     ;;Merge the two Crates given in R1 and R2
00000A6C:             ;     ;;left can be (left) or (toFree)
00000A6C:             ;     ;;right can be (right) or (toFree)
00000A6C:             ;     ;;If left == right: don't merge; create new Crate
00000A6C:             ;     ;;If left != right: then add to left's size
00000A6C:             ; 
00000A6C: E1510002    ;     cmp R1, R2
00000A70: 0A00000A    ;     beq mergeNew
00000A74:             ; 
00000A74:             ;     ;;The new size is right.addr - left.addr + right->size    from right.addr - left.addr - siz
                      ; eof(Crate) + sizeof(Crate) + right->size
00000A74:             ;     ;;                                                               |left      |right
00000A74:             ;     ;;                                                               |<12>|size||<12>|size|
00000A74:             ;     ;;
00000A74:             ;     ;;                                                               |left      
00000A74:             ;     ;;                                                               |<12>|size           |
00000A74:             ;     ;;
00000A74:             ;     ;;I'm doing it this way as the left and right may not be contiguous i.e. if toFree has a fr
                      ; ee crate on either side
00000A74:             ; 
00000A74: E0423001    ;     sub R3, R2, R1
00000A78: E5924008    ;     ldr R4, [R2, #8]
00000A7C: E0833004    ;     add R3, R3, R4
00000A80: E5813008    ;     str R3, [R1, #8]
00000A84:             ; 
00000A84:             ;     ;;Time to switch some ptrs
00000A84:             ;     ;;Current state left.prev<->left<->right<->right.next (with left or right = toFree) or left
                      ; .prev<->left<->toFree<->right<->right.next
00000A84:             ;     ;;New state would be left.prev<->left<->right.next (with left or right = toFree) or left.pr
                      ; ev<->left<->right.next
00000A84:             ;     ;;Both cases end the same, so get right.next. These could be 0 but it doesn't matter
00000A84:             ;     ;;Next need to change the prev and next ptrs for adjacent Crates
00000A84:             ;     ;;i.e. right->next->prev = left
00000A84:             ; 
00000A84: E5924000    ;     ldr R4, [R2, #0] ;;right->next
00000A88: E1540001    ;     cmp R4, R1
00000A8C: 15814000    ;     strne R4, [R1, #0] ;;left->next = right->next
00000A90: 13A04000    ;     movne R4, #0
00000A94: 15814000    ;     strne R4, [R1, #0]
00000A98:             ; 
00000A98: E3540000    ;     cmp R4, #0
00000A9C: 15841004    ;     strne R1, [R4, #4] ;;right->next->prev = left
00000AA0:             ; 
00000AA0:             ; mergeNew
00000AA0:             ;     ;;The crate has already been setup with its ptrs and had its size as well so don't need to 
                      ; do anything
00000AA0:             ; 
00000AA0:             ; freeEnd
00000AA0: E8BD01F0    ;     pop {R4-R8}
00000AA4: E1A0F00E    ;     mov R15, R14
00000AA8:             ; 
00000AA8:             ; align
00000AA8:             ; ;;Integer defs
00000AA8: 00010000    ; heaphead        defw 0x10000 ;;default start changed to addr of heapstart
00000AAC: FFFFFFFF    ; offsets         defw -1,-1,-1,0,-1,1,0,-1,0,1,1,-1,1,0,1,1 ;;[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1
00000AB0: FFFFFFFF    ; ],[1,-1],[1,0],[1,1]]
00000AB4: FFFFFFFF    ; 
00000AB8: 00000000    ; 
00000ABC: FFFFFFFF    ; 
00000AC0: 00000001    ; 
00000AC4: 00000000    ; 
00000AC8: FFFFFFFF    ; 
00000ACC: 00000000    ; 
00000AD0: 00000001    ; 
00000AD4: 00000001    ; 
00000AD8: FFFFFFFF    ; 
00000ADC: 00000001    ; 
00000AE0: 00000000    ; 
00000AE4: 00000001    ; 
00000AE8: 00000001    ; 
00000AEC:             ; 
00000AEC:             ; ;;Grid addresses
00000AEC: 00000000    ; gridA           defw 0
00000AF0: 00000000    ; gridB           defw 0
00000AF4:             ; 
00000AF4:             ; ;;options
00000AF4: 00          ; erase_b         defb 0
00000AF5: 00          ; slow_b          defb 0
00000AF6: 00          ; step_b          defb 0
00000AF7: 12          ; width           defb 18
00000AF8: 12          ; height          defb 18
00000AF9:             ; 
00000AF9:             ; ;;String defs
00000AF9: 2D 2D 2D 2D ; welcomemsg      defb "-----------Welcome to JCGOL in ARM32-----------\n", 0
00000AFD: 2D 2D 2D 2D ; 
00000B01: 2D 2D 2D 57 ; 
00000B05: 65 6C 63 6F ; 
00000B09: 6D 65 20 74 ; 
00000B0D: 6F 20 4A 43 ; 
00000B11: 47 4F 4C 20 ; 
00000B15: 69 6E 20 41 ; 
00000B19: 52 4D 33 32 ; 
00000B1D: 2D 2D 2D 2D ; 
00000B21: 2D 2D 2D 2D ; 
00000B25: 2D 2D 2D 0A ; 
00000B29: 00          ; 
00000B2A: 54 6F 20 73 ; welcome2msg     defb "To start a new board press n\nTo load a saved board press l\nTo quit pres
00000B2E: 74 61 72 74 ; s q\n", 0
00000B32: 20 61 20 6E ; 
00000B36: 65 77 20 62 ; 
00000B3A: 6F 61 72 64 ; 
00000B3E: 20 70 72 65 ; 
00000B42: 73 73 20 6E ; 
00000B46: 0A 54 6F 20 ; 
00000B4A: 6C 6F 61 64 ; 
00000B4E: 20 61 20 73 ; 
00000B52: 61 76 65 64 ; 
00000B56: 20 62 6F 61 ; 
00000B5A: 72 64 20 70 ; 
00000B5E: 72 65 73 73 ; 
00000B62: 20 6C 0A 54 ; 
00000B66: 6F 20 71 75 ; 
00000B6A: 69 74 20 70 ; 
00000B6E: 72 65 73 73 ; 
00000B72: 20 71 0A 00 ; 
00000B76: 49 6E 76 61 ; mainchoicefail  defb "Invalid choice please enter 'n' for new board or 'l' for load a board or 
00000B7A: 6C 69 64 20 ; 'q' to close. Not cases sensative\n", 0
00000B7E: 63 68 6F 69 ; 
00000B82: 63 65 20 70 ; 
00000B86: 6C 65 61 73 ; 
00000B8A: 65 20 65 6E ; 
00000B8E: 74 65 72 20 ; 
00000B92: 27 6E 27 20 ; 
00000B96: 66 6F 72 20 ; 
00000B9A: 6E 65 77 20 ; 
00000B9E: 62 6F 61 72 ; 
00000BA2: 64 20 6F 72 ; 
00000BA6: 20 27 6C 27 ; 
00000BAA: 20 66 6F 72 ; 
00000BAE: 20 6C 6F 61 ; 
00000BB2: 64 20 61 20 ; 
00000BB6: 62 6F 61 72 ; 
00000BBA: 64 20 6F 72 ; 
00000BBE: 20 27 71 27 ; 
00000BC2: 20 74 6F 20 ; 
00000BC6: 63 6C 6F 73 ; 
00000BCA: 65 2E 20 4E ; 
00000BCE: 6F 74 20 63 ; 
00000BD2: 61 73 65 73 ; 
00000BD6: 20 73 65 6E ; 
00000BDA: 73 61 74 69 ; 
00000BDE: 76 65 0A 00 ; 
00000BE2: 53 6C 6F 77 ; helpmsg         defb "Slow mode will create a pause between each grid print to make it more rea
00000BE6: 20 6D 6F 64 ; dable - can't use with step mode\nErase mode will erase the previous board before printing the 
00000BEA: 65 20 77 69 ; next - [is 2x slower]\n", 0
00000BEE: 6C 6C 20 63 ; 
00000BF2: 72 65 61 74 ; 
00000BF6: 65 20 61 20 ; 
00000BFA: 70 61 75 73 ; 
00000BFE: 65 20 62 65 ; 
00000C02: 74 77 65 65 ; 
00000C06: 6E 20 65 61 ; 
00000C0A: 63 68 20 67 ; 
00000C0E: 72 69 64 20 ; 
00000C12: 70 72 69 6E ; 
00000C16: 74 20 74 6F ; 
00000C1A: 20 6D 61 6B ; 
00000C1E: 65 20 69 74 ; 
00000C22: 20 6D 6F 72 ; 
00000C26: 65 20 72 65 ; 
00000C2A: 61 64 61 62 ; 
00000C2E: 6C 65 20 2D ; 
00000C32: 20 63 61 6E ; 
00000C36: 27 74 20 75 ; 
00000C3A: 73 65 20 77 ; 
00000C3E: 69 74 68 20 ; 
00000C42: 73 74 65 70 ; 
00000C46: 20 6D 6F 64 ; 
00000C4A: 65 0A 45 72 ; 
00000C4E: 61 73 65 20 ; 
00000C52: 6D 6F 64 65 ; 
00000C56: 20 77 69 6C ; 
00000C5A: 6C 20 65 72 ; 
00000C5E: 61 73 65 20 ; 
00000C62: 74 68 65 20 ; 
00000C66: 70 72 65 76 ; 
00000C6A: 69 6F 75 73 ; 
00000C6E: 20 62 6F 61 ; 
00000C72: 72 64 20 62 ; 
00000C76: 65 66 6F 72 ; 
00000C7A: 65 20 70 72 ; 
00000C7E: 69 6E 74 69 ; 
00000C82: 6E 67 20 74 ; 
00000C86: 68 65 20 6E ; 
00000C8A: 65 78 74 20 ; 
00000C8E: 2D 20 5B 69 ; 
00000C92: 73 20 32 78 ; 
00000C96: 20 73 6C 6F ; 
00000C9A: 77 65 72 5D ; 
00000C9E: 0A 00       ; 
00000CA0: 53 69 6E 67 ; help2msg        defb "Single step mode will prompt for input each time a grid is drawn, you can
00000CA4: 6C 65 20 73 ;  (s)ave the current state or (q)uit to menu", 0
00000CA8: 74 65 70 20 ; 
00000CAC: 6D 6F 64 65 ; 
00000CB0: 20 77 69 6C ; 
00000CB4: 6C 20 70 72 ; 
00000CB8: 6F 6D 70 74 ; 
00000CBC: 20 66 6F 72 ; 
00000CC0: 20 69 6E 70 ; 
00000CC4: 75 74 20 65 ; 
00000CC8: 61 63 68 20 ; 
00000CCC: 74 69 6D 65 ; 
00000CD0: 20 61 20 67 ; 
00000CD4: 72 69 64 20 ; 
00000CD8: 69 73 20 64 ; 
00000CDC: 72 61 77 6E ; 
00000CE0: 2C 20 79 6F ; 
00000CE4: 75 20 63 61 ; 
00000CE8: 6E 20 28 73 ; 
00000CEC: 29 61 76 65 ; 
00000CF0: 20 74 68 65 ; 
00000CF4: 20 63 75 72 ; 
00000CF8: 72 65 6E 74 ; 
00000CFC: 20 73 74 61 ; 
00000D00: 74 65 20 6F ; 
00000D04: 72 20 28 71 ; 
00000D08: 29 75 69 74 ; 
00000D0C: 20 74 6F 20 ; 
00000D10: 6D 65 6E 75 ; 
00000D14: 00          ; 
00000D15: 57 6F 75 6C ; askdefaults     defb "Would you like to use the default settings? Y/n: ", 0
00000D19: 64 20 79 6F ; 
00000D1D: 75 20 6C 69 ; 
00000D21: 6B 65 20 74 ; 
00000D25: 6F 20 75 73 ; 
00000D29: 65 20 74 68 ; 
00000D2D: 65 20 64 65 ; 
00000D31: 66 61 75 6C ; 
00000D35: 74 20 73 65 ; 
00000D39: 74 74 69 6E ; 
00000D3D: 67 73 3F 20 ; 
00000D41: 59 2F 6E 3A ; 
00000D45: 20 00       ; 
00000D47: 45 6E 61 62 ; askerase        defb "Enable erase mode? Y/n: ", 0
00000D4B: 6C 65 20 65 ; 
00000D4F: 72 61 73 65 ; 
00000D53: 20 6D 6F 64 ; 
00000D57: 65 3F 20 59 ; 
00000D5B: 2F 6E 3A 20 ; 
00000D5F: 00          ; 
00000D60: 45 6E 61 62 ; askslow         defb "Enable slow mode? Y/n: ", 0
00000D64: 6C 65 20 73 ; 
00000D68: 6C 6F 77 20 ; 
00000D6C: 6D 6F 64 65 ; 
00000D70: 3F 20 59 2F ; 
00000D74: 6E 3A 20 00 ; 
00000D78: 45 6E 61 62 ; askstep         defb "Enable step mode? Y/n: ", 0
00000D7C: 6C 65 20 73 ; 
00000D80: 74 65 70 20 ; 
00000D84: 6D 6F 64 65 ; 
00000D88: 3F 20 59 2F ; 
00000D8C: 6E 3A 20 00 ; 
00000D90: 43 61 6E 6E ; stepslowwarning defb "Cannot have slow and step mode active at the same time, disabling slow mo
00000D94: 6F 74 20 68 ; de\n", 0
00000D98: 61 76 65 20 ; 
00000D9C: 73 6C 6F 77 ; 
00000DA0: 20 61 6E 64 ; 
00000DA4: 20 73 74 65 ; 
00000DA8: 70 20 6D 6F ; 
00000DAC: 64 65 20 61 ; 
00000DB0: 63 74 69 76 ; 
00000DB4: 65 20 61 74 ; 
00000DB8: 20 74 68 65 ; 
00000DBC: 20 73 61 6D ; 
00000DC0: 65 20 74 69 ; 
00000DC4: 6D 65 2C 20 ; 
00000DC8: 64 69 73 61 ; 
00000DCC: 62 6C 69 6E ; 
00000DD0: 67 20 73 6C ; 
00000DD4: 6F 77 20 6D ; 
00000DD8: 6F 64 65 0A ; 
00000DDC: 00          ; 
00000DDD: 52 65 74 75 ; savedchoice     defb "Return to menu? (n for continue sim) Y/n: ", 0
00000DE1: 72 6E 20 74 ; 
00000DE5: 6F 20 6D 65 ; 
00000DE9: 6E 75 3F 20 ; 
00000DED: 28 6E 20 66 ; 
00000DF1: 6F 72 20 63 ; 
00000DF5: 6F 6E 74 69 ; 
00000DF9: 6E 75 65 20 ; 
00000DFD: 73 69 6D 29 ; 
00000E01: 20 59 2F 6E ; 
00000E05: 3A 20 00    ; 
00000E08: 50 6C 65 61 ; askname         defb "Please enter a name for the grid: ", 0
00000E0C: 73 65 20 65 ; 
00000E10: 6E 74 65 72 ; 
00000E14: 20 61 20 6E ; 
00000E18: 61 6D 65 20 ; 
00000E1C: 66 6F 72 20 ; 
00000E20: 74 68 65 20 ; 
00000E24: 67 72 69 64 ; 
00000E28: 3A 20 00    ; 
00000E2B: 45 72 61 73 ; warneraseslow   defb "Erase mode is active it is recommended to also use slow mode\n", 0
00000E2F: 65 20 6D 6F ; 
00000E33: 64 65 20 69 ; 
00000E37: 73 20 61 63 ; 
00000E3B: 74 69 76 65 ; 
00000E3F: 20 69 74 20 ; 
00000E43: 69 73 20 72 ; 
00000E47: 65 63 6F 6D ; 
00000E4B: 6D 65 6E 64 ; 
00000E4F: 65 64 20 74 ; 
00000E53: 6F 20 61 6C ; 
00000E57: 73 6F 20 75 ; 
00000E5B: 73 65 20 73 ; 
00000E5F: 6C 6F 77 20 ; 
00000E63: 6D 6F 64 65 ; 
00000E67: 0A 00       ; 
00000E69: 50 6C 65 61 ; askwid          defb "Please enter a width (1-30): ", 0
00000E6D: 73 65 20 65 ; 
00000E71: 6E 74 65 72 ; 
00000E75: 20 61 20 77 ; 
00000E79: 69 64 74 68 ; 
00000E7D: 20 28 31 2D ; 
00000E81: 33 30 29 3A ; 
00000E85: 20 00       ; 
00000E87: 50 6C 65 61 ; askhei          defb "Please enter a height (1-30): ", 0
00000E8B: 73 65 20 65 ; 
00000E8F: 6E 74 65 72 ; 
00000E93: 20 61 20 68 ; 
00000E97: 65 69 67 68 ; 
00000E9B: 74 20 28 31 ; 
00000E9F: 2D 33 30 29 ; 
00000EA3: 3A 20 00    ; 
00000EA6: 49 6E 76 61 ; getwidfailmsg   defb "Invalid width please enter a value between 1-30 inclusive: ", 0
00000EAA: 6C 69 64 20 ; 
00000EAE: 77 69 64 74 ; 
00000EB2: 68 20 70 6C ; 
00000EB6: 65 61 73 65 ; 
00000EBA: 20 65 6E 74 ; 
00000EBE: 65 72 20 61 ; 
00000EC2: 20 76 61 6C ; 
00000EC6: 75 65 20 62 ; 
00000ECA: 65 74 77 65 ; 
00000ECE: 65 6E 20 31 ; 
00000ED2: 2D 33 30 20 ; 
00000ED6: 69 6E 63 6C ; 
00000EDA: 75 73 69 76 ; 
00000EDE: 65 3A 20 00 ; 
00000EE2: 49 6E 76 61 ; getheifailmsg   defb "Invalid height please enter a value between 1-30 inclusive: ", 0
00000EE6: 6C 69 64 20 ; 
00000EEA: 68 65 69 67 ; 
00000EEE: 68 74 20 70 ; 
00000EF2: 6C 65 61 73 ; 
00000EF6: 65 20 65 6E ; 
00000EFA: 74 65 72 20 ; 
00000EFE: 61 20 76 61 ; 
00000F02: 6C 75 65 20 ; 
00000F06: 62 65 74 77 ; 
00000F0A: 65 65 6E 20 ; 
00000F0E: 31 2D 33 30 ; 
00000F12: 20 69 6E 63 ; 
00000F16: 6C 75 73 69 ; 
00000F1A: 76 65 3A 20 ; 
00000F1E: 00          ; 
00000F1F: 55 73 69 6E ; usingDefault    defb "Using default values: dims=(18, 18) slowMode=Off eraseMode=Off stepMode=O
00000F23: 67 20 64 65 ; ff", nlchar, 0
00000F27: 66 61 75 6C ; 
00000F2B: 74 20 76 61 ; 
00000F2F: 6C 75 65 73 ; 
00000F33: 3A 20 64 69 ; 
00000F37: 6D 73 3D 28 ; 
00000F3B: 31 38 2C 20 ; 
00000F3F: 31 38 29 20 ; 
00000F43: 73 6C 6F 77 ; 
00000F47: 4D 6F 64 65 ; 
00000F4B: 3D 4F 66 66 ; 
00000F4F: 20 65 72 61 ; 
00000F53: 73 65 4D 6F ; 
00000F57: 64 65 3D 4F ; 
00000F5B: 66 66 20 73 ; 
00000F5F: 74 65 70 4D ; 
00000F63: 6F 64 65 3D ; 
00000F67: 4F 66 66 0A ; 
00000F6B: 00          ; 
00000F6C: 43 68 6F 6F ; askgenoption    defb "Choose between (R)andom generation or (D)rawing the grid", 0
00000F70: 73 65 20 62 ; 
00000F74: 65 74 77 65 ; 
00000F78: 65 6E 20 28 ; 
00000F7C: 52 29 61 6E ; 
00000F80: 64 6F 6D 20 ; 
00000F84: 67 65 6E 65 ; 
00000F88: 72 61 74 69 ; 
00000F8C: 6F 6E 20 6F ; 
00000F90: 72 20 28 44 ; 
00000F94: 29 72 61 77 ; 
00000F98: 69 6E 67 20 ; 
00000F9C: 74 68 65 20 ; 
00000FA0: 67 72 69 64 ; 
00000FA4: 00          ; 
00000FA5: 49 6E 76 61 ; setupGrdFailmsg defb "Invalid choice, use `R` for random generation and `d` for drawing the gri
00000FA9: 6C 69 64 20 ; d. Not case sensative: ", 0
00000FAD: 63 68 6F 69 ; 
00000FB1: 63 65 2C 20 ; 
00000FB5: 75 73 65 20 ; 
00000FB9: 60 52 60 20 ; 
00000FBD: 66 6F 72 20 ; 
00000FC1: 72 61 6E 64 ; 
00000FC5: 6F 6D 20 67 ; 
00000FC9: 65 6E 65 72 ; 
00000FCD: 61 74 69 6F ; 
00000FD1: 6E 20 61 6E ; 
00000FD5: 64 20 60 64 ; 
00000FD9: 60 20 66 6F ; 
00000FDD: 72 20 64 72 ; 
00000FE1: 61 77 69 6E ; 
00000FE5: 67 20 74 68 ; 
00000FE9: 65 20 67 72 ; 
00000FED: 69 64 2E 20 ; 
00000FF1: 4E 6F 74 20 ; 
00000FF5: 63 61 73 65 ; 
00000FF9: 20 73 65 6E ; 
00000FFD: 73 61 74 69 ; 
00001001: 76 65 3A 20 ; 
00001005: 00          ; 
00001006: 45 6E 74 65 ; askseed         defb "Enter 4 characters to be used as the seed: ", 0
0000100A: 72 20 34 20 ; 
0000100E: 63 68 61 72 ; 
00001012: 61 63 74 65 ; 
00001016: 72 73 20 74 ; 
0000101A: 6F 20 62 65 ; 
0000101E: 20 75 73 65 ; 
00001022: 64 20 61 73 ; 
00001026: 20 74 68 65 ; 
0000102A: 20 73 65 65 ; 
0000102E: 64 3A 20 00 ; 
00001032: 49 6E 76 61 ; drawfailmsg     defb "Invalid input please enter 1 or 0: ", nlchar, 0
00001036: 6C 69 64 20 ; 
0000103A: 69 6E 70 75 ; 
0000103E: 74 20 70 6C ; 
00001042: 65 61 73 65 ; 
00001046: 20 65 6E 74 ; 
0000104A: 65 72 20 31 ; 
0000104E: 20 6F 72 20 ; 
00001052: 30 3A 20 0A ; 
00001056: 00          ; 
00001057: 47 72 69 64 ; gridfailmsg     defb "Grid was not properly initialised, consider smaller dims", nlchar, 0
0000105B: 20 77 61 73 ; 
0000105F: 20 6E 6F 74 ; 
00001063: 20 70 72 6F ; 
00001067: 70 65 72 6C ; 
0000106B: 79 20 69 6E ; 
0000106F: 69 74 69 61 ; 
00001073: 6C 69 73 65 ; 
00001077: 64 2C 20 63 ; 
0000107B: 6F 6E 73 69 ; 
0000107F: 64 65 72 20 ; 
00001083: 73 6D 61 6C ; 
00001087: 6C 65 72 20 ; 
0000108B: 64 69 6D 73 ; 
0000108F: 0A 00       ; 
00001091:             ; 
00001091:             ; 
00001094:             ; align
00001094: 00000000    ; heapstart       defw 0 ;;points to the end of the data this is where the heap can then begin
00001098:             ; Remaining literals

Symbol Table: Labels
: max_addr                          00100000  Value
: stack_size                        00010000  Value
: nlchar                            0000000A  Value
: backspace                         00000008  Value
: minBuffSize                       00000008  Value
: enter                             0000000A  Value
: minSaveSize                       00000008  Value
: sizeofSaveI                       00000008  Value
: _start                            00000000  Local -- ARM
: main                              00000038  Local -- ARM
: mainchoice                        00000074  Local -- ARM
: newboard                          000000A4  Local -- ARM
: loadboard                         000000CC  Local -- ARM
: mainloopstart                     000000CC  Local -- ARM
: mainloop                          000000F4  Local -- ARM
: gridFail                          00000134  Local -- ARM
: mainEnd                           00000140  Local -- ARM
: newline                           0000014C  Local -- ARM
: step                              00000158  Local -- ARM
: stependfail                       000001A8  Local -- ARM
: stependsucc                       000001B0  Local -- ARM
: stepend                           000001B4  Local -- ARM
: saveGrid                          000001BC  Local -- ARM
: erase                             000001BC  Local -- ARM
: eraseloop                         000001C0  Local -- ARM
: eraseend                          000001D8  Local -- ARM
: slow                              000001DC  Local -- ARM
: slowloop                          000001E4  Local -- ARM
: slowend                           00000204  Local -- ARM
: heapclean                         00000208  Local -- ARM
: heapcleanloop                     00000224  Local -- ARM
: heapcleanend                      00000238  Local -- ARM
: strlen                            0000023C  Local -- ARM
: strlenloop                        00000248  Local -- ARM
: strlenend                         0000025C  Local -- ARM
: strtoi                            00000264  Local -- ARM
: strtoiloop                        000002A4  Local -- ARM
: strtoilend                        000002D8  Local -- ARM
: strtoifailminus                   000002E0  Local -- ARM
: strtoifailoutrange                000002E8  Local -- ARM
: strtoifailnonnum                  000002F0  Local -- ARM
: strtoiendfail                     000002F4  Local -- ARM
: strtoiendsucc                     000002FC  Local -- ARM
: strtoiend                         00000300  Local -- ARM
: memcpy                            00000308  Local -- ARM
: memcpywordsloop                   00000330  Local -- ARM
: memcpywordslend                   00000348  Local -- ARM
: memcpyallbytes                    00000358  Local -- ARM
: memcpybytes                       00000364  Local -- ARM
: memcpybytesloop                   00000368  Local -- ARM
: memcpybyteslend                   00000380  Local -- ARM
: memcpyend                         00000384  Local -- ARM
: getstring                         0000038C  Local -- ARM
: getstringloop                     000003B8  Local -- ARM
: skipMax                           000003D4  Local -- ARM
: getstringlcont                    000003E0  Local -- ARM
: getstringresize                   000003F8  Local -- ARM
: getstringlend                     00000428  Local -- ARM
: getstringResizeEnd                00000434  Local -- ARM
: getstringEnd                      00000460  Local -- ARM
: tolower                           00000474  Local -- ARM
: setupGrid                         0000047C  Local -- ARM
: setupGridAsk                      000004C4  Local -- ARM
: setupdrawing                      000004F4  Local -- ARM
: setuprandom                       000004FC  Local -- ARM
: setupstart                        00000518  Local -- ARM
: setuprowloop                      0000051C  Local -- ARM
: setupcolloop                      00000528  Local -- ARM
: dorandom                          0000053C  Local -- ARM
: dodraw                            00000550  Local -- ARM
: dodrawsucc                        00000574  Local -- ARM
: setupcollcont                     00000578  Local -- ARM
: setupcollend                      00000594  Local -- ARM
: setuprowlend                      0000059C  Local -- ARM
: setupGridFail                     0000059C  Local -- ARM
: setupGridEnd                      0000059C  Local -- ARM
: drawgrid                          000005A4  Local -- ARM
: drawgridrowloop                   000005B8  Local -- ARM
: drawgridcolloop                   000005C4  Local -- ARM
: drawgridcollend                   000005F4  Local -- ARM
: drawgridrowlend                   00000608  Local -- ARM
: drawgridend                       00000610  Local -- ARM
: setupOptions                      00000618  Local -- ARM
: setupCustom                       00000670  Local -- ARM
: setupCustomskipslow               00000714  Local -- ARM
: setupCustomDimsCheck              0000071C  Local -- ARM
: getwid                            00000730  Local -- ARM
: getwidFail                        00000764  Local -- ARM
: getheisetup                       00000774  Local -- ARM
: gethei                            00000780  Local -- ARM
: getheiFail                        000007B4  Local -- ARM
: customend                         000007C4  Local -- ARM
: updategrid                        000007CC  Local -- ARM
: updategridrowloop                 000007E4  Local -- ARM
: updategridcolloop                 000007F0  Local -- ARM
: updatealive                       00000818  Local -- ARM
: updatedead                        00000834  Local -- ARM
: updatelcont                       00000844  Local -- ARM
: updategridccollend                0000084C  Local -- ARM
: updategridrowlend                 00000858  Local -- ARM
: updategridend                     00000858  Local -- ARM
: countneighbours                   00000860  Local -- ARM
: countneighboursloop               00000880  Local -- ARM
: countneighboursskipadd            000008C4  Local -- ARM
: countneighbourslend               000008C8  Local -- ARM
: countneighboursend                000008C8  Local -- ARM
: isinrange                         000008D4  Local -- ARM
: isinrangefail                     00000908  Local -- ARM
: isinrangeend                      0000090C  Local -- ARM
: setupHeap                         00000910  Local -- ARM
: malloc                            0000093C  Local -- ARM
: mallignend                        00000958  Local -- ARM
: checkcrate                        0000095C  Local -- ARM
: nocrates                          0000097C  Local -- ARM
: foundcrate                        00000984  Local -- ARM
: splitcrate                        00000994  Local -- ARM
: usecrate                          000009C8  Local -- ARM
: mallocEnd                         000009DC  Local -- ARM
: free                              000009E4  Local -- ARM
: freeloop                          000009F0  Local -- ARM
: freelend                          00000A0C  Local -- ARM
: freelendEnd                       00000A2C  Local -- ARM
: freeMergeCheck                    00000A34  Local -- ARM
: verifyLeft                        00000A44  Local -- ARM
: verifyRight                       00000A58  Local -- ARM
: merge                             00000A6C  Local -- ARM
: mergeNew                          00000AA0  Local -- ARM
: freeEnd                           00000AA0  Local -- ARM
: heaphead                          00000AA8  Local -- ARM
: offsets                           00000AAC  Local -- ARM
: gridA                             00000AEC  Local -- ARM
: gridB                             00000AF0  Local -- ARM
: erase_b                           00000AF4  Local -- ARM
: slow_b                            00000AF5  Local -- ARM
: step_b                            00000AF6  Local -- ARM
: width                             00000AF7  Local -- ARM
: height                            00000AF8  Local -- ARM
: welcomemsg                        00000AF9  Local -- ARM
: welcome2msg                       00000B2A  Local -- ARM
: mainchoicefail                    00000B76  Local -- ARM
: helpmsg                           00000BE2  Local -- ARM
: help2msg                          00000CA0  Local -- ARM
: askdefaults                       00000D15  Local -- ARM
: askerase                          00000D47  Local -- ARM
: askslow                           00000D60  Local -- ARM
: askstep                           00000D78  Local -- ARM
: stepslowwarning                   00000D90  Local -- ARM
: savedchoice                       00000DDD  Local -- ARM
: askname                           00000E08  Local -- ARM
: warneraseslow                     00000E2B  Local -- ARM
: askwid                            00000E69  Local -- ARM
: askhei                            00000E87  Local -- ARM
: getwidfailmsg                     00000EA6  Local -- ARM
: getheifailmsg                     00000EE2  Local -- ARM
: usingDefault                      00000F1F  Local -- ARM
: askgenoption                      00000F6C  Local -- ARM
: setupGrdFailmsg                   00000FA5  Local -- ARM
: askseed                           00001006  Local -- ARM
: drawfailmsg                       00001032  Local -- ARM
: gridfailmsg                       00001057  Local -- ARM
: heapstart                         00001094  Local -- ARM
