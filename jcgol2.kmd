KMD
00000000:             ; ;;  This is my second rendition of JCGOL in ARM assembly for Komodo
00000000:             ; ;;  
00000000:             ; ;;  This will attempt to follow the ARM 32bit calling convention 
00000000:             ; ;;      R0-3 are argument registers, scratch
00000000:             ; ;;      R4-10 are local variable registers and should be saved before use in a function
00000000:             ; ;;      R11 - FP
00000000:             ; ;;      R12 - IPC
00000000:             ; ;;      R13 - SP
00000000:             ; ;;      R14 - LR
00000000:             ; ;;      R15 - PC
00000000:             ; ;;
00000000:             ; ;;  The plan
00000000:             ; ;;  - Create a simple `heap` allocator for the grid and input
00000000:             ; ;;  - Ask the user
00000000:             ; ;;      |-Use default? Y - skip below
00000000:             ; ;;      |-dims of the grid
00000000:             ; ;;      |   `-Will need a way to get a string input and convert to an integer (make sure to cat
                      ; ch -ve)
00000000:             ; ;;      |-slow mode
00000000:             ; ;;      `-erase mode
00000000:             ; ;;  - ask for generation mode
00000000:             ; ;;      |-If random ask for seed
00000000:             ; ;;      |   `-For generation roll the seed to create a pseudorandom value for each `pixel`
00000000:             ; ;;      `-If draw then get them to draw the grid one `pixel` at a time
00000000:             ; ;;  - Allocate two grids, the pointers to which will swap after a frame. One is used to count t
                      ; he neighbours the other for the new cell value.
00000000:             ; ;;  - loop
00000000:             ; ;;      |-count neighbours
00000000:             ; ;;      |-update inactive grid
00000000:             ; ;;      |-swap grids
00000000:             ; ;;      |-draw active grid
00000000:             ; ;;      `-goto loop
00000000:             ; 
00000000:             ; ;;SINGLE STEP mode allows you to save the current state of the board into a list, also give it 
                      ; a name
00000000:             ; ;;At the main menu you can load a saved grid
00000000:             ; 
00000000:             ; ;;Grid info struct
00000000:             ; ;;  - SaveInfoStruct* array
00000000:             ; ;;  - int max size of arr
00000000:             ; ;;  - int current position in arr
00000000:             ; 
00000000:             ; ;;Save info struct
00000000:             ; ;;  -address of grid [4 BYTES]
00000000:             ; ;;  -char* to the name [4 BYTES]
00000000:             ; ;;  -width of grid (1 BYTE)
00000000:             ; ;;  -height of grid (1 BYTE)
00000000:             ; 
00000000:             ; 
00000000:             ; ;;  CURRENT ISSUES/TODOS
00000000:             ; ;;  `-Think about minimising the fragmentation of the heap - find the best free block instead o
                      ; f the first
00000000:             ;   
00000000:             ; max_addr    EQU  0x100000
00000000:             ; stack_size  EQU  0x10000
00000000:             ; nl          EQU  10
00000000:             ; backspace   EQU  8
00000000:             ; minBuffSize EQU  8
00000000:             ; enter       EQU  nl
00000000:             ; minSaveSize EQU  8
00000000:             ; sizeofSaveI EQU  12 ;;10 bytes + 2 bytes of padding to align to 4 byte boundry for arr
00000000:             ; 
00000000: EA000017    ; b _start
00000004:             ; 
00000004:             ; align
00000004:             ; ;;[[note]]
00000004:             ; ;;ldr instructions out of range (for pc-relative offsets?) of ldr (-4096/+4095?) use below
00000004:             ; ;;  adrl Rx, label
00000004:             ; ;;  ldr  Rx, [Rx]
00000004: 00010000    ; heaphead        defw 0x10000 ;;default start changed to addr of heapstart 
00000008:             ; 
00000008:             ; ;;Integer defs
00000008: FFFFFFFF    ; offsets         defw -1,-1,-1,0,-1,1,0,-1,0,1,1,-1,1,0,1,1 ;;[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1
0000000C: FFFFFFFF    ; ],[1,-1],[1,0],[1,1]]
00000010: FFFFFFFF    ; 
00000014: 00000000    ; 
00000018: FFFFFFFF    ; 
0000001C: 00000001    ; 
00000020: 00000000    ; 
00000024: FFFFFFFF    ; 
00000028: 00000000    ; 
0000002C: 00000001    ; 
00000030: 00000001    ; 
00000034: FFFFFFFF    ; 
00000038: 00000001    ; 
0000003C: 00000000    ; 
00000040: 00000001    ; 
00000044: 00000001    ; 
00000048:             ; 
00000048:             ; ;;Grid addresses
00000048: 00000000    ; gridA           defw 0
0000004C: 00000000    ; gridB           defw 0
00000050:             ; 
00000050:             ; ;;options
00000050: 00          ; erase_b         defb 0
00000051: 00          ; slow_b          defb 0
00000052: 00          ; step_b          defb 0
00000053: 12          ; width           defb 18
00000054: 12          ; height          defb 18
00000055: 01          ; range_min       defb 1
00000056: 1E          ; range_max       defb 30
00000057: 19          ; maxitters       defb 25
00000058: 01          ; drawerase_b     defb 1  ;;Should the draw mode erase previous
00000059:             ; 
00000059: 58          ; alive_c         defb 'X'
0000005A: 2D          ; dead_c          defb '-'
0000005B: 23          ; ptr_c           defb '#'
0000005C:             ; 
0000005C:             ; ;;default options
0000005C: 00          ; erase_b_d       defb 0
0000005D: 00          ; slow_b_d        defb 0
0000005E: 01          ; step_b_d        defb 1
0000005F: 12          ; width_d         defb 18
00000060: 12          ; height_d        defb 18
00000061:             ; 
00000064:             ; align
00000064:             ; 
00000064:             ; _start
00000064:             ;     ;;prepare the stack
00000064: E3A0D601    ;     ldr R13, =max_addr
00000068: E3A0E000    ;     mov R14, #0 ;; allow for `returning` from _start
0000006C: E92D4000    ;     push {R14}
00000070:             ; 
00000070:             ;     ;;[[temp]] clean the heap (zero out)
00000070:             ;     ;;bl heapclean
00000070:             ; 
00000070:             ;     ;;setup heap
00000070: E28F0F77    ;     adrl R0, heapstart
00000074: E2800B0B    ; 
00000078: E50F007C    ;     str R0, heaphead    ;;place address of last instruction (heapstart label) into the heaphead
                      ;  variable
0000007C: EB00064C    ;     bl setupHeap
00000080:             ; 
00000080: EB000002    ;     bl main
00000084:             ; 
00000084: E8BD4000    ;     pop {R14}
00000088: EF000002    ;     swi 2
0000008C: E1A0F00E    ;     mov R15, R14
00000090:             ; 
00000090:             ; main
00000090: E92D4FF0    ;     push {fp, R14, R4-R10} ;;8 registers saved
00000094:             ; 
00000094: E28DB01C    ;     add fp, sp, #28 ;;(r - 1) * 4
00000098: E24DD010    ;     sub sp, sp, #16 ;;reserve 12 bytes (4 bytes to align?) on the stack for the pointer to the 
                      ; list of saved grids + the maxSize of the array
0000009C:             ; 
0000009C:             ;     ;;The gridInfo struct
0000009C:             ;     ;;set the current position of the pointer
0000009C: E3A00000    ;     mov R0, #0
000000A0: E58D0008    ;     str R0, [sp, #8]
000000A4:             ; 
000000A4:             ;     ;;set the number of elements(save info structs) that can be stored in the array at the mome
                      ; nt
000000A4: E3A00008    ;     ldr R0, =minSaveSize
000000A8: E58D0004    ;     str R0, [sp, #4]
000000AC:             ; 
000000AC:             ;     ;;minsize * sizeof(SaveInfo) = number of bytes needed for the array
000000AC: E3A0100C    ;     ldr R1, =sizeofSaveI
000000B0: E0000190    ;     mul R0, R0, R1
000000B4: EB00064B    ;     bl malloc ;;allocate the array on the heap
000000B8:             ; 
000000B8: E3500000    ;     cmp R0, #0
000000BC: 0A000051    ;     beq mainMallocFail
000000C0:             ; 
000000C0: E58D0000    ;     str R0, [sp, #0] ;;store the address
000000C4:             ; 
000000C4:             ; mainmenu
000000C4: E28F0F53    ;     adrl R0, welcomemsg
000000C8: E2800B07    ; 
000000CC: EF000003    ;     swi 3
000000D0:             ; 
000000D0: E28F0F5D    ;     adrl R0, welcome2msg
000000D4: E2800B07    ; 
000000D8: EF000003    ;     swi 3
000000DC:             ; 
000000DC:             ; mainchoice
000000DC: EF000001    ;     swi 1
000000E0: E3800020    ;     orr R0, R0, #32
000000E4: E1A04000    ;     mov R4, R0
000000E8:             ; 
000000E8:             ;     ;;These should really be functions
000000E8:             ; 
000000E8: E354006E    ;     cmp R4, #'n' ;;new board generation
000000EC: 0A00025F    ;     beq newboard
000000F0:             ; 
000000F0: E354006C    ;     cmp R4, #'l' ;;load a saved board
000000F4: E1A0000D    ;     mov R0, sp ;;load the info ptr
000000F8: 0A000270    ;     beq loadboard
000000FC:             ; 
000000FC: E3540073    ;     cmp R4, #'s'
00000100: 0A000100    ;     beq settingsmenu
00000104:             ; 
00000104: E3540070    ;     cmp R4, #'p'
00000108: 0A000005    ;     beq showHeap
0000010C:             ; 
0000010C: E3540071    ;     cmp R4, #'q' ;;quit
00000110: 0A000040    ;     beq mainEnd
00000114:             ; 
00000114: E28F0075    ;     adrl R0, mainchoicefail
00000118: E2800C1D    ; 
0000011C: EF000003    ;     swi 3
00000120:             ; 
00000120: EAFFFFED    ;     b mainchoice
00000124:             ; 
00000124:             ;     ;;R4 will hold the active grid, R5 will hold the passive grid
00000124:             ;     ;;Active is used to count neighbours, passive is used to place updated values in 
00000124:             ;     ;;either can be drawn, just drawn in a different position
00000124:             ; 
00000124:             ; 
00000124:             ; showHeap
00000124: EB000669    ;     bl printHeap
00000128:             ; 
00000128: EAFFFFE5    ;     b mainmenu
0000012C:             ; 
0000012C:             ; ;;update loop
0000012C:             ; ;;    - loop
0000012C:             ; ;;      |-count neighbours
0000012C:             ; ;;      |-update inactive grid
0000012C:             ; ;;      |-swap grids
0000012C:             ; ;;      |-draw grid
0000012C:             ; ;;      |-[slow?] - slow() - loops for some time to increase waiting time
0000012C:             ; ;;      |-[step?] - step() - waits for input, s and q will have effects
0000012C:             ; ;;      |-[erase?] - erase() - \b until grid is gone
0000012C:             ; ;;      `-goto loop
0000012C:             ; mainloopstart
0000012C:             ;     ;;load the slow, step, and erase booleans
0000012C: E55F60E3    ;     ldrb R6, slow_b
00000130: E55F70E8    ;     ldrb R7, erase_b
00000134: E55F80EA    ;     ldrb R8, step_b
00000138:             ; 
00000138: E51F40F8    ;     ldr R4, gridA
0000013C: E51F50F8    ;     ldr R5, gridB
00000140:             ; 
00000140:             ;     ;;(width * height) * 2 + 1 + height
00000140: E55F00F5    ;     ldrb R0, width
00000144: E55F10F8    ;     ldrb R1, height
00000148: E0000190    ;     mul R0, R0, R1
0000014C: E1A00080    ;     mov R0, R0, lsl #1
00000150: E2800001    ;     add R0, R0, #1
00000154: E0800001    ;     add R0, R0, R1
00000158: E1A09000    ;     mov R9, R0      ;;R9 holds the itterations for erase, so it doesn't have to calc it every t
                      ; ime
0000015C:             ; 
0000015C: E3A0A000    ;     mov R10, #0 ;;This will hold the number of itterations, when it reaches 
00000160:             ; 
00000160:             ; mainloop
00000160: E55F0111    ;     ldrb R0, maxitters ;;run out of registers @-@
00000164: E15A0000    ;     cmp R10, R0
00000168: E28AA001    ;     add R10, R10, #1
0000016C: 1A000004    ;     bne mainloopcont
00000170:             ; 
00000170: E3A0A000    ;     mov R10, #0
00000174:             ; 
00000174: E28F0096    ;     adrl R0, mainloopittsmsg
00000178: E2800A02    ; 
0000017C: EF000003    ;     swi 3
00000180:             ; 
00000180: EA000006    ;     b mainloopdostep
00000184:             ; 
00000184:             ; mainloopcont
00000184: E1A00004    ;     mov R0, R4
00000188: E1A01005    ;     mov R1, R5
0000018C: EB0005A5    ;     bl updategrid
00000190:             ; 
00000190: E1A00004    ;     mov R0, R4
00000194: EB000476    ;     bl drawgrid
00000198:             ; 
00000198: E3580001    ;     cmp R8, #1
0000019C: 1A00000D    ;     bne mainloopskipstep
000001A0:             ; 
000001A0:             ; mainloopdostep
000001A0: E1A0000D    ;     mov R0, sp
000001A4: E1A01004    ;     mov R1, R4 ;;give the active grid
000001A8: EB000299    ;     bl step
000001AC: E3500000    ;     cmp R0, #0
000001B0: 0A00000A    ;     beq mainloopskipslow
000001B4:             ;     
000001B4:             ;     ;;If R0 is #1 then free and go to the main menu
000001B4:             ;     ;;free the current grid
000001B4: E51F0174    ;     ldr R0, gridA
000001B8: EB0006AD    ;     bl free
000001BC: E3A01000    ;     mov R1, #0
000001C0: E50F1180    ;     str R1, gridA
000001C4:             ; 
000001C4: E51F0180    ;     ldr R0, gridB
000001C8: EB0006A9    ;     bl free
000001CC: E3A01000    ;     mov R1, #0
000001D0: E50F118C    ;     str R1, gridB
000001D4:             ; 
000001D4: EAFFFFBA    ;     b mainmenu
000001D8:             ; 
000001D8:             ; mainloopskipstep
000001D8: E3560001    ;     cmp R6, #1
000001DC: 0B00032B    ;     bleq slow
000001E0:             ; mainloopskipslow
000001E0: E3570001    ;     cmp R7, #1
000001E4: 01A00009    ;     moveq R0, R9
000001E8: 0B000320    ;     bleq erase
000001EC:             ; 
000001EC: E1A00004    ;     mov R0, R4
000001F0: E1A04005    ;     mov R4, R5
000001F4: E1A05000    ;     mov R5, R0 ;;SWAP the active and passive
000001F8:             ; 
000001F8: EAFFFFD8    ;     b mainloop
000001FC:             ; 
000001FC:             ; gridFail
000001FC: E28F0007    ;     adrl R0, gridfailmsg
00000200: E2800C22    ; 
00000204: EF000003    ;     swi 3
00000208:             ; 
00000208:             ; mainMallocFail
00000208: E28F0095    ;     adrl R0, malloc_panic
0000020C: E2800C2A    ; 
00000210: EF000003    ;     swi 3
00000214:             ; 
00000214: EA00001E    ;     b mainEndEnd
00000218:             ; 
00000218:             ; mainEnd
00000218: E28F0F42    ;     adrl R0, mainendmsg
0000021C: E2800B07    ; 
00000220: EF000003    ;     swi 3
00000224:             ; 
00000224: E1A0000D    ;     mov R0, sp
00000228: EB00001C    ;     bl mainfree
0000022C:             ; 
0000022C: E28F0045    ;     adrl R0, printHeap_end_m
00000230: E2800C2A    ; 
00000234: EF000003    ;     swi 3
00000238:             ; 
00000238: EB000624    ;     bl printHeap
0000023C:             ; 
0000023C:             ; assertheapempty     ;;this should maybe be in _start?
0000023C: E51F0240    ;     ldr R0, heaphead
00000240: E5901000    ;     ldr R1, [R0, #0] ;;next
00000244: E5902008    ;     ldr R2, [R0, #8] ;;size
00000248:             ; 
00000248: E3510000    ;     cmp R1, #0
0000024C: 1A000009    ;     bne assertionfail
00000250:             ; 
00000250: E282200C    ;     add R2, R2, #12
00000254: E0822000    ;     add R2, R2, R0
00000258:             ; 
00000258: E28F0EDA    ;     adrl R0, max_addr
0000025C: E2800AFF    ; 
00000260: E28F1F66    ;     adrl R1, stack_size
00000264: E2811B3F    ; 
00000268: E0400001    ;     sub R0, R0, R1
0000026C:             ; 
0000026C: E1500002    ;     cmp R0, R2
00000270: 1A000000    ;     bne assertionfail
00000274:             ; 
00000274: EA000003    ;     b assertionsuccess
00000278:             ; 
00000278:             ; assertionfail
00000278: E28F0079    ;     adrl R0, heapNotEmpty_m
0000027C: E2800C2A    ; 
00000280: EF000003    ;     swi 3
00000284:             ; 
00000284: EA000002    ;     b mainEndEnd
00000288:             ; 
00000288:             ; assertionsuccess
00000288: E28F002D    ;     adrl R0, heapEmpty_m
0000028C: E2800C2B    ; 
00000290: EF000003    ;     swi 3
00000294:             ; mainEndEnd
00000294: E24BD018    ;     sub sp, fp, #24 ;;???
00000298: E8BD47F0    ;     pop {R14, R4-R10}
0000029C: E1A0F00E    ;     mov R15, R14
000002A0:             ; 
000002A0:             ; mainfree
000002A0:             ; ;;INP in R0 is the saveInfoStruct
000002A0:             ; ;;OUT --
000002A0:             ; ;;free all of the memory that we used i.e. any saved grids, saved grid names, and the arr of sa
                      ; ved grids
000002A0: E92D47F0    ;     push {R14, R4-R10}
000002A4:             ; 
000002A4: E5905008    ;     ldr R5, [R0, #8] ;;get the current index this is the number of elements in the arr
000002A8: E5906000    ;     ldr R6, [R0, #0] ;;This is the array address
000002AC: E3A0700C    ;     ldr R7, =sizeofSaveI
000002B0:             ; 
000002B0: E1A0A000    ;     mov R10, R0
000002B4: E3A04000    ;     mov R4, #0
000002B8:             ; mainfreeloop
000002B8:             ;     ;;loop through the savedGrids
000002B8: E1540005    ;     cmp R4, R5
000002BC: 0A00000B    ;     beq mainfreelend
000002C0:             ; 
000002C0: E0286794    ;     mla R8, R4, R7, R6
000002C4: E5980000    ;     ldr R0, [R8, #0] ;;get the address of the grid
000002C8: E5989004    ;     ldr R9, [R8, #4] ;;get the address of the char*
000002CC:             ; 
000002CC: EB000668    ;     bl free
000002D0: E3A00000    ;     mov R0, #0
000002D4: E5880000    ;     str R0, [R8, #0]
000002D8:             ; 
000002D8: E1A00009    ;     mov R0, R9
000002DC: EB000664    ;     bl free
000002E0: E3A00000    ;     mov R0, #0
000002E4: E5880004    ;     str R0, [R8, #4]
000002E8:             ; 
000002E8: E2844001    ;     add R4, R4, #1
000002EC: EAFFFFF1    ;     b mainfreeloop
000002F0:             ; 
000002F0:             ; mainfreelend
000002F0:             ;     ;;free the array
000002F0: E1A00006    ;     mov R0, R6
000002F4: EB00065E    ;     bl free
000002F8: E3A00000    ;     mov R0, #0
000002FC: E58A0000    ;     str R0, [R10, #0]
00000300:             ; 
00000300:             ; mainfreeend
00000300: E8BD47F0    ;     pop {R14, R4-R10}
00000304: E1A0F00E    ;     mov R15, R14
00000308:             ; 
00000308:             ; printcurrentsettinglist
00000308:             ; ;;INP in R0 is x addr
00000308:             ; ;;INP in R1 is y addr
00000308: E1A02000    ;     mov R2, R0
0000030C:             ; 
0000030C: E28F004D    ;     adrl R0, bracket_open
00000310: E2800C26    ; 
00000314: EF000003    ;     swi 3
00000318:             ; 
00000318: E5520000    ;     ldrb R0, [R2]
0000031C: EF000004    ;     swi 4
00000320:             ; 
00000320: E28F003B    ;     adrl R0, comma_space
00000324: E2800C26    ; 
00000328: EF000003    ;     swi 3
0000032C:             ; 
0000032C: E5510000    ;     ldrb R0, [R1]
00000330: EF000004    ;     swi 4
00000334:             ; 
00000334: E28F002A    ;     adrl R0, bracket_close
00000338: E2800C26    ; 
0000033C: EF000003    ;     swi 3
00000340:             ; 
00000340: E1A0F00E    ;     mov R15, R14
00000344:             ; 
00000344:             ; 
00000344:             ; printcurrentsettings
00000344:             ; ;;INP --
00000344:             ; ;;OUT --
00000344: E92D4000    ;     push {R14}
00000348:             ; 
00000348: E28F0FFA    ;     adrl R0, currentset_m
0000034C: E2800B09    ; 
00000350: EF000003    ;     swi 3
00000354:             ; 
00000354:             ;     ;;STEP
00000354: E28F00CF    ;     adrl R0, currentstep
00000358: E2800C25    ; 
0000035C: EF000003    ;     swi 3
00000360:             ; 
00000360: E55F130A    ;     ldrb R1, step_b_d
00000364: E3510000    ;     cmp R1, #0
00000368: 028F0FB7    ;     adrleq R0, off_msg
0000036C: 02800B0A    ; 
00000370: 128F00D1    ;     adrlne R0, on_msg
00000374: 12800C2A    ; 
00000378: EF000003    ;     swi 3
0000037C:             ; 
0000037C: E28F00DF    ;     adrl R0, comma_space
00000380: E2800C25    ; 
00000384: EF000003    ;     swi 3
00000388:             ; 
00000388:             ;     ;;SLOW
00000388: E28F0F62    ;     adrl R0, currentslow
0000038C: E2800B09    ; 
00000390: EF000003    ;     swi 3
00000394:             ; 
00000394: E55F133F    ;     ldrb R1, slow_b_d
00000398: E3510000    ;     cmp R1, #0
0000039C: 028F0FAA    ;     adrleq R0, off_msg
000003A0: 02800B0A    ; 
000003A4: 128F009D    ;     adrlne R0, on_msg
000003A8: 12800C2A    ; 
000003AC: EF000003    ;     swi 3
000003B0:             ; 
000003B0: E28F00AB    ;     adrl R0, comma_space
000003B4: E2800C25    ; 
000003B8: EF000003    ;     swi 3
000003BC:             ; 
000003BC:             ;     ;;ERASE
000003BC: E28F005D    ;     adrl R0, currenterase
000003C0: E2800C25    ; 
000003C4: EF000003    ;     swi 3
000003C8:             ; 
000003C8: E55F1374    ;     ldrb R1, erase_b_d
000003CC: E3510000    ;     cmp R1, #0
000003D0: 028F0F9D    ;     adrleq R0, off_msg
000003D4: 02800B0A    ; 
000003D8: 128F0069    ;     adrlne R0, on_msg
000003DC: 12800C2A    ; 
000003E0: EF000003    ;     swi 3
000003E4:             ; 
000003E4: E28F0077    ;     adrl R0, comma_space
000003E8: E2800C25    ; 
000003EC: EF000003    ;     swi 3
000003F0:             ; 
000003F0:             ;     ;;DIMS
000003F0: E28F0F4F    ;     adrl R0, currentDims
000003F4: E2800B09    ; 
000003F8: EF000003    ;     swi 3
000003FC:             ; 
000003FC: E24F00A5    ;     adrl R0, width_d
00000400: E2400C03    ; 
00000404: E24F1FEB    ;     adrl R1, height_d
00000408: EBFFFFBE    ;     bl printcurrentsettinglist
0000040C:             ; 
0000040C: E28F004F    ;     adrl R0, comma_space
00000410: E2800C25    ; 
00000414: EF000003    ;     swi 3
00000418:             ; 
00000418:             ;     ;;RANGE
00000418: E28F001B    ;     adrl R0, currentRange
0000041C: E2800C25    ; 
00000420: EF000003    ;     swi 3
00000424:             ; 
00000424: E24F00D7    ;     adrl R0, range_min
00000428: E2400C03    ; 
0000042C: E24F10DE    ;     adrl R1, range_max
00000430: E2411C03    ; 
00000434: EBFFFFB3    ;     bl printcurrentsettinglist
00000438:             ; 
00000438: E28F0023    ;     adrl R0, comma_space
0000043C: E2800C25    ; 
00000440: EF000003    ;     swi 3
00000444:             ; 
00000444:             ;     ;;Alive_c
00000444: E28F0F47    ;     adrl R0,  currenticons_1
00000448: E2800B09    ; 
0000044C: EF000003    ;     swi 3
00000450:             ; 
00000450: E55F03FF    ;     ldrb R0, alive_c
00000454: EF000000    ;     swi 0
00000458:             ; 
00000458: E28F0003    ;     adrl R0, comma_space
0000045C: E2800C25    ; 
00000460: EF000003    ;     swi 3
00000464:             ; 
00000464:             ;     ;;Dead_c
00000464: E28F0F41    ;     adrl R0, currenticons_2
00000468: E2800B09    ; 
0000046C: EF000003    ;     swi 3
00000470:             ; 
00000470: E55F041E    ;     ldrb R0, dead_c
00000474: EF000000    ;     swi 0
00000478:             ; 
00000478: E28F00E3    ;     adrl R0, comma_space
0000047C: E2800B09    ; 
00000480: EF000003    ;     swi 3
00000484:             ; 
00000484:             ;     ;;Ptr_c
00000484: E28F00EB    ;     adrl R0, currenticons_3
00000488: E2800B09    ; 
0000048C: EF000003    ;     swi 3
00000490:             ; 
00000490: E55F043D    ;     ldrb R0, ptr_c
00000494: EF000000    ;     swi 0
00000498:             ; 
00000498: E28F00C3    ;     adrl R0, comma_space
0000049C: E2800B09    ; 
000004A0: EF000003    ;     swi 3
000004A4:             ; 
000004A4:             ;     ;;Itters
000004A4: E28F0097    ;     adrl R0, currentItters
000004A8: E2800B09    ; 
000004AC: EF000003    ;     swi 3
000004B0:             ; 
000004B0: E55F0461    ;     ldrb R0, maxitters
000004B4: EF000004    ;     swi 4
000004B8:             ; 
000004B8: E28F00A3    ;     adrl R0, comma_space
000004BC: E2800B09    ; 
000004C0: EF000003    ;     swi 3
000004C4:             ; 
000004C4:             ;     ;;Draw erase
000004C4: E28F0D92    ;     adrl R0, currentdraweras
000004C8: E2800000    ; 
000004CC: EF000003    ;     swi 3
000004D0:             ; 
000004D0: E55F1480    ;     ldrb R1, drawerase_b
000004D4: E3510000    ;     cmp R1, #0
000004D8: 028F0F5B    ;     adrleq R0, off_msg
000004DC: 02800B0A    ; 
000004E0: 128F0061    ;     adrlne R0, on_msg
000004E4: 12800C29    ; 
000004E8: EF000003    ;     swi 3
000004EC:             ; 
000004EC:             ;     ;;END
000004EC: E28F0072    ;     adrl R0, bracket_close
000004F0: E2800B09    ; 
000004F4: EF000003    ;     swi 3
000004F8:             ; 
000004F8: E3A0000A    ;     ldr R0, =nl
000004FC: EF000000    ;     swi 0
00000500:             ; 
00000500: E8BD4000    ;     pop {R14}
00000504: E1A0F00E    ;     mov R15, R14
00000508:             ; 
00000508:             ; 
00000508:             ; settingsmenu
00000508:             ; ;;https://media.giphy.com/media/jOpLbiGmHR9S0/giphy.gif
00000508:             ; ;;I think there's a limit on the defined string length
00000508: E28F005A    ;     adrl R0, s_m1
0000050C: E2800C21    ; 
00000510: EF000003    ;     swi 3
00000514:             ; 
00000514: E28F000D    ;     adrl R0, s_m2
00000518: E2800C22    ; 
0000051C: EF000003    ;     swi 3
00000520:             ;     
00000520: E28F0065    ;     adrl R0, s_m3
00000524: E2800C22    ; 
00000528: EF000003    ;     swi 3
0000052C:             ; 
0000052C: E28F000A    ;     adrl R0, s_m4
00000530: E2800C23    ; 
00000534: EF000003    ;     swi 3
00000538:             ; 
00000538:             ; changesetting
00000538: EBFFFF81    ;     bl printcurrentsettings
0000053C:             ; 
0000053C: E28F0055    ;     adrl R0, s_m
00000540: E2800C23    ; 
00000544: EF000003    ;     swi 3
00000548:             ; 
00000548:             ; changesettingget
00000548: E3A0000A    ;     ldr R0, =enter
0000054C: E3A01002    ;     mov R1, #2
00000550: E3A02001    ;     mov R2, #1
00000554: EB0002B9    ;     bl getstring
00000558:             ; 
00000558: E3500000    ;     cmp R0, #0
0000055C: 0A00000E    ;     beq changesettingsmallocfail
00000560:             ; 
00000560: E1A05000    ;     mov R5, R0
00000564:             ; 
00000564: EB00026B    ;     bl strtoi
00000568:             ; 
00000568: E1A04000    ;     mov R4, R0
0000056C: E1A06001    ;     mov R6, R1
00000570: E1A00005    ;     mov R0, R5
00000574:             ; 
00000574: EB0005BE    ;     bl free
00000578:             ; 
00000578: EB0001A2    ;     bl newline
0000057C:             ; 
0000057C: E3560001    ;     cmp R6, #1
00000580: 0AFFFECF    ;     beq mainmenu
00000584:             ; 
00000584: E3560000    ;     cmp R6, #0
00000588: 0A000007    ;     beq changesettingscont
0000058C:             ; 
0000058C:             ; changesettingserr
0000058C: E28F0061    ;     adrl R0, s_m_err
00000590: E2800C23    ; 
00000594: EF000003    ;     swi 3
00000598:             ; 
00000598: EAFFFFEA    ;     b changesettingget
0000059C:             ; 
0000059C:             ; changesettingsmallocfail
0000059C: E28F0001    ;     adrl R0, malloc_panic
000005A0: E2800C27    ; 
000005A4: EF000003    ;     swi 3
000005A8:             ; 
000005A8: EAFFFEC5    ;     b mainmenu
000005AC:             ; 
000005AC:             ; changesettingscont
000005AC: E3540007    ;     cmp R4, #7
000005B0: CAFFFFF5    ;     bgt changesettingserr
000005B4:             ; 
000005B4:             ;     ;;now we have the index we can print the current value and prompt for a new one then loop b
                      ; ack up to the getsetting
000005B4: EA000007    ;     b getjump
000005B8:             ; 
000005B8: 00000798    ;     jumps defw changestep, changeslow, changeerase, changedims, changerange, changeicons, chang
000005BC: 000007B0    ; eitter, changedrawerase
000005C0: 000007C8    ; 
000005C4: 00000884    ; 
000005C8: 000008B8    ; 
000005CC: 000008EC    ; 
000005D0: 000009A0    ; 
000005D4: 00000A54    ; 
000005D8:             ;     align
000005D8:             ; 
000005D8:             ; getjump
000005D8: E1A04104    ;     mov R4, R4, lsl #2
000005DC: E24F002C    ;     adr R0, jumps
000005E0: E0840000    ;     add R0, R4, R0
000005E4: E5104000    ;     ldr R4, [R0]
000005E8: E12FFF14    ;     bx R4
000005EC:             ; 
000005EC: E3540000    ;     cmp R4, #0
000005F0: 0A000068    ;     beq changestep
000005F4:             ; 
000005F4: E3540001    ;     cmp R4, #1
000005F8: 0A00006C    ;     beq changeslow
000005FC:             ; 
000005FC: E3540002    ;     cmp R4, #2
00000600: 0A000070    ;     beq changeerase
00000604:             ; 
00000604: E3540003    ;     cmp R4, #3
00000608: 0A00009D    ;     beq changedims
0000060C:             ; 
0000060C: E3540004    ;     cmp R4, #4
00000610: 0A0000A8    ;     beq changerange
00000614:             ; 
00000614: E3540005    ;     cmp R4, #5
00000618: 0A0000B3    ;     beq changeicons
0000061C:             ; 
0000061C: E3540006    ;     cmp R4, #6
00000620: 0A0000DE    ;     beq changeitter
00000624:             ; 
00000624: E3540007    ;     cmp R4, #7
00000628: 0A000109    ;     beq changedrawerase
0000062C:             ; 
0000062C:             ; changearr
0000062C:             ; ;;generic for changedims and change range
0000062C:             ; ;;INP in R0 is addr. for x
0000062C:             ; ;;INP in R1 is addr. for y
0000062C:             ; ;;INP in R2 is boolean for require x < y. 1 for require
0000062C:             ; ;;OUT in R0 is err code non-0 for error
0000062C: E92D41F0    ;     push {R14, R4-R8}
00000630:             ; 
00000630: E1A06000    ;     mov R6, R0
00000634: E1A07001    ;     mov R7, R1
00000638: E1A08002    ;     mov R8, R2
0000063C:             ; 
0000063C: EB000040    ;     bl printdims
00000640:             ; 
00000640:             ; changearrget
00000640: E28F00E1    ;     adrl R0, currentaskx
00000644: E2800C23    ; 
00000648: EF000003    ;     swi 3
0000064C:             ; 
0000064C: EB00001D    ;     bl changearrgetvalidint
00000650: E1A04000    ;     mov R4, R0
00000654: E3510000    ;     cmp R1, #0
00000658: 1A000015    ;     bne changearrmallocerr
0000065C:             ; 
0000065C: EB000169    ;     bl newline
00000660:             ; 
00000660: E28F0FFA    ;     adrl R0, currentasky
00000664: E2800A02    ; 
00000668: EF000003    ;     swi 3
0000066C:             ; 
0000066C: EB000015    ;     bl changearrgetvalidint
00000670: E1A05000    ;     mov R5, R0
00000674:             ; 
00000674: EB000163    ;     bl newline
00000678:             ; 
00000678: E3580001    ;     cmp R8, #1
0000067C: 1A000006    ;     bne changearrset
00000680:             ; 
00000680: E1540005    ;     cmp R4, R5
00000684: AA000000    ;     bge changearrsizeerr
00000688:             ; 
00000688: EA000003    ;     b changearrset
0000068C:             ; 
0000068C:             ; changearrsizeerr
0000068C: E28F004A    ;     adrl R0, changearrsizmsg
00000690: E2800B09    ; 
00000694: EF000003    ;     swi 3
00000698:             ; 
00000698: EAFFFFE8    ;     b changearrget
0000069C:             ; 
0000069C:             ; changearrset
0000069C:             ;     ;;now we have the two valid values so str them back
0000069C: E5464000    ;     strb R4, [R6]
000006A0: E5475000    ;     strb R5, [R7] 
000006A4:             ; 
000006A4: E1A00006    ;     mov R0, R6
000006A8: E1A01007    ;     mov R1, R7
000006AC:             ; 
000006AC: EB000024    ;     bl printdims
000006B0:             ; 
000006B0: EA000001    ;     b changearrend
000006B4:             ; 
000006B4:             ; changearrmallocerr
000006B4: E3A00001    ;     mov R0, #1
000006B8: EA000000    ;     b changearrendend
000006BC:             ; 
000006BC:             ; changearrend
000006BC: E3A00000    ;     mov R0, #0
000006C0:             ; 
000006C0:             ; changearrendend
000006C0: E8BD41F0    ;     pop {R14, R4-R8}
000006C4: E1A0F00E    ;     mov R15, R14
000006C8:             ; 
000006C8:             ; ;;And you thought the naming couldn't get worse \(*0*)/
000006C8:             ; changearrgetvalidint ;;basically an inner function
000006C8:             ; ;;INP --
000006C8:             ; ;;OUT in R0 is the gotten value
000006C8:             ; ;;OUT in R1 is err code non-0 for fail
000006C8: E92D41F0    ;     push {R14, R4-R8}
000006CC:             ; changearrgetvalidintget
000006CC: E3A0000A    ;     ldr R0, =enter
000006D0: E3A01003    ;     mov R1, #3
000006D4: E3A02001    ;     mov R2, #1
000006D8: EB000258    ;     bl getstring
000006DC:             ; 
000006DC: E3500000    ;     cmp R0, #0
000006E0: 0A000011    ;     beq changearrgvmallocerr
000006E4:             ; 
000006E4: E1A04000    ;     mov R4, R0 ;;save the string to free
000006E8:             ; 
000006E8: EB00020A    ;     bl strtoi
000006EC:             ; 
000006EC: E1A05000    ;     mov R5, R0 ;;save the int value
000006F0: E1A06001    ;     mov R6, R1 ;;save err code
000006F4:             ; 
000006F4: E1A00004    ;     mov R0, R4
000006F8: EB00055D    ;     bl free
000006FC:             ; 
000006FC: E3560000    ;     cmp R6, #0
00000700: 0A000004    ;     beq changearrgetvalidintcont
00000704:             ; 
00000704:             ; changearrgetvalidinterr
00000704: EB00013F    ;     bl newline
00000708:             ; 
00000708: E28F0021    ;     adrl R0, changearrverr_m
0000070C: E2800C1F    ; 
00000710: EF000003    ;     swi 3
00000714:             ; 
00000714: EAFFFFEC    ;     b changearrgetvalidintget
00000718:             ; 
00000718:             ; changearrgetvalidintcont
00000718:             ;     ;;we now have an int value, need to do bounds checks
00000718: E3550000    ;     cmp R5, #0
0000071C: DAFFFFF8    ;     ble changearrgetvalidinterr
00000720:             ; 
00000720: E35500FF    ;     cmp R5, #255
00000724: CAFFFFF6    ;     bgt changearrgetvalidinterr
00000728:             ; 
00000728: EA000001    ;     b changearrgetvalidintend
0000072C:             ; 
0000072C:             ; changearrgvmallocerr
0000072C: E3A01001    ;     mov R1, #1
00000730:             ; 
00000730: EA000001    ;     b changearrgvendend
00000734:             ; 
00000734:             ; changearrgetvalidintend
00000734: E1A00005    ;     mov R0, R5
00000738: E3A01000    ;     mov R1, #0
0000073C:             ; changearrgvendend
0000073C: E8BD41F0    ;     pop {R14, R4-R8}
00000740: E1A0F00E    ;     mov R15, R14
00000744:             ; 
00000744:             ; printdims
00000744:             ; ;;INP in R0 is addr. for x
00000744:             ; ;;INP in R1 is addr. for y
00000744:             ; ;;(_, _)
00000744:             ;     
00000744: E1A02000    ;     mov R2, R0
00000748: E1A03001    ;     mov R3, R1
0000074C:             ; 
0000074C: E28F0E1E    ;     adrl R0, currentDims
00000750: E2800A02    ; 
00000754: EF000003    ;     swi 3
00000758:             ; 
00000758: E28F0001    ;     adrl R0, bracket_open
0000075C: E2800C22    ; 
00000760: EF000003    ;     swi 3
00000764:             ; 
00000764: E5520000    ;     ldrb R0, [R2]
00000768: EF000004    ;     swi 4
0000076C:             ; 
0000076C: E28F00EF    ;     adrl R0, comma_space
00000770: E2800C21    ; 
00000774: EF000003    ;     swi 3
00000778:             ; 
00000778: E5530000    ;     ldrb R0, [R3]
0000077C: EF000004    ;     swi 4
00000780:             ; 
00000780: E28F00DE    ;     adrl R0, bracket_close
00000784: E2800C21    ; 
00000788: EF000003    ;     swi 3
0000078C:             ; 
0000078C: E3A0000A    ;     ldr R0, =nl
00000790: EF000000    ;     swi 0
00000794:             ; 
00000794: E1A0F00E    ;     mov R15, R14
00000798:             ; 
00000798:             ; changestep
00000798: E24F0042    ;     adrl R0, step_b_d
0000079C: E2400C07    ; 
000007A0: E28F1083    ;     adrl R1, currentstep
000007A4: E2811C21    ; 
000007A8:             ; 
000007A8: EB00000C    ;     bl changebool
000007AC:             ; 
000007AC: EAFFFF61    ;     b changesetting
000007B0:             ; 
000007B0:             ; changeslow
000007B0: E24F005B    ;     adrl R0, slow_b_d
000007B4: E2400C07    ; 
000007B8: E28F1F56    ;     adrl R1, currentslow
000007BC: E2811A02    ; 
000007C0:             ; 
000007C0: EB000006    ;     bl changebool
000007C4:             ; 
000007C4: EAFFFF5B    ;     b changesetting
000007C8:             ; 
000007C8:             ; changeerase
000007C8: E24F0FDD    ;     adrl R0, erase_b_d
000007CC: E2400B01    ; 
000007D0: E28F1049    ;     adrl R1, currenterase
000007D4: E2811C21    ; 
000007D8:             ; 
000007D8: EB000000    ;     bl changebool
000007DC:             ; 
000007DC: EAFFFF55    ;     b changesetting
000007E0:             ; 
000007E0:             ; changebool
000007E0:             ; ;;INP in R0 is the address of ___b_d
000007E0:             ; ;;INP in R1 is the address of the printing name
000007E0:             ; ;;OUT --
000007E0: E92D41F0    ;     push {R14, R4-R8}
000007E4:             ; 
000007E4: E1A04000    ;     mov R4, R0
000007E8: E1A05001    ;     mov R5, R1
000007EC:             ; 
000007EC: E1A00001    ;     mov R0, R1
000007F0: EF000003    ;     swi 3
000007F4:             ; 
000007F4: E5540000    ;     ldrb R0, [R4]
000007F8: E3500001    ;     cmp R0, #1
000007FC: 128F0F92    ;     adrlne R0, off_msg
00000800: 12800B09    ; 
00000804: 028F003D    ;     adrleq R0, on_msg
00000808: 02800C26    ; 
0000080C: EF000003    ;     swi 3
00000810:             ; 
00000810: EB0000FC    ;     bl newline
00000814:             ; 
00000814: E28F006D    ;     adrl R0, currentasknew_B
00000818: E2800C22    ; 
0000081C: EF000003    ;     swi 3
00000820:             ; 
00000820:             ; changebool_cont
00000820: EF000001    ;     swi 1
00000824:             ; 
00000824: E2400030    ;     sub R0, R0, #48
00000828: E3500001    ;     cmp R0, #1
0000082C: 0A000006    ;     beq changebool_set
00000830: E3500000    ;     cmp R0, #0
00000834: 0A000004    ;     beq changebool_set
00000838:             ; 
00000838: EB0000F2    ;     bl newline
0000083C:             ; 
0000083C: E28F0E26    ;     adrl R0, currentasknew_E
00000840: E2800A02    ; 
00000844: EF000003    ;     swi 3
00000848:             ; 
00000848: EAFFFFF4    ;     b changebool_cont
0000084C:             ; 
0000084C:             ; changebool_set
0000084C: E5440000    ;     strb R0, [R4]
00000850:             ; 
00000850: EB0000EC    ;     bl newline
00000854:             ; 
00000854: E1A00005    ;     mov R0, R5
00000858: EF000003    ;     swi 3
0000085C:             ; 
0000085C: E5540000    ;     ldrb R0, [R4]
00000860: E3500001    ;     cmp R0, #1
00000864: 128F0E5E    ;     adrlne R0, off_msg
00000868: 12800A02    ; 
0000086C: 028F00D5    ;     adrleq R0, on_msg
00000870: 02800C25    ; 
00000874: EF000003    ;     swi 3
00000878:             ; 
00000878: EB0000E2    ;     bl newline
0000087C:             ; 
0000087C:             ; changeboolend
0000087C: E8BD41F0    ;     pop {R14, R4-R8}
00000880: E1A0F00E    ;     mov R15, R14
00000884:             ; 
00000884:             ; changedims
00000884:             ; ;;INP in R0 is addr. for x
00000884:             ; ;;INP in R1 is addr. for y
00000884:             ; ;;INP in R2 is boolean for require x < y. 1 for require
00000884: E24F002D    ;     adrl R0, width_d
00000888: E2400B02    ; 
0000088C: E24F1034    ;     adrl R1, height_d
00000890: E2411B02    ; 
00000894: E3A02000    ;     mov R2, #0
00000898: EBFFFF63    ;     bl changearr
0000089C:             ; 
0000089C: E3500000    ;     cmp R0, #0
000008A0: 0A000003    ;     beq changedimscont
000008A4:             ; 
000008A4: E28F00F9    ;     adrl R0, malloc_panic
000008A8: E2800C23    ; 
000008AC: EF000003    ;     swi 3
000008B0:             ; 
000008B0: EAFFFE03    ;     b mainmenu
000008B4:             ; 
000008B4:             ; changedimscont
000008B4:             ; 
000008B4: EAFFFF1F    ;     b changesetting
000008B8:             ; 
000008B8:             ; changerange
000008B8: E24F006B    ;     adrl R0, range_min
000008BC: E2400B02    ; 
000008C0: E24F1072    ;     adrl R1, range_max
000008C4: E2411B02    ; 
000008C8: E3A02001    ;     mov R2, #1
000008CC: EBFFFF56    ;     bl changearr
000008D0:             ; 
000008D0: E3500000    ;     cmp R0, #0
000008D4: 0A000003    ;     beq changerangecont
000008D8:             ; 
000008D8: E28F00C5    ;     adrl R0, malloc_panic
000008DC: E2800C23    ; 
000008E0: EF000003    ;     swi 3
000008E4:             ; 
000008E4: EAFFFDF6    ;     b mainmenu
000008E8:             ; 
000008E8:             ; changerangecont
000008E8:             ; 
000008E8: EAFFFF12    ;     b changesetting
000008EC:             ; 
000008EC:             ; changeicons
000008EC:             ; ;;print the current icons, ask for 3 characters in sequence for alive/dead/ptr
000008EC: EB000015    ;     bl printicons
000008F0:             ; 
000008F0: E28F0085    ;     adrl R0, currenticons_a
000008F4: E2800A02    ; 
000008F8: EF000003    ;     swi 3
000008FC:             ; 
000008FC: E3A00000    ;     mov R0, #0
00000900: E3A01003    ;     mov R1, #3
00000904: E3A02001    ;     mov R2, #1
00000908: EB0001CC    ;     bl getstring
0000090C:             ; 
0000090C: E3500000    ;     cmp R0, #0
00000910: 0A000008    ;     beq changeiconsmallerr
00000914:             ; 
00000914: E5D01000    ;     ldrb R1, [R0, #0]
00000918: E5D02001    ;     ldrb R2, [R0, #1]
0000091C: E5D03002    ;     ldrb R3, [R0, #2]
00000920:             ; 
00000920: E54F18CF    ;     strb R1, alive_c
00000924: E54F28D2    ;     strb R2, dead_c
00000928: E54F38D5    ;     strb R3, ptr_c
0000092C:             ; 
0000092C: EB0000B5    ;     bl newline
00000930:             ; 
00000930: EB000004    ;     bl printicons
00000934:             ; 
00000934: EAFFFEFF    ;     b changesetting
00000938:             ; 
00000938:             ; changeiconsmallerr
00000938: E28F00B3    ;     adrl R0, getstringerr_m
0000093C: E2800A02    ; 
00000940: EF000003    ;     swi 3
00000944:             ; 
00000944: EAFFFEFB    ;     b changesetting
00000948:             ; 
00000948:             ; printicons
00000948:             ; ;;INP --
00000948:             ; ;;OUT --
00000948: E28F0018    ;     adrl R0, currenticons_1
0000094C: E2800A02    ; 
00000950: EF000003    ;     swi 3
00000954:             ; 
00000954: E55F0903    ;     ldrb R0, alive_c
00000958: EF000000    ;     swi 0
0000095C:             ; 
0000095C: E3A0000A    ;     ldr R0, =nl
00000960: EF000000    ;     swi 0
00000964:             ; 
00000964: E28F0004    ;     adrl R0, currenticons_2
00000968: E2800A02    ; 
0000096C: EF000003    ;     swi 3
00000970:             ; 
00000970: E55F091E    ;     ldrb R0, dead_c
00000974: EF000000    ;     swi 0
00000978:             ; 
00000978: E3A0000A    ;     ldr R0, =nl
0000097C: EF000000    ;     swi 0
00000980:             ; 
00000980: E28F00EF    ;     adrl R0, currenticons_3
00000984: E2800C1F    ; 
00000988: EF000003    ;     swi 3
0000098C:             ; 
0000098C: E55F0939    ;     ldrb R0, ptr_c
00000990: EF000000    ;     swi 0
00000994:             ; 
00000994: E3A0000A    ;     ldr R0, =nl
00000998: EF000000    ;     swi 0
0000099C:             ; 
0000099C:             ; printiconsend
0000099C: E1A0F00E    ;     mov R15, R14
000009A0:             ; 
000009A0:             ; changeitter
000009A0: E28F009B    ;     adrl R0, currentItters
000009A4: E2800C1F    ; 
000009A8: EF000003    ;     swi 3
000009AC:             ; 
000009AC: E55F095D    ;     ldrb R0, maxitters
000009B0: EF000004    ;     swi 4
000009B4:             ; 
000009B4: EB000093    ;     bl newline
000009B8:             ; 
000009B8: E28F0051    ;     adrl R0, getitters_m
000009BC: E2800C21    ; 
000009C0: EF000003    ;     swi 3
000009C4:             ; 
000009C4:             ; changeitterget
000009C4: E3A0000A    ;     ldr R0, =enter
000009C8: E3E01000    ;     mov R1, #-1
000009CC: E3A02001    ;     mov R2, #1
000009D0: EB00019A    ;     bl getstring
000009D4:             ; 
000009D4: E3500000    ;     cmp R0, #0
000009D8: 1A000003    ;     bne changeittergetcont
000009DC:             ; 
000009DC: E28F00C1    ;     adrl R0, malloc_panic
000009E0: E2800C22    ; 
000009E4: EF000003    ;     swi 3
000009E8:             ; 
000009E8: EAFFFDB5    ;     b mainmenu 
000009EC:             ; 
000009EC:             ; changeittergetcont
000009EC:             ; 
000009EC: E1A04000    ;     mov R4, R0
000009F0:             ; 
000009F0: EB000148    ;     bl strtoi
000009F4: E1A03000    ;     mov R3, R0
000009F8:             ; 
000009F8: E1A05000    ;     mov R5, R0
000009FC: E1A06001    ;     mov R6, R1
00000A00:             ; 
00000A00: E1A00004    ;     mov R0, R4
00000A04: EB00049A    ;     bl free
00000A08:             ; 
00000A08: EB00007E    ;     bl newline
00000A0C:             ; 
00000A0C: E3560000    ;     cmp R6, #0
00000A10: 1A000003    ;     bne changeittererr
00000A14:             ; 
00000A14: E24F00C5    ;     adrl R0, maxitters
00000A18: E2400C09    ; 
00000A1C: E5405000    ;     strb R5, [R0]
00000A20:             ; 
00000A20: EA000004    ;     b changeitterend
00000A24:             ; 
00000A24:             ; changeittererr
00000A24: EB000077    ;     bl newline
00000A28:             ; 
00000A28: E28F0D83    ;     adrl R0, changeittere_m
00000A2C: E2800000    ; 
00000A30: EF000003    ;     swi 3
00000A34: EAFFFFE2    ;     b changeitterget
00000A38:             ; changeitterend
00000A38: E28F0003    ;     adrl R0, currentItters
00000A3C: E2800C1F    ; 
00000A40: EF000003    ;     swi 3
00000A44:             ; 
00000A44: E55F09F5    ;     ldrb R0, maxitters
00000A48: EF000004    ;     swi 4
00000A4C:             ; 
00000A4C: EB00006D    ;     bl newline
00000A50:             ; 
00000A50: EAFFFEB8    ;     b changesetting
00000A54:             ; 
00000A54:             ; changedrawerase
00000A54: E24F0F81    ;     adrl R0, drawerase_b
00000A58: E2400B02    ; 
00000A5C: E28F1FBA    ;     adrl R1, currentdraweras
00000A60: E2811B07    ; 
00000A64: EBFFFF5D    ;     bl changebool
00000A68:             ; 
00000A68: EAFFFEB2    ;     b changesetting
00000A6C:             ; 
00000A6C:             ; changedraweraseend
00000A6C: EAFFFEB1    ;     b changesetting
00000A70:             ; 
00000A70:             ; newboard
00000A70: E3A00001    ;     mov R0, #1;;should get dims
00000A74: EB00029F    ;     bl setupOptions
00000A78:             ; 
00000A78: E24F002E    ;     adrl R0, step_b
00000A7C: E2400C0A    ; 
00000A80: E5500000    ;     ldrb R0, [R0]
00000A84:             ; 
00000A84: E3500001    ;     cmp R0, #1
00000A88: 1A000002    ;     bne newboardcont
00000A8C:             ; 
00000A8C: E28F00AD    ;     adrl R0, stepmode_m
00000A90: E2800C16    ; 
00000A94: EF000003    ;     swi 3
00000A98:             ; 
00000A98:             ; newboardcont
00000A98:             ; 
00000A98: EB0001AF    ;     bl setupGrid
00000A9C:             ; 
00000A9C: E3500000    ;     cmp R0, #0
00000AA0: 1AFFFDD8    ;     bne mainMallocFail
00000AA4:             ;     
00000AA4: E51F4A64    ;     ldr R4, gridA
00000AA8: E51F5A64    ;     ldr R5, gridB
00000AAC:             ; 
00000AAC: E3540000    ;     cmp R4, #0
00000AB0: 0AFFFDD1    ;     beq gridFail
00000AB4: E3550000    ;     cmp R5, #0
00000AB8: 0AFFFDCF    ;     beq gridFail
00000ABC:             ; 
00000ABC: EAFFFD9A    ;     b mainloopstart
00000AC0:             ; 
00000AC0:             ; loadboard
00000AC0:             ; ;;INP in R0 is the ptr to the SaveInfoHeader struct i.e. ptr to arr, current pos, max size
00000AC0:             ; ;;RET in R0 0 for success in which case go to main loop, n/0 for err in which case return to ma
                      ; in menu
00000AC0:             ; ;;display the saved grids
00000AC0:             ; ;;ask for the index
00000AC0:             ; ;;load the grids with the saved info
00000AC0:             ; ;;ask the user for the settings
00000AC0: E1A04000    ;     mov R4, R0 ;;save the struct ptr
00000AC4:             ; 
00000AC4:             ;     ;;pass ptr to listgrids
00000AC4: EB00007C    ;     bl listGrids
00000AC8:             ; 
00000AC8: E5940008    ;     ldr R0, [R4, #8] ;;get the current position
00000ACC: E3500000    ;     cmp R0, #0
00000AD0: 0A00004A    ;     beq loadboardempty
00000AD4:             ; 
00000AD4:             ; loadboardaskindex
00000AD4:             ;     ;;The grid has now been printed out we need to get the index to load
00000AD4: E28F00F7    ;     adrl R0, loadboardaski
00000AD8: E2800C19    ; 
00000ADC: EF000003    ;     swi 3
00000AE0:             ; 
00000AE0: E3A0000A    ;     ldr R0, =enter
00000AE4: E3E01000    ;     mov R1, #-1
00000AE8: E3A02001    ;     mov R2, #1
00000AEC: EB000153    ;     bl getstring
00000AF0:             ; 
00000AF0: E3500000    ;     cmp R0, #0
00000AF4: 1A000003    ;     bne loadboardaskindexcont
00000AF8:             ; 
00000AF8: E28F00A5    ;     adrl R0, malloc_panic
00000AFC: E2800C21    ; 
00000B00: EF000003    ;     swi 3
00000B04:             ; 
00000B04: EAFFFD6E    ;     b mainmenu 
00000B08:             ; 
00000B08:             ; loadboardaskindexcont
00000B08:             ; 
00000B08: E1A05000    ;     mov R5, R0
00000B0C:             ; 
00000B0C: EB00003D    ;     bl newline
00000B10:             ; 
00000B10: E1A00005    ;     mov R0, R5
00000B14: EB0000FF    ;     bl strtoi
00000B18: E1A06000    ;     mov R6, R0
00000B1C: E1A07001    ;     mov R7, R1
00000B20:             ;     ;;ERR codes
00000B20:             ;     ;;  0 is success
00000B20:             ;     ;;  1 is attempted -ve
00000B20:             ;     ;;  2 is use of non-numeric characters
00000B20:             ;     ;;  3 is value out of range of integer
00000B20:             ;     ;;  4 is null string given
00000B20:             ; 
00000B20: E1A00005    ;     mov R0, R5
00000B24: EB000452    ;     bl free
00000B28:             ; 
00000B28: E1A00006    ;     mov R0, R6
00000B2C: E1A01007    ;     mov R1, R7
00000B30:             ; 
00000B30: E3510001    ;     cmp R1, #1
00000B34: 0A00002E    ;     beq loadboardret
00000B38:             ; 
00000B38: E3510000    ;     cmp R1, #0
00000B3C: 0A000003    ;     beq loadboardindex
00000B40:             ; 
00000B40: E28F0015    ;     adrl R0, loadboardifail
00000B44: E2800C1A    ; 
00000B48: EF000003    ;     swi 3
00000B4C:             ; 
00000B4C: EAFFFFE0    ;     b loadboardaskindex
00000B50:             ; 
00000B50:             ; loadboardindex
00000B50:             ; ;;we now have an index lets check if its in range and then load the board
00000B50:             ;     ;;should be +ve so don't need to check < 0
00000B50: E5941008    ;     ldr R1, [R4, #8] ;;get the current position, this is where things get added so index < curr
                      ; entposition
00000B54: E1500001    ;     cmp R0, R1
00000B58: BA000003    ;     blt loadboardmain
00000B5C:             ; 
00000B5C: E28F0F87    ;     adrl R0, loadboardirerr
00000B60: E2800B06    ; 
00000B64: EF000003    ;     swi 3
00000B68: EAFFFFD9    ;     b loadboardaskindex
00000B6C:             ; 
00000B6C:             ; loadboardmain
00000B6C:             ; ;;now we know that the index is valid we can load the grid
00000B6C:             ; ;;
00000B6C:             ; ;;need to free current grid
00000B6C:             ; ;;need to create a copy of the snapshot and set gridA to it 
00000B6C:             ; ;;return to main menu
00000B6C: E5941000    ;     ldr R1, [R4, #0] ;;get the array of grids
00000B70: E3A0200C    ;     ldr R2, =sizeofSaveI
00000B74: E0201290    ;     mla R0, R0, R2, R1 ;;R0 = index * sizeofSaveI + grid.addr
00000B78:             ; 
00000B78: E5905000    ;     ldr R5, [R0, #0] ;;get the address of that grid
00000B7C: E5D06008    ;     ldrb R6, [R0, #8] ;;get the width
00000B80: E5D07009    ;     ldrb R7, [R0, #9] ;;get the height
00000B84:             ; 
00000B84: E0000796    ;     mul R0, R6, R7 ;;get the required size
00000B88: E1A09000    ;     mov R9, R0 ;;save the number of bytes
00000B8C:             ; 
00000B8C: EB000395    ;     bl malloc
00000B90:             ; 
00000B90: E3500000    ;     cmp R0, #0
00000B94: 0A000012    ;     beq loadboardmallocfail
00000B98:             ; 
00000B98: E1A08000    ;     mov R8, R0 ;;save the new grid arr
00000B9C:             ; 
00000B9C:             ;     ;;need to copy the saved grid into the new grid
00000B9C:             ; 
00000B9C: E1A00005    ;     mov R0, R5  ;;src is the saved grid
00000BA0: E1A01008    ;     mov R1, R8  ;;dst is the new grid
00000BA4: E1A02009    ;     mov R2, R9  ;;bytes is in R9 already from width and height
00000BA8: EB000103    ;     bl memcpy
00000BAC:             ; 
00000BAC: E50F8B6C    ;     str R8, gridA
00000BB0:             ; 
00000BB0:             ;     ;;also need to check if the old gridB is big enough --NO!
00000BB0:             ;     ;;The old grid has been freed when returning to the main menu so we must make a new one
00000BB0:             ; loadboardmallocB
00000BB0: E1A00009    ;     mov R0, R9
00000BB4: EB00038B    ;     bl malloc
00000BB8:             ; 
00000BB8: E3500000    ;     cmp R0, #0
00000BBC: 0A000008    ;     beq loadboardmallocfail
00000BC0:             ; 
00000BC0: E50F0B7C    ;     str R0, gridB
00000BC4:             ; 
00000BC4:             ; loadboardskipB
00000BC4: E54F6B79    ;     strb R6, width
00000BC8: E54F7B7C    ;     strb R7, height ;;overwrite the active grid information
00000BCC:             ; 
00000BCC: E28F0009    ;     adrl R0, loadboardsucmsg
00000BD0: E2800C1A    ; 
00000BD4: EF000003    ;     swi 3
00000BD8:             ; 
00000BD8: E3A00000    ;     mov R0, #0 ;;skip asking dims as they've been loaded
00000BDC: EB000245    ;     bl setupOptions
00000BE0:             ; 
00000BE0: EA000007    ;     b loadboardsucc
00000BE4:             ; 
00000BE4:             ; loadboardmallocfail
00000BE4: E28F00B1    ;     adrl R0, loadboardmlcerr
00000BE8: E2800C19    ; 
00000BEC: EF000003    ;     swi 3
00000BF0:             ; 
00000BF0: EA000002    ;     b loadboarderr
00000BF4:             ; 
00000BF4:             ; loadboardret
00000BF4: E28F0049    ;     adrl R0, loadboardretmsg
00000BF8: E2800C19    ; 
00000BFC: EF000003    ;     swi 3
00000C00:             ; 
00000C00:             ; loadboardempty
00000C00:             ; loadboarderr
00000C00: EAFFFD2F    ;     b mainmenu
00000C04:             ; loadboardsucc
00000C04: EAFFFD48    ;     b mainloopstart
00000C08:             ; 
00000C08:             ; newline
00000C08: E3A0000A    ;     ldr R0, =nl
00000C0C: EF000000    ;     swi 0
00000C10:             ; 
00000C10: E1A0F00E    ;     mov R15, R14
00000C14:             ; 
00000C14:             ; step
00000C14:             ; ;;INP in R0 is the gridHeaderStruct ptr
00000C14:             ; ;;INP in R1 is the active grid ptr
00000C14:             ; ;;OUT in R0 is 1 if should return to main menu, else 0.
00000C14:             ; 
00000C14:             ; ;;get user input
00000C14:             ; ;;if q -> jump to main menu
00000C14:             ; ;;if s -> ask for name, bl saveGrid with name
00000C14: E92D41F0    ;     push {R14, R4-R8}
00000C18: E1A04000    ;     mov R4, R0 ;;save the struct 
00000C1C: E1A05001    ;     mov R5, R1
00000C20:             ; 
00000C20: EF000001    ;     swi 1
00000C24:             ; 
00000C24: E3500071    ;     cmp R0, #'q'
00000C28: 0A00001E    ;     beq stependfail ;;bad name, shame I can't change it eh
00000C2C:             ; 
00000C2C: E3500073    ;     cmp R0, #'s'
00000C30: 1A00001E    ;     bne stependsucc
00000C34:             ; 
00000C34: E28F0006    ;     adrl R0, askname
00000C38: E2800B05    ; 
00000C3C: EF000003    ;     swi 3
00000C40:             ; 
00000C40: E3A0000A    ;     ldr R0, =enter
00000C44: E3E01000    ;     mov R1, #-1
00000C48: E3A02001    ;     mov R2, #1
00000C4C: EB0000FB    ;     bl getstring
00000C50:             ; 
00000C50: E3500000    ;     cmp R0, #0
00000C54: 1A000003    ;     bne stepcont
00000C58:             ; 
00000C58: E28F0045    ;     adrl R0, malloc_panic
00000C5C: E2800A02    ; 
00000C60: EF000003    ;     swi 3
00000C64:             ; 
00000C64: EA00000F    ;     b stependfail
00000C68:             ; 
00000C68:             ; stepcont
00000C68:             ; 
00000C68: E1A01000    ;     mov R1, R0 ;;char* name
00000C6C: E1A00004    ;     mov R0, R4 ;;gridinfo* 
00000C70: E1A02005    ;     mov R2, R5 ;;active grid
00000C74: EB000047    ;     bl saveGrid
00000C78:             ; 
00000C78: EBFFFFE2    ;     bl newline
00000C7C:             ; 
00000C7C: E28F0093    ;     adrl R0, savedchoice
00000C80: E2800C13    ; 
00000C84: EF000003    ;     swi 3
00000C88:             ; 
00000C88: EF000001    ;     swi 1
00000C8C: EF000000    ;     swi 0
00000C90: E3800020    ;     orr R0, R0, #32
00000C94: E3500079    ;     cmp R0, #'y'
00000C98:             ; 
00000C98: E3A0000A    ;     ldr R0, =nl
00000C9C: EF000000    ;     swi 0
00000CA0:             ; 
00000CA0: 0A000000    ;     beq stependfail
00000CA4: EA000001    ;     b stependsucc
00000CA8:             ; 
00000CA8:             ; stependfail
00000CA8: E3A00001    ;     mov R0, #1
00000CAC: EA000000    ;     b stepend
00000CB0:             ; 
00000CB0:             ; stependsucc
00000CB0: E3A00000    ;     mov R0, #0
00000CB4:             ; 
00000CB4:             ; stepend
00000CB4: E8BD41F0    ;     pop {R14, R4-R8}
00000CB8: E1A0F00E    ;     mov R15, R14
00000CBC:             ; 
00000CBC:             ; listGrids
00000CBC:             ; ;;INP in R0 is the ptr to the gridInfo struct
00000CBC:             ; ;;RET --
00000CBC:             ; ;;Grid info struct
00000CBC:             ; ;;  - SaveInfoStruct* array
00000CBC:             ; ;;  - int max size of arr
00000CBC:             ; ;;  - int current position in arr
00000CBC:             ; 
00000CBC:             ; ;;loops through the array of grids (if any) printing their names, and dims, ask to print grid
00000CBC: E92D47F0    ;     push {R14, R4-R10}
00000CC0:             ; 
00000CC0: E5904000    ;     ldr R4, [R0, #0] ;;get the array ptr
00000CC4: E5905008    ;     ldr R5, [R0, #8] ;;current position
00000CC8:             ; 
00000CC8: E3550000    ;     cmp R5, #0
00000CCC: 0A00002C    ;     beq listGridsEmpty
00000CD0:             ; 
00000CD0:             ; ;;if current position == 1: print("There are no saved grids")
00000CD0:             ; ;;for i from 0 to current position
00000CD0:             ; ;;  getname(4)
00000CD0:             ; ;;  getwidth(8)
00000CD0:             ; ;;  getheight(9)
00000CD0:             ; ;;  print("There is a grid called %s with dims (%d, %d)")
00000CD0: E3A01000    ;     mov R1, #0 ;;i
00000CD4: E3A0200C    ;     ldr R2, =sizeofSaveI
00000CD8:             ; 
00000CD8: E28F001B    ;     adrl R0, listgridmsg
00000CDC: E2800C19    ; 
00000CE0: EF000003    ;     swi 3
00000CE4:             ; 
00000CE4: E28F0032    ;     adrl R0, cutoff
00000CE8: E2800C19    ; 
00000CEC: EF000003    ;     swi 3
00000CF0:             ; 
00000CF0:             ; listGridsLoop
00000CF0: E1510005    ;     cmp R1, R5
00000CF4: 0A000025    ;     beq listGridsLend
00000CF8:             ; 
00000CF8: E0234291    ;     mla R3, R1, R2, R4 ;;R3 = i * sizeof(saveInfo) + array
00000CFC: E5936004    ;     ldr R6, [R3, #4] ;;load the name ptr
00000D00: E5D37008    ;     ldrb R7, [R3, #8] ;;load the width
00000D04: E5D38009    ;     ldrb R8, [R3, #9] ;;load the height
00000D08:             ; 
00000D08: E28F009F    ;     adrl R0, gridloadpindex
00000D0C: E2800C17    ; 
00000D10: EF000003    ;     swi 3
00000D14:             ; 
00000D14: E3A0003A    ;     mov R0, #':'
00000D18: EF000000    ;     swi 0
00000D1C:             ; 
00000D1C: E1A00001    ;     mov R0, R1
00000D20: EF000004    ;     swi 4
00000D24:             ; 
00000D24: EBFFFFB7    ;     bl newline
00000D28:             ; 
00000D28: E28F0FE2    ;     adrl R0, gridloadpname
00000D2C: E2800B05    ; 
00000D30: EF000003    ;     swi 3
00000D34:             ; 
00000D34: E1A00006    ;     mov R0, R6
00000D38: EF000003    ;     swi 3
00000D3C:             ; 
00000D3C: EBFFFFB1    ;     bl newline
00000D40:             ; 
00000D40: E28F0FDE    ;     adrl R0, gridloadpwidth
00000D44: E2800B05    ; 
00000D48: EF000003    ;     swi 3
00000D4C:             ; 
00000D4C: E1A00007    ;     mov R0, R7
00000D50: EF000004    ;     swi 4
00000D54:             ; 
00000D54: EBFFFFAB    ;     bl newline
00000D58:             ; 
00000D58: E28F0069    ;     adrl R0, gridloadpheight
00000D5C: E2800C17    ; 
00000D60: EF000003    ;     swi 3
00000D64:             ; 
00000D64: E1A00008    ;     mov R0, R8
00000D68: EF000004    ;     swi 4
00000D6C:             ; 
00000D6C: EBFFFFA5    ;     bl newline
00000D70:             ; 
00000D70:             ;     ;;[[Prob]  Printing the grid uses the stored width and height, I could change it to use a p
                      ; assed in
00000D70:             ;     ;;             version but do the other areas have enough registers to cope? probably not.
00000D70:             ;     ;;             Would have to swap the width and height with the loaded versions - I really 
                      ; don't like this idea
00000D70:             ; 
00000D70: E2811001    ;     add R1, R1, #1
00000D74:             ; 
00000D74: E28F00A2    ;     adrl R0, cutoff
00000D78: E2800B06    ; 
00000D7C: EF000003    ;     swi 3
00000D80:             ; 
00000D80: EAFFFFDA    ;     b listGridsLoop
00000D84:             ; 
00000D84:             ; listGridsEmpty
00000D84: E28F00F1    ;     adrl R0, gridloadempty
00000D88: E2800C16    ; 
00000D8C: EF000003    ;     swi 3
00000D90:             ; 
00000D90:             ; listGridsLend
00000D90:             ; listGridsEnd
00000D90: E8BD47F0    ;     pop {R14, R4-R10}
00000D94: E1A0F00E    ;     mov R15, R14
00000D98:             ; 
00000D98:             ; saveGrid
00000D98:             ; ;;INP in R0 is the ptr gridInfo struct (in the main's stackframe)
00000D98:             ; ;;INP in R1 is the char* to the name
00000D98:             ; ;;INP in R2 is the active grid
00000D98:             ; ;;RET in R0 is an errcode or 0 for success. 1 for malloc error
00000D98:             ; 
00000D98:             ; ;;if reachedCap -> realloc + inc maxsize
00000D98:             ; ;;copy the current grid to another loc and place info in gridArr
00000D98:             ; ;;inc current index
00000D98: E92D47F0    ;     push {R14, R4-R10}
00000D9C:             ; 
00000D9C: E1A04000    ;     mov R4, R0
00000DA0: E1A05001    ;     mov R5, R1
00000DA4: E1A0A002    ;     mov R10, R2
00000DA8:             ; 
00000DA8: E5942008    ;     ldr R2, [R4, #8] ;;get the current index
00000DAC: E5943004    ;     ldr R3, [R4, #4] ;;get the maxsize
00000DB0:             ; 
00000DB0: E1520003    ;     cmp R2, R3
00000DB4: 0A000000    ;     beq saveGridResize
00000DB8: EA00000D    ;     b saveGridAdd
00000DBC:             ; 
00000DBC:             ; saveGridResize
00000DBC:             ;     ;;maxsize in R3
00000DBC: E1A06083    ;     mov R6, R3, lsl #1 ;;double the capacity
00000DC0: E3A0700C    ;     ldr R7, =sizeofSaveI
00000DC4: E0070796    ;     mul R7, R6, R7 ;;get the number of bytes
00000DC8:             ; 
00000DC8: E1A00007    ;     mov R0, R7
00000DCC: EB000305    ;     bl malloc ;;get the new grid
00000DD0:             ; 
00000DD0: E3500000    ;     cmp R0, #0 ;;if malloc failed then don't do any saving
00000DD4: 0A000020    ;     beq saveGridFailMalloc
00000DD8:             ; 
00000DD8: E1A01000    ;     mov R1, R0
00000DDC: E1A08000    ;     mov R8, R0 ;;save of ptr
00000DE0:             ; 
00000DE0:             ;     ;;now that we have the new grid we need to memcpy the bytes from the original into the new 
                      ; one
00000DE0: E5940000    ;     ldr R0, [R4, #0] ;;get the array ptr
00000DE4:             ;     ;;R1 has the malloced address
00000DE4: E1A020A7    ;     mov R2, R7, lsr #1 ;;not great, this is the double cap halfed, means no mul again
00000DE8: EB000073    ;     bl memcpy
00000DEC:             ; 
00000DEC:             ;     ;;assume success because I didn't give memcpy an err code :)
00000DEC:             ;     ;;need to store the new size and arr ptr in the gridinfo struct
00000DEC:             ; 
00000DEC: E5848000    ;     str R8, [R4, #0]
00000DF0: E5846004    ;     str R6, [R4, #4]
00000DF4:             ; 
00000DF4:             ; saveGridAdd
00000DF4:             ; ;;add the current grid to the array
00000DF4: E5946000    ;     ldr R6, [R4, #0] ;;get the arr ptr
00000DF8: E5947008    ;     ldr R7, [R4, #8] ;;get current index
00000DFC:             ; 
00000DFC:             ;     ;;ptr is 4 bytes
00000DFC:             ;     ;;we're adding the struct of 
00000DFC:             ;     ;;  |-grid*     (ptr)
00000DFC:             ;     ;;  |-char*     (ptr)
00000DFC:             ;     ;;  |-width     (byte)
00000DFC:             ;     ;;  `-height    (byte)
00000DFC:             ; 
00000DFC:             ;     ;;we need to copy the current array
00000DFC: E55F8DB1    ;     ldrb R8, width
00000E00: E55F9DB4    ;     ldrb R9, height
00000E04: E0080998    ;     mul R8, R8, R9 ;;get the number of bytes in grid
00000E08:             ; 
00000E08: E1A00008    ;     mov R0, R8
00000E0C: EB0002F5    ;     bl malloc ;;allocate a new grid
00000E10:             ; 
00000E10: E3500000    ;     cmp R0, #0
00000E14: 0A000010    ;     beq saveGridFailMalloc
00000E18:             ; 
00000E18: E92D0100    ;     push {R8} ;; :(
00000E1C:             ; 
00000E1C: E3A0800C    ;     ldr R8, =sizeofSaveI
00000E20: E0266897    ;     mla R6, R7, R8, R6 ;;currentindex * sizeof(Gridinfo) + arrptr
00000E24: E5860000    ;     str R0, [R6, #0] ;;store the grid*
00000E28: E5865004    ;     str R5, [R6, #4] ;;store the char*
00000E2C: E55F8DE1    ;     ldrb R8, width
00000E30: E5C68008    ;     strb R8, [R6, #8]
00000E34: E5C69009    ;     strb R9, [R6, #9]
00000E38:             ; 
00000E38: E8BD0100    ;     pop {R8}
00000E3C:             ; 
00000E3C: E1A01000    ;     mov R1, R0 ;;dst
00000E40: E1A0000A    ;     mov R0, R10 ;;src
00000E44: E1A02008    ;     mov R2, R8 ;;num bytes
00000E48: EB00005B    ;     bl memcpy ;;copy the grid into the new location
00000E4C:             ; 
00000E4C:             ;     ;;inc the position
00000E4C: E5940008    ;     ldr R0, [R4, #8]
00000E50: E2800001    ;     add R0, R0, #1
00000E54: E5840008    ;     str R0, [R4, #8]
00000E58:             ; 
00000E58: EA000001    ;     b saveGridSucc
00000E5C:             ; 
00000E5C:             ; saveGridFailMalloc
00000E5C: E3A00001    ;     mov R0, #1
00000E60: EA000000    ;     b saveGridEnd
00000E64:             ; 
00000E64:             ; saveGridSucc
00000E64: E3A00000    ;     mov R0, #0
00000E68:             ; 
00000E68:             ; saveGridEnd
00000E68: E8BD47F0    ;     pop {R14, R4-R10}
00000E6C: E1A0F00E    ;     mov R15, R14
00000E70:             ; 
00000E70:             ; erase
00000E70:             ; ;;INP in R0 is the itters
00000E70:             ; ;;for (width * height + 1) * 2 + 1
00000E70:             ; ;;      print('\b')
00000E70: E1A01000    ;     mov R1, R0
00000E74:             ; 
00000E74:             ; eraseloop
00000E74: E3510000    ;     cmp R1, #0
00000E78: 0A000003    ;     beq eraseend
00000E7C:             ; 
00000E7C: E3A00008    ;     ldr R0, =backspace
00000E80: EF000000    ;     swi 0
00000E84:             ; 
00000E84: E2411001    ;     sub R1, R1, #1
00000E88: EAFFFFF9    ;     b eraseloop
00000E8C:             ; 
00000E8C:             ; eraseend
00000E8C: E1A0F00E    ;     mov R15, R14
00000E90:             ; 
00000E90:             ; slow
00000E90: E3A010FF    ;     mov R1, #0xFF
00000E94: E1A01081    ;     mov R1, R1, lsl #1
00000E98:             ; 
00000E98:             ; slowloop
00000E98: E3510000    ;     cmp R1, #0
00000E9C: 0A000005    ;     beq slowend
00000EA0:             ; 
00000EA0: E3A00020    ;     mov R0, #' '
00000EA4: EF000000    ;     swi 0
00000EA8: E3A00008    ;     ldr R0, =backspace
00000EAC: EF000000    ;     swi 0
00000EB0:             ; 
00000EB0: E2411001    ;     sub R1, R1, #1
00000EB4: EAFFFFF7    ;     b slowloop
00000EB8:             ; 
00000EB8:             ; slowend
00000EB8: E1A0F00E    ;     mov R15, R14
00000EBC:             ; 
00000EBC:             ; heapclean
00000EBC:             ; ;;zero out all memory in the heap (debugging uses)
00000EBC: E28F0EF9    ;     adrl R0, heapstart
00000EC0: E2800A01    ; 
00000EC4: E3A01601    ;     ldr R1, =max_addr ;;stores the end of the heap
00000EC8: E3A02801    ;     ldr R2, =stack_size
00000ECC: E0411002    ;     sub R1, R1, R2 ;; R1 = max_addr - stack_size which should be the heap end
00000ED0: E3C11003    ;     and R1, R1, #-4 ;;align to 4 byte boundry just in case
00000ED4: E3A03000    ;     mov R3, #0
00000ED8:             ; heapcleanloop ;;starting at heapstart
00000ED8: E1500001    ;     cmp R0, R1
00000EDC: 0A000002    ;     beq heapcleanend
00000EE0: E5003000    ;     str R3, [R0] ;;store 0 in loc
00000EE4: E2800004    ;     add R0, R0, #4 ;;inc by a word
00000EE8: EAFFFFFA    ;     b heapcleanloop
00000EEC:             ; heapcleanend
00000EEC: E1A0F00E    ;     mov R15, R14
00000EF0:             ; 
00000EF0:             ; strlen
00000EF0:             ; ;;INP in R0 is the address of the string
00000EF0:             ; ;;OUT in R0 is the length of the null terminated string
00000EF0:             ; 
00000EF0:             ; ;;len = 0
00000EF0:             ; ;;while(inp[len] != \0) {len++;}
00000EF0:             ; ;;return len
00000EF0:             ; 
00000EF0: E3A01000    ;     mov R1, #0 ;;len
00000EF4: E3500000    ;     cmp R0, #0
00000EF8: 0A000004    ;     beq strlenend
00000EFC:             ; 
00000EFC:             ; strlenloop
00000EFC: E7D02001    ;     ldrb R2, [R0, R1]
00000F00: E3520000    ;     cmp R2, #0
00000F04: 0A000001    ;     beq strlenend
00000F08: E2811001    ;     add R1, R1, #1
00000F0C: EAFFFFFA    ;     b strlenloop
00000F10:             ; 
00000F10:             ; strlenend
00000F10: E1A00001    ;     mov R0, R1
00000F14: E1A0F00E    ;     mov R15, R14
00000F18:             ; 
00000F18:             ; 
00000F18:             ; strtoi
00000F18:             ; ;;INP in R0 is the address of the string
00000F18:             ; ;;OUT in R0 is the value created
00000F18:             ; ;;OUT in R1 is the err code
00000F18:             ; ;;
00000F18:             ; ;;ERR codes
00000F18:             ; ;;  0 is success
00000F18:             ; ;;  1 is attempted -ve
00000F18:             ; ;;  2 is use of non-numeric characters
00000F18:             ; ;;  3 is value out of range of integer
00000F18:             ; ;;  4 is null string given
00000F18:             ; 
00000F18:             ; ;;  example inp
00000F18:             ; ;;  12234       len = 5
00000F18:             ; ;;      ^-find end
00000F18:             ; ;;  tot = 0
00000F18:             ; ;;  for i from end to 0:
00000F18:             ; ;;      tot += inp[i] * (10 ** (len(inp) - i - 1))
00000F18:             ; ;;  +some checks for valid input
00000F18:             ; 
00000F18:             ; ;;This will take in an address to the start of a string and attempt to convert it into an integ
                      ; er
00000F18:             ; ;;String is only valid when all characters are numerical
00000F18:             ; ;;For now it does not accept -ve numbers
00000F18:             ; 
00000F18: E92D41F0    ;     push {R14, R4-R8}
00000F1C: E1A04000    ;     mov R4, R0  ;;R4 holds the addr
00000F20:             ; 
00000F20: E3500000    ;     cmp R0, #0
00000F24: 03A01004    ;     moveq R1, #4
00000F28: 0A00001E    ;     beq strtoiendfail ;;null given so err code = 4 and end
00000F2C:             ; 
00000F2C: EBFFFFEF    ;     bl strlen
00000F30: E1A05000    ;     mov R5, R0  ;;R5 holds the len of the string
00000F34:             ; 
00000F34: E3550000    ;     cmp R5, #0
00000F38: 0A00001C    ;     beq strtoiendsucc ;;if len(string) == 0 then return 0
00000F3C:             ; 
00000F3C: E5D46000    ;     ldrb R6, [R4, #0]
00000F40: E356002D    ;     cmp R6, #45
00000F44: 0A000012    ;     beq strtoifailminus
00000F48:             ; 
00000F48: E3A06000    ;     mov R6, #0  ;;R6 holds the total
00000F4C: E3A07001    ;     mov R7, #1  ;;R7 holds the **
00000F50: E2458001    ;     sub R8, R5, #1  ;;R8 is i which starts at end (len - 1)
00000F54: E3A0300A    ;     mov R3, #10 ;;mul to **
00000F58:             ; 
00000F58:             ; strtoiloop
00000F58: E3580000    ;     cmp R8, #0
00000F5C: BA00000A    ;     blt strtoilend
00000F60:             ; 
00000F60: E7D42008    ;     ldrb R2, [R4, R8]
00000F64: E2422030    ;     sub R2, R2, #48
00000F68:             ; 
00000F68: E3520000    ;     cmp R2, #0
00000F6C: BA00000C    ;     blt strtoifailnonnum
00000F70: E3520009    ;     cmp R2, #9
00000F74: CA00000A    ;     bgt strtoifailnonnum
00000F78:             ; 
00000F78: E0266792    ;     mla R6, R2, R7, R6 ;;total = (inp[i] * (**)) + total -> total += inp[i] * (**)
00000F7C: 6A000006    ;     bvs strtoifailoutrange
00000F80: E0070397    ;     mul R7, R7, R3
00000F84:             ; 
00000F84: E2488001    ;     sub R8, R8, #1
00000F88:             ; 
00000F88: EAFFFFF2    ;     b strtoiloop
00000F8C:             ; 
00000F8C:             ; 
00000F8C:             ; ;;branches are expensive - should this just be rep RET? probably doesn't matter at this scale
00000F8C:             ; strtoilend
00000F8C: E1A00006    ;     mov R0, R6
00000F90: EA000006    ;     b strtoiendsucc
00000F94:             ; 
00000F94:             ; strtoifailminus
00000F94: E3A01001    ;     mov R1, #1
00000F98: EA000002    ;     b strtoiendfail
00000F9C:             ; 
00000F9C:             ; strtoifailoutrange
00000F9C: E3A01003    ;     mov R1, #3
00000FA0: EA000000    ;     b strtoiendfail
00000FA4:             ; 
00000FA4:             ; strtoifailnonnum
00000FA4: E3A01002    ;     mov R1, #2
00000FA8:             ; 
00000FA8:             ; strtoiendfail
00000FA8: E3A00000    ;     mov R0, #0
00000FAC: EA000000    ;     b strtoiend
00000FB0:             ; 
00000FB0:             ; strtoiendsucc
00000FB0: E3A01000    ;     mov R1, #0
00000FB4:             ; 
00000FB4:             ; strtoiend
00000FB4: E8BD41F0    ;     pop {R14, R4-R8}
00000FB8: E1A0F00E    ;     mov R15, R14
00000FBC:             ; 
00000FBC:             ; memcpy
00000FBC:             ; ;;INP in R0 is the addr of src
00000FBC:             ; ;;INP in R1 is the addr of dst
00000FBC:             ; ;;INP in R2 is the number of bytes to copy
00000FBC:             ; 
00000FBC:             ; ;;check if src and dst are alliged
00000FBC:             ; ;;If different then write bytes
00000FBC:             ; ;;If same then go to 4byte boundry
00000FBC:             ; ;;  Write words of bytes2copy / 4
00000FBC:             ; ;;  Write remaining bytes
00000FBC: E92D41F0    ;     push {R14, R4-R8}
00000FC0:             ; 
00000FC0: E2004003    ;     and R4, R0, #0b11
00000FC4: E2015003    ;     and R5, R1, #0b11
00000FC8:             ; 
00000FC8: E1540005    ;     cmp R4, R5
00000FCC: 1A00000E    ;     bne memcpyallbytes
00000FD0:             ; 
00000FD0:             ;     ;;If they are the same then cpy R4 bytes and then do words
00000FD0: E0422004    ;     sub R2, R2, R4;; bytes2cpy -= bytes we are about to write
00000FD4: E1A03004    ;     mov R3, R4
00000FD8: EB00000E    ;     bl memcpybytes
00000FDC:             ; 
00000FDC:             ;     ;;Now find the number of words that can be written i.e. bytes2cpy / 4 (bytes2cpy >> 2)
00000FDC: E3C23003    ;     and R3, R2, #-4 ;;the number of bytes to write that make up the words
00000FE0: E3A04000    ;     mov R4, #0 ;;i
00000FE4:             ; memcpywordsloop
00000FE4: E1540003    ;     cmp R4, R3
00000FE8: 0A000003    ;     beq memcpywordslend
00000FEC:             ; 
00000FEC: E7906004    ;     ldr R6, [R0, R4]
00000FF0: E7816004    ;     str R6, [R1, R4]
00000FF4:             ;     
00000FF4: E2844004    ;     add R4, R4, #4
00000FF8:             ; 
00000FF8: EAFFFFF9    ;     b memcpywordsloop
00000FFC:             ;     
00000FFC:             ; memcpywordslend
00000FFC:             ; ;;Now copy the remaining bytes
00000FFC: E2022003    ;     and R2, R2, #0b11
00001000: E1A03002    ;     mov R3, R2
00001004: EB000003    ;     bl memcpybytes
00001008: EA00000A    ;     b memcpyend
0000100C:             ; 
0000100C:             ; memcpyallbytes
0000100C: E1A03002    ;     mov R3, R2
00001010: EB000000    ;     bl memcpybytes
00001014: EA000007    ;     b memcpyend
00001018:             ; 
00001018:             ; memcpybytes
00001018:             ; ;;This is an internal function to memcpy and so doesn't follow the calling convention, it also 
                      ; assumes values are in place from memcpy
00001018:             ; ;;for (int i = 0; i < byte2cpy; i++) {
00001018:             ; ;;      *(dst + i) = *(src + i)
00001018:             ; ;;INP in R3 is the number of bytes to copy
00001018: E3A05000    ;     mov R5, #0 ;;i
0000101C:             ; memcpybytesloop
0000101C: E1550003    ;     cmp R5, R3
00001020: 0A000003    ;     beq memcpybyteslend ;;i < bytes2cpy
00001024:             ; 
00001024: E7D04005    ;     ldrb R4, [R0, R5]
00001028: E7C14005    ;     strb R4, [R1, R5] ;;dst[i] = src[i]
0000102C:             ; 
0000102C: E2855001    ;     add R5, R5, #1 ;;i++
00001030:             ; 
00001030: EAFFFFF9    ;     b memcpybytesloop
00001034:             ; 
00001034:             ; memcpybyteslend
00001034: E1A0F00E    ;     mov R15, R14
00001038:             ; 
00001038:             ; memcpyend
00001038: E8BD41F0    ;     pop {R14, R4-R8}
0000103C: E1A0F00E    ;     mov R15, R14
00001040:             ; 
00001040:             ; getstring
00001040:             ; ;;INP in R0 the terminator character
00001040:             ; ;;INP in R1 the max number of characters or -1 for no max
00001040:             ; ;;INP in R2 boolean (non-0/0) for if letters should be printed out as well
00001040:             ; ;;RET in R0 a ptr to the memory address
00001040:             ; ;;
00001040:             ; ;;Dynamically allocate memory to support large string
00001040:             ; 
00001040:             ; ;;buff = malloc(minBytes)
00001040:             ; ;;while (input != terminator && pos < maxchars) 
00001040:             ; ;;  buff[pos] = input
00001040:             ; ;;  putchar(input)
00001040:             ; ;;  if (pos > buffSize)
00001040:             ; ;;      nBuff = malloc(buffSize << 1)
00001040:             ; ;;      memcpy from buff to nBuff
00001040:             ; ;;      free buff
00001040:             ; ;;      buff = nBuff
00001040:             ; 
00001040: E92D47F0    ;     push {R14, R4-R10}
00001044:             ; 
00001044: E1A08000    ;     mov R8, R0 ;;now holds terminator
00001048: E1A09001    ;     mov R9, R1 ;;nax chars
0000104C: E3590000    ;     cmp R9, #0
00001050: 0A00003A    ;     beq getstringEnd
00001054:             ;     ;sub R9, R9, #1 ;;reduce by 1 to use later
00001054: E1A0A002    ;     mov R10, R2 ;;print bool
00001058:             ; 
00001058: E3A06008    ;     ldr R6, =minBuffSize ;;R6 will hold the current size of the buffer
0000105C: E1A00006    ;     mov R0, R6
00001060: EB000260    ;     bl malloc
00001064:             ; 
00001064: E3500000    ;     cmp R0, #0
00001068: 0A000032    ;     beq getstringErr
0000106C:             ; 
0000106C: E1A04000    ;     mov R4, R0 ;;R4 is the address of the buffer
00001070:             ; 
00001070: E3A05000    ;     mov R5, #0 ;;R5 is the loop counter/index into buffer
00001074:             ; getstringloop
00001074: E3790001    ;     cmp R9, #-1
00001078: 0A000001    ;     beq getstringloopskipsize
0000107C: E1550009    ;     cmp R5, R9 ;;position - maxsize
00001080:             ;                       ;;pos 2 means 3 characters written
00001080: AA00001B    ;     bge getstringlend ;;if position >= maxsize
00001084:             ; getstringloopskipsize
00001084: EF000001    ;     swi 1 ;;get input
00001088: E1500008    ;     cmp R0, R8 ;;is input == terminator character
0000108C: 0A000018    ;     beq getstringlend
00001090:             ; 
00001090: E3790001    ;     cmp R9, #-1
00001094: 0AFFFFFF    ;     beq skipMax
00001098:             ;     
00001098:             ; skipMax
00001098: E1550006    ;     cmp R5, R6
0000109C: E92D0001    ;     push {R0}
000010A0: AA000005    ;     bge getstringresize
000010A4:             ; 
000010A4:             ; getstringlcont
000010A4: E8BD0001    ;     pop {R0}
000010A8: E7C40005    ;     strb R0, [R4, R5] ;;buff[pos] = input
000010AC:             ; 
000010AC: E35A0000    ;     cmp R10, #0
000010B0: 1F000000    ;     swine 0 ;;output the character to the screen if R10 is not 0
000010B4:             ; 
000010B4: E2855001    ;     add R5, R5, #1
000010B8:             ; 
000010B8: EAFFFFED    ;     b getstringloop
000010BC:             ; 
000010BC:             ; getstringresize
000010BC:             ;     ;;r6 will hold new buffer
000010BC: E1A00086    ;     mov R0, R6, lsl #1
000010C0: EB000248    ;     bl malloc
000010C4:             ; 
000010C4: E3500000    ;     cmp R0, #0
000010C8: 0A00001A    ;     beq getstringErr
000010CC:             ; 
000010CC: E1A07000    ;     mov R7, R0
000010D0:             ; 
000010D0: E1A00004    ;     mov R0, R4 ;;old buff
000010D4: E1A01007    ;     mov R1, R7 ;;newBuff
000010D8: E1A02005    ;     mov R2, R5 ;;bytes to write
000010DC: EBFFFFB6    ;     bl memcpy
000010E0:             ; 
000010E0: E1A00004    ;     mov R0, R4
000010E4: EB0002E2    ;     bl free
000010E8: E1A04007    ;     mov R4, R7
000010EC:             ; 
000010EC: E1A06086    ;     mov R6, R6, lsl #1
000010F0:             ; 
000010F0: EAFFFFEB    ;     b getstringlcont
000010F4:             ; 
000010F4:             ; getstringlend
000010F4:             ;     ;;need to add a \0
000010F4:             ;     ;;need to check if the buffer is completely full -> resize buffer to +1? (will be aligned t
                      ; o 8 in malloc!) then copy
000010F4:             ;     ;;I could have the buffers always leave a space open for the \0? but this is kind of an edg
                      ; e case?
000010F4: E1550006    ;     cmp R5, R6 ;;position to size of buffer
000010F8: 0A000000    ;     beq getstringResizeEnd
000010FC:             ; 
000010FC: EA00000F    ;     b getstringEnd
00001100:             ; 
00001100:             ; getstringResizeEnd
00001100: E2860001    ;     add R0, R6, #1
00001104: EB000237    ;     bl malloc
00001108:             ; 
00001108: E3500000    ;     cmp R0, #0
0000110C: 0A000009    ;     beq getstringErr
00001110:             ; 
00001110: E1A07000    ;     mov R7, R0
00001114:             ; 
00001114: E1A00004    ;     mov R0, R4;;old buff
00001118: E1A01007    ;     mov R1, R7;;new buff
0000111C: E1A02005    ;     mov R2, R5;;bytes2write
00001120: EBFFFFA5    ;     bl memcpy
00001124:             ; 
00001124: E1A00004    ;     mov R0, R4
00001128: EB0002D1    ;     bl free
0000112C: E1A04007    ;     mov R4, R7
00001130:             ; 
00001130: E2866001    ;     add R6, R6, #1 ;;not needed
00001134:             ; 
00001134: EA000001    ;     b getstringEnd
00001138:             ; 
00001138:             ; getstringErr
00001138: E3A00000    ;     mov R0, #0
0000113C: EA000002    ;     b getstringEndEnd
00001140:             ; 
00001140:             ; getstringEnd
00001140: E3A00000    ;     mov R0, #0
00001144: E7C40005    ;     strb R0, [R4, R5]
00001148:             ; 
00001148: E1A00004    ;     mov R0, R4
0000114C:             ; 
0000114C:             ; getstringEndEnd
0000114C: E8BD47F0    ;     pop {R14, R4-R10}
00001150: E1A0F00E    ;     mov R15, R14
00001154:             ; 
00001154:             ; tolower
00001154:             ; ;;INP in R0 is a character
00001154:             ; ;;OUT in R0 is the character.lower()
00001154: E3800020    ;     orr R0, R0, #32
00001158: E1A0F00E    ;     mov R15, R14
0000115C:             ; 
0000115C:             ; setupGrid
0000115C:             ; ;;INP --
0000115C:             ; ;;RET in R0 is err code, non-0 is error
0000115C:             ; ;;The values addresses of the grids will now be set, can still be 0
0000115C:             ; ;; ask for generation mode
0000115C:             ; ;;      |-If random ask for seed
0000115C:             ; ;;      |   `-For generation roll the seed to create a pseudorandom value for each `pixel`
0000115C:             ; ;;      `-If draw then get them to draw the grid one `pixel` at a time
0000115C: E92D47F0    ;     push {R14, R4-R10}
00001160:             ; 
00001160:             ;     ;;generate the main grid
00001160: E24F6015    ;     adrl R6, width
00001164: E2466C11    ; 
00001168: E5566000    ;     ldrb R6, [R6]
0000116C: E24F7E12    ;     adrl R7, height
00001170: E2477A01    ; 
00001174: E5577000    ;     ldrb R7, [R7]
00001178:             ; 
00001178: E0000796    ;     mul R0, R6, R7 ;;width * height = num of bytes to malloc
0000117C:             ; 
0000117C: E1A05000    ;     mov R5, R0
00001180: EB000218    ;     bl malloc
00001184:             ; 
00001184: E1A04000    ;     mov R4, R0
00001188: E24F1F52    ;     adrl R1, gridA
0000118C: E2411A01    ; 
00001190: E5014000    ;     str R4, [R1]
00001194:             ; 
00001194: E1A00005    ;     mov R0, R5
00001198: EB000212    ;     bl malloc
0000119C: E24F1F56    ;     adrl R1, gridB
000011A0: E2411A01    ; 
000011A4: E5010000    ;     str R0, [R1]
000011A8:             ; 
000011A8: E3500000    ;     cmp R0, #0      ;;If either grid failed to malloc
000011AC: 0A00006A    ;     beq setupGridFail
000011B0: E3540000    ;     cmp R4, #0
000011B4: 0A000068    ;     beq setupGridFail
000011B8:             ; 
000011B8:             ;     ;;R4 holds the gridA addr
000011B8:             ;     ;;R6 holds the width
000011B8:             ;     ;;R7 holds the height
000011B8:             ; 
000011B8: E28F00F2    ;     adrl R0, askgenoption
000011BC: E2800A01    ; 
000011C0: EF000003    ;     swi 3
000011C4:             ; setupGridAsk
000011C4: EF000001    ;     swi 1
000011C8: E3800020    ;     orr R0, R0, #32
000011CC:             ; 
000011CC: E1A01000    ;     mov R1, R0
000011D0: EBFFFE8C    ;     bl newline
000011D4:             ; 
000011D4: E3510064    ;     cmp R1, #'d'
000011D8: 0A000005    ;     beq setupdrawing
000011DC:             ; 
000011DC: E3510072    ;     cmp R1, #'r'
000011E0: 0A00000C    ;     beq setuprandom
000011E4:             ; 
000011E4: E28F00FF    ;     adrl R0, setupGrdFailmsg
000011E8: E2800A01    ; 
000011EC: EF000003    ;     swi 3
000011F0: EAFFFFF3    ;     b setupGridAsk
000011F4:             ; 
000011F4:             ; setupdrawing
000011F4: E3A09000    ;     mov R9, #0
000011F8:             ; 
000011F8: E28F0F5E    ;     adrl R0, drawinfomsg
000011FC: E2800A01    ; 
00001200: EF000003    ;     swi 3
00001204:             ; 
00001204:             ;     ;;clean the grid
00001204: E1A00004    ;     mov R0, R4
00001208: E0214796    ;     mla R1, R6, R7, R4 ;; width * height = bytes inside + address = endAddr. 
0000120C: E3A02000    ;     mov R2, #0
00001210: EB0002D0    ;     bl memset
00001214:             ; 
00001214: EA00000C    ;     b setupstart
00001218:             ; 
00001218:             ; setuprandom
00001218: E28F0F4B    ;     adrl R0, askseed
0000121C: E2800A01    ; 
00001220: EF000003    ;     swi 3
00001224:             ; 
00001224: E3A00000    ;     mov R0, #0
00001228: E3A01004    ;     mov R1, #4
0000122C: E3A02001    ;     mov R2, #1
00001230: EBFFFF82    ;     bl getstring
00001234:             ; 
00001234: E3500000    ;     cmp R0, #0
00001238: 0A000047    ;     beq setupGridFail
0000123C:             ; 
0000123C: E5108000    ;     ldr R8, [R0]
00001240:             ; 
00001240: EB00028B    ;     bl free
00001244:             ; 
00001244: EBFFFE6F    ;     bl newline
00001248:             ; 
00001248: E3A09001    ;     mov R9, #1
0000124C:             ; 
0000124C:             ; setupstart
0000124C:             ; ;;This is probably not a good way to do it as there is more branching in the middle of a loop t
                      ; hat is executed alot
0000124C:             ; ;;I'm doing it this way `not because it is easy, but because I though it would be easy`
0000124C:             ; ;;Reduces the need for writing another loop :)
0000124C:             ; ;;R9 holds the mode (1 for random, 0 for draw)
0000124C:             ; ;;R8 will hold the seed for random
0000124C:             ; ;;for row from 0 to height - 1
0000124C:             ; ;;  for col from 0 to width - 1
0000124C:             ; ;;      if (random)
0000124C:             ; ;;          grid[row][col] = ((seed rol 1) || row) && 1
0000124C:             ; ;;      else
0000124C:             ; ;;          grid[row][col] = input() == 1
0000124C: E3A05000    ;     mov R5, #0 ;; row
00001250:             ; setuprowloop
00001250: E1550007    ;     cmp R5, R7
00001254: 0A00003E    ;     beq setuprowlend
00001258:             ; 
00001258: E3A0A000    ;     mov R10, #0 ;;col
0000125C:             ; setupcolloop
0000125C: E15A0006    ;     cmp R10, R6
00001260: 0A000039    ;     beq setupcollend
00001264:             ; 
00001264: E3590001    ;     cmp R9, #1
00001268: 0A000000    ;     beq dorandom
0000126C: EA000004    ;     b dodrawstart
00001270:             ; 
00001270:             ; ;;dorandom and dodraw will get their value for this position and then place it in R2
00001270:             ; ;;R3 is free at this point
00001270:             ; dorandom
00001270:             ;     ;;seed in R8
00001270: E1A080E8    ;     mov R8, R8, ror #1
00001274: E00A3005    ;     and R3, R10, R5
00001278: E0288003    ;     eor R8, R8, R3
0000127C: E2082001    ;     and R2, R8, #1
00001280: EA00002D    ;     b setupcollcont
00001284:             ; 
00001284:             ; dodrawstart
00001284: E023A695    ;     mla R3, R5, R6, R10 ;;R3 = row * width + col
00001288:             ; 
00001288: E3A00002    ;     mov R0, #2
0000128C: E7C40003    ;     strb R0, [R4, R3]
00001290:             ; 
00001290: E3590000    ;     cmp R9, #0
00001294: 01A00004    ;     moveq R0, R4
00001298: 0B000035    ;     bleq drawgrid ;;print the new state of the grid if this is drawing mode
0000129C:             ; 
0000129C:             ; dodraw
0000129C:             ;     ;;get input, validate 1 or 0
0000129C:             ;     ;;if invalid print error loop back
0000129C:             ;     ;;-_- I've just realised I want to print the grid each time as well R0-R3 are scratch
0000129C: EF000001    ;     swi 1
000012A0:             ; 
000012A0: E3500031    ;     cmp R0, #'1'
000012A4: 0A000017    ;     beq dodrawsucc
000012A8: E3500030    ;     cmp R0, #'0'
000012AC: 0A000015    ;     beq dodrawsucc
000012B0:             ; 
000012B0: E3A0100A    ;     ldr R1, =enter
000012B4: E1500001    ;     cmp R0, R1;;next line
000012B8: 1A00000E    ;     bne dodrawfail
000012BC:             ; 
000012BC: E023A695    ;     mla R3, R5, R6, R10 ;;R3 = row * width + col
000012C0: E3A00000    ;     mov R0, #0
000012C4: E7C40003    ;     strb R0, [R4, R3]
000012C8:             ; 
000012C8: E2855001    ;     add R5, R5, #1
000012CC:             ; 
000012CC: E24F0F9F    ;     adrl R0, drawerase_b
000012D0: E2400A01    ; 
000012D4: E5500000    ;     ldrb R0, [R0]
000012D8: E3500000    ;     cmp R0, #0
000012DC: 0AFFFFDB    ;     beq setuprowloop
000012E0:             ; 
000012E0: E0000796    ;     mul R0, R6, R7      ;;I don't like having to do this every time :(
000012E4: E1A00080    ;     mov R0, R0, lsl #1
000012E8: E2800001    ;     add R0, R0, #1
000012EC: E0800007    ;     add R0, R0, R7
000012F0: EBFFFEDE    ;     bl erase
000012F4:             ; 
000012F4: EAFFFFD5    ;     b setuprowloop
000012F8:             ; 
000012F8:             ; dodrawfail
000012F8:             ; 
000012F8: E28F00CE    ;     adrl R0, drawfailmsg
000012FC: E2800A01    ; 
00001300: EF000003    ;     swi 3
00001304:             ; 
00001304: EAFFFFE4    ;     b dodraw
00001308:             ; 
00001308:             ; dodrawsucc
00001308: E92D0001    ;     push {R0}
0000130C: E24F0FAF    ;     adrl R0, drawerase_b
00001310: E2400A01    ; 
00001314: E5500000    ;     ldrb R0, [R0]
00001318: E3500000    ;     cmp R0, #0
0000131C: 0A000004    ;     beq dodrawsuccskiperase
00001320:             ; 
00001320: E0000796    ;     mul R0, R6, R7      ;;I don't like having to do this every time :(
00001324: E1A00080    ;     mov R0, R0, lsl #1
00001328: E2800001    ;     add R0, R0, #1
0000132C: E0800007    ;     add R0, R0, R7
00001330: EBFFFECE    ;     bl erase
00001334:             ;     
00001334:             ; dodrawsuccskiperase
00001334: E8BD0001    ;     pop {R0}
00001338:             ; 
00001338: E2402030    ;     sub R2, R0, #48 ;;could be xor?
0000133C:             ; 
0000133C:             ; setupcollcont
0000133C:             ;     ;;place the value in R2 into the grid[row][col]
0000133C:             ;     ;;row * width + col
0000133C: E023A695    ;     mla R3, R5, R6, R10 ;;R3 = row * width + col ;;I'm doing this twice \-(*v*)-/
00001340: E7C42003    ;     strb R2, [R4, R3] ;;grid offset by R3
00001344:             ; 
00001344: E28AA001    ;     add R10, R10, #1
00001348: EAFFFFC3    ;     b setupcolloop
0000134C:             ; setupcollend
0000134C: E2855001    ;     add R5, R5, #1
00001350: EAFFFFBE    ;     b setuprowloop
00001354:             ; setuprowlend
00001354:             ;     ;;grid has been setup
00001354: E3A00000    ;     mov R0, #0 ;;success
00001358: EA000003    ;     b setupGridEnd
0000135C:             ; 
0000135C:             ; setupGridFail
0000135C: E28F0041    ;     adrl R0, malloc_panic
00001360: E2800C19    ; 
00001364: EF000003    ;     swi 3
00001368:             ; 
00001368: E3A00001    ;     mov R0, #1 ;;fail!
0000136C:             ; 
0000136C:             ; setupGridEnd
0000136C: E8BD47F0    ;     pop {R14, R4-R10}
00001370: E1A0F00E    ;     mov R15, R14
00001374:             ; 
00001374:             ; 
00001374:             ; ;;[[TODO]] the heap may not be blank (when heapclean is removed) and so need to 0 the mem. Mayb
                      ; e add option to malloc or add calloc (not the same)
00001374:             ; drawgrid
00001374:             ; ;;INP in R0 is the grid address to draw
00001374:             ; 
00001374:             ; ;;for row from 0 to height - 1
00001374:             ; ;;  for col from 0 to width - 1
00001374:             ; ;;      print('X' if grid[row][col] else '_')
00001374:             ; ;;  print(newline)
00001374:             ; ;;print(newline)
00001374: E92D01F0    ;     push {R4-R8}
00001378:             ; 
00001378: E1A06000    ;     mov R6, R0
0000137C:             ; 
0000137C: E24F4031    ;     adrl R4, width
00001380: E2444C13    ; 
00001384: E5544000    ;     ldrb R4, [R4]
00001388: E24F5FCF    ;     adrl R5, height
0000138C: E2455A01    ; 
00001390: E5555000    ;     ldrb R5, [R5]
00001394:             ; 
00001394: E3A02000    ;     mov R2, #0 ;;row
00001398:             ; drawgridrowloop
00001398: E1520005    ;     cmp R2, R5
0000139C: 0A00001C    ;     beq drawgridrowlend
000013A0:             ; 
000013A0: E3A01000    ;     mov R1, #0 ;;col
000013A4:             ; drawgridcolloop
000013A4: E1510004    ;     cmp R1, R4
000013A8: 0A000014    ;     beq drawgridcollend
000013AC:             ; 
000013AC: E0231492    ;     mla R3, R2, R4, R1 ;;R3 = row * width + col
000013B0: E7D63003    ;     ldrb R3, [R6, R3]
000013B4:             ; 
000013B4: E3530002    ;     cmp R3, #2
000013B8: 0A000008    ;     beq drawgridprintcurrent
000013BC: E3530001    ;     cmp R3, #1
000013C0: 024F006F    ;     adrleq R0, alive_c
000013C4: 02400C13    ; 
000013C8: 05100000    ;     ldreq R0, [R0]
000013CC: 124F007A    ;     adrlne R0, dead_c
000013D0: 12400C13    ; 
000013D4: 15100000    ;     ldrne R0, [R0]
000013D8:             ; 
000013D8: EF000000    ;     swi 0
000013DC:             ; 
000013DC: EA000003    ;     b drawgridcollcont
000013E0:             ; 
000013E0:             ; drawgridprintcurrent
000013E0: E24F008D    ;     adrl R0, ptr_c
000013E4: E2400C13    ; 
000013E8: E5100000    ;     ldr R0, [R0]
000013EC: EF000000    ;     swi 0
000013F0:             ; 
000013F0:             ; drawgridcollcont
000013F0: E3A00020    ;     mov R0, #' '
000013F4: EF000000    ;     swi 0
000013F8:             ; 
000013F8: E2811001    ;     add R1, R1, #1
000013FC: EAFFFFE8    ;     b drawgridcolloop
00001400:             ; 
00001400:             ; drawgridcollend
00001400: E3A01000    ;     mov R1, #0
00001404: E2822001    ;     add R2, R2, #1
00001408: E3A0000A    ;     mov R0, #10
0000140C: EF000000    ;     swi 0
00001410: EAFFFFE0    ;     b drawgridrowloop
00001414:             ; 
00001414:             ; drawgridrowlend
00001414: E3A0000A    ;     mov R0, #10
00001418: EF000000    ;     swi 0
0000141C:             ; drawgridend
0000141C: E8BD01F0    ;     pop {R4-R8}
00001420: E1A0F00E    ;     mov R15, R14
00001424:             ; 
00001424:             ; 
00001424:             ; printoptions
00001424:             ; ;;INP --
00001424:             ; ;;OUT --
00001424:             ; ;;optionsp_1-5
00001424: E28F0F6A    ;     adrl R0, optionsp_1
00001428: E2800B03    ; 
0000142C: EF000003    ;     swi 3
00001430:             ; 
00001430: E24F00E5    ;     adrl R0, width
00001434: E2400C13    ; 
00001438: E5500000    ;     ldrb R0, [R0]
0000143C: EF000004    ;     swi 4
00001440:             ; 
00001440: E28F0F69    ;     adrl R0, optionsp_2
00001444: E2800B03    ; 
00001448: EF000003    ;     swi 3
0000144C:             ; 
0000144C: E24F0B05    ;     adrl R0, height
00001450: E2400000    ; 
00001454: E5500000    ;     ldrb R0, [R0]
00001458: EF000004    ;     swi 4
0000145C:             ; 
0000145C: E28F008B    ;     adrl R0, optionsp_3
00001460: E2800C0D    ; 
00001464: EF000003    ;     swi 3
00001468:             ; 
00001468: E24F001F    ;     adrl R0, slow_b
0000146C: E2400B05    ; 
00001470: E5500000    ;     ldrb R0, [R0]
00001474: E3500001    ;     cmp R0, #1
00001478: 128F0F73    ;     adrlne R0, off_msg
0000147C: 12800B06    ; 
00001480: 028F00C1    ;     adrleq R0, on_msg
00001484: 02800C19    ; 
00001488: EF000003    ;     swi 3
0000148C:             ; 
0000148C: E28F0067    ;     adrl R0, optionsp_4
00001490: E2800C0D    ; 
00001494: EF000003    ;     swi 3
00001498:             ; 
00001498: E24F0E45    ;     adrl R0, erase_b
0000149C: E2400A01    ; 
000014A0: E5500000    ;     ldrb R0, [R0]
000014A4: E3500001    ;     cmp R0, #1
000014A8: 128F0F67    ;     adrlne R0, off_msg
000014AC: 12800B06    ; 
000014B0: 028F0091    ;     adrleq R0, on_msg
000014B4: 02800C19    ; 
000014B8: EF000003    ;     swi 3
000014BC:             ; 
000014BC: E28F0043    ;     adrl R0, optionsp_5
000014C0: E2800C0D    ; 
000014C4: EF000003    ;     swi 3
000014C8:             ; 
000014C8: E24F007E    ;     adrl R0, step_b
000014CC: E2400B05    ; 
000014D0: E5500000    ;     ldrb R0, [R0]
000014D4: E3500001    ;     cmp R0, #1
000014D8: 128F0F5B    ;     adrlne R0, off_msg
000014DC: 12800B06    ; 
000014E0: 028F0061    ;     adrleq R0, on_msg
000014E4: 02800C19    ; 
000014E8: EF000003    ;     swi 3
000014EC:             ; 
000014EC: E3A0000A    ;     ldr R0, =nl
000014F0: EF000000    ;     swi 0
000014F4:             ; 
000014F4: E1A0F00E    ;     mov R15, R14
000014F8:             ; 
000014F8:             ; setupOptions
000014F8:             ; ;;INP in R0 is 1 if should ask for dims 0 for skip
000014F8: E92D4010    ;     push {R14, R4}
000014FC: E1A04000    ;     mov R4, R0
00001500:             ; 
00001500: E28F0047    ;     adrl R0, askdefaults ;;ask q
00001504: E2800C0A    ; 
00001508: EF000003    ;     swi 3
0000150C: EF000001    ;     swi 1   ;;get character answer
00001510: EF000000    ;     swi 0
00001514: E3800020    ;     orr R0, R0, #32
00001518: E3500079    ;     cmp R0, #'y'
0000151C: E3A0000A    ;     ldr R0, =nl
00001520: EF000000    ;     swi 0
00001524:             ; 
00001524: 1A000022    ;     bne setupCustom
00001528:             ; 
00001528: E24F00D4    ;     adrl R0, erase_b_d
0000152C: E2400B05    ; 
00001530: E5500000    ;     ldrb R0, [R0]
00001534: E24F10EC    ;     adrl R1, erase_b
00001538: E2411B05    ; 
0000153C: E5410000    ;     strb R0, [R1]
00001540:             ; 
00001540: E24F00EB    ;     adrl R0, slow_b_d
00001544: E2400B05    ; 
00001548: E5500000    ;     ldrb R0, [R0]
0000154C: E24F1003    ;     adrl R1, slow_b
00001550: E2411C15    ; 
00001554: E5410000    ;     strb R0, [R1]
00001558:             ; 
00001558: E24F0002    ;     adrl R0, step_b_d
0000155C: E2400C15    ; 
00001560: E5500000    ;     ldrb R0, [R0]
00001564: E24F101A    ;     adrl R1, step_b
00001568: E2411C15    ; 
0000156C: E5410000    ;     strb R0, [R1]
00001570:             ; 
00001570: E3540000    ;     cmp R4, #0
00001574: 0A00000B    ;     beq setupOptionsDEnd
00001578:             ; 
00001578: E24F0021    ;     adrl R0, width_d
0000157C: E2400C15    ; 
00001580: E5500000    ;     ldrb R0, [R0]
00001584: E24F1039    ;     adrl R1, width
00001588: E2411C15    ; 
0000158C: E5410000    ;     strb R0, [R1]
00001590: E24F0F4E    ;     adrl R0, height_d
00001594: E2400B05    ; 
00001598: E5500000    ;     ldrb R0, [R0]
0000159C: E24F1E55    ;     adrl R1, height
000015A0: E2411A01    ; 
000015A4: E5410000    ;     strb R0, [R1]
000015A8:             ; 
000015A8:             ; setupOptionsDEnd
000015A8: EBFFFF9D    ;     bl printoptions
000015AC:             ; 
000015AC: E8BD4010    ;     pop {R14, R4}
000015B0: E1A0F00E    ;     mov R15, R14 ;;RET
000015B4:             ; 
000015B4:             ; setupCustom
000015B4:             ; ;;ask for erase, slow, step, and conditionally dims
000015B4:             ; 
000015B4:             ; ;;ask step
000015B4:             ; ;;ask erase
000015B4:             ; ;;if (!step)
000015B4:             ; ;;  if erase
000015B4:             ; ;;      print(recommend slow)
000015B4:             ; ;;  ask slow
000015B4:             ; 
000015B4: E3A01001    ;     mov R1, #1
000015B8:             ; 
000015B8: E28F00F2    ;     adrl R0, askstep
000015BC: E2800C09    ; 
000015C0: EF000003    ;     swi 3
000015C4: EF000001    ;     swi 1
000015C8: EF000000    ;     swi 0 
000015CC: E3800020    ;     orr R0, R0, #32
000015D0: E3500079    ;     cmp R0, #'y' 
000015D4: E3A0000A    ;     ldr R0, =nl
000015D8: EF000000    ;     swi 0
000015DC: 13A01000    ;     movne R1, #0
000015E0: E24F0096    ;     adrl R0, step_b
000015E4: E2400C15    ; 
000015E8: E5401000    ;     strb R1, [R0]
000015EC:             ; 
000015EC: E3A01001    ;     mov R1, #1
000015F0:             ; 
000015F0: E28F0089    ;     adrl R0, askerase
000015F4: E2800C09    ; 
000015F8: EF000003    ;     swi 3
000015FC: EF000001    ;     swi 1
00001600: EF000000    ;     swi 0
00001604: E3800020    ;     orr R0, R0, #32
00001608: E3500079    ;     cmp R0, #'y'
0000160C: E3A0000A    ;     ldr R0, =nl
00001610: EF000000    ;     swi 0
00001614: 13A01000    ;     movne R1, #0
00001618: E24F0E5D    ;     adrl R0, erase_b
0000161C: E2400A01    ; 
00001620: E5401000    ;     strb R1, [R0]
00001624:             ; 
00001624: E24F00DA    ;     adrl R0, step_b
00001628: E2400C15    ; 
0000162C: E5500000    ;     ldrb R0, [R0]
00001630: E3500001    ;     cmp R0, #1
00001634: 0A000012    ;     beq setupCustomskipslow
00001638:             ; 
00001638: E3510001    ;     cmp R1, #1 ;;if erase is on
0000163C: E28F0032    ;     adrl R0, warneraseslow
00001640: E2800C0A    ; 
00001644: 0F000003    ;     swieq 3
00001648:             ; 
00001648: E3A01001    ;     mov R1, #1
0000164C:             ;  
0000164C: E28F0046    ;     adrl R0, askslow
00001650: E2800C09    ; 
00001654: EF000003    ;     swi 3
00001658: EF000001    ;     swi 1
0000165C: EF000000    ;     swi 0
00001660: E3800020    ;     orr R0, R0, #32
00001664: E3500079    ;     cmp R0, #'y' 
00001668: E3A0000A    ;     ldr R0, =nl
0000166C: EF000000    ;     swi 0
00001670: 13A01000    ;     movne R1, #0
00001674: E24F002B    ;     adrl R0, slow_b
00001678: E2400C16    ; 
0000167C: E5401000    ;     strb R1, [R0] ;;[[maybe]] changed but not checked, go here if error
00001680:             ; 
00001680: EA000016    ;     b setupCustomDimsCheck
00001684:             ; 
00001684:             ; setupCustomskipslow
00001684: E3A00000    ;     mov R0, #0
00001688: E24F103F    ;     adrl R1, slow_b
0000168C: E2411C16    ; 
00001690: E5410000    ;     strb R0, [R1]
00001694:             ; 
00001694: EA000011    ;     b setupCustomDimsCheck
00001698:             ; 
00001698:             ; printrange
00001698:             ; ;;INP --
00001698:             ; ;;OUT --
00001698: E28F00C1    ;     adrl R0, bracket_open
0000169C: E2800C12    ; 
000016A0: EF000003    ;     swi 3
000016A4:             ; 
000016A4: E24F0057    ;     adrl R0, range_min
000016A8: E2400C16    ; 
000016AC: E5500000    ;     ldrb R0, [R0]
000016B0: EF000004    ;     swi 4
000016B4:             ; 
000016B4: E28F000F    ;     adrl R0, dash
000016B8: E2800C0A    ; 
000016BC: EF000003    ;     swi 3
000016C0:             ; 
000016C0: E24F0072    ;     adrl R0, range_max
000016C4: E2400C16    ; 
000016C8: E5500000    ;     ldrb R0, [R0]
000016CC: EF000004    ;     swi 4
000016D0:             ; 
000016D0: E28F00F5    ;     adrl R0, b_close_colon
000016D4: E2800C09    ; 
000016D8: EF000003    ;     swi 3
000016DC:             ; 
000016DC: E1A0F00E    ;     mov R15, R14
000016E0:             ; 
000016E0:             ; setupCustomDimsCheck
000016E0: E3540000    ;     cmp R4, #0
000016E4: 0A00004C    ;     beq customend
000016E8:             ; 
000016E8: E28F0F71    ;     adrl R0, askwid
000016EC: E2800B02    ; 
000016F0: EF000003    ;     swi 3
000016F4:             ; 
000016F4: EBFFFFE7    ;     bl printrange
000016F8:             ; 
000016F8:             ; getwid
000016F8: E3A0000A    ;     ldr R0, =enter
000016FC: E3A01003    ;     mov R1, #3
00001700: E3A02001    ;     mov R2, #1
00001704: EBFFFE4D    ;     bl getstring
00001708:             ; 
00001708: E3500000    ;     cmp R0, #0
0000170C: 0A00003E    ;     beq customfail
00001710:             ; 
00001710: E1A04000    ;     mov R4, R0
00001714:             ; 
00001714: EBFFFDFF    ;     bl strtoi
00001718: E1A05000    ;     mov R5, R0
0000171C:             ;     
0000171C: E1A00004    ;     mov R0, R4
00001720: EB000153    ;     bl free ;;free the collected string
00001724:             ; 
00001724: E1A01005    ;     mov R1, R5
00001728:             ; 
00001728: EBFFFD36    ;     bl newline
0000172C:             ; 
0000172C: E24F40DF    ;     adrl R4, range_min
00001730: E2444C16    ; 
00001734: E5544000    ;     ldrb R4, [R4]
00001738: E24F50EA    ;     adrl R5, range_max
0000173C: E2455C16    ; 
00001740: E5555000    ;     ldrb R5, [R5]
00001744:             ; 
00001744: E1510005    ;     cmp R1, R5
00001748: CA000005    ;     bgt getwidFail
0000174C: E1510004    ;     cmp R1, R4
00001750: BA000003    ;     blt getwidFail
00001754:             ; 
00001754: E24F0009    ;     adrl R0, width
00001758: E2400C17    ; 
0000175C: E5401000    ;     strb R1, [R0]
00001760:             ; 
00001760: EA000004    ;     b getheisetup
00001764:             ; 
00001764:             ; getwidFail
00001764: E28F0F5F    ;     adrl R0, getwidfailmsg
00001768: E2800B02    ; 
0000176C: EF000003    ;     swi 3
00001770:             ; 
00001770: EBFFFFC8    ;     bl printrange
00001774:             ; 
00001774: EAFFFFDF    ;     b getwid
00001778:             ; 
00001778:             ; getheisetup
00001778: E28F0051    ;     adrl R0, askhei
0000177C: E2800C09    ; 
00001780: EF000003    ;     swi 3
00001784:             ; 
00001784: EBFFFFC3    ;     bl printrange
00001788:             ; 
00001788:             ; gethei
00001788: E3A0000A    ;     ldr R0, =enter
0000178C: E3A01003    ;     mov R1, #3
00001790: E3A02001    ;     mov R2, #1
00001794: EBFFFE29    ;     bl getstring
00001798:             ; 
00001798: E3500000    ;     cmp R0, #0
0000179C: 0A00001A    ;     beq customfail
000017A0:             ; 
000017A0: E1A04000    ;     mov R4, R0
000017A4:             ; 
000017A4: EBFFFDDB    ;     bl strtoi
000017A8: E1A05000    ;     mov R5, R0
000017AC:             ; 
000017AC: E1A00004    ;     mov R0, R4
000017B0: EB00012F    ;     bl free
000017B4:             ; 
000017B4: E1A01005    ;     mov R1, R5
000017B8:             ; 
000017B8: EBFFFD12    ;     bl newline
000017BC:             ; 
000017BC: E24F406F    ;     adrl R4, range_min
000017C0: E2444C17    ; 
000017C4: E5544000    ;     ldrb R4, [R4]
000017C8: E24F507A    ;     adrl R5, range_max
000017CC: E2455C17    ; 
000017D0: E5555000    ;     ldrb R5, [R5]
000017D4:             ; 
000017D4: E1510005    ;     cmp R1, R5
000017D8: CA000005    ;     bgt getheiFail
000017DC: E1510004    ;     cmp R1, R4
000017E0: BA000003    ;     blt getheiFail
000017E4:             ; 
000017E4: E24F2FE6    ;     adrl R2, height
000017E8: E2422B05    ; 
000017EC: E5421000    ;     strb R1, [R2]
000017F0:             ; 
000017F0: EA000009    ;     b customend
000017F4:             ; 
000017F4:             ; getheiFail
000017F4: E28F0F46    ;     adrl R0, getheifailmsg
000017F8: E2800B02    ; 
000017FC: EF000003    ;     swi 3
00001800:             ; 
00001800: EBFFFFA4    ;     bl printrange
00001804:             ; 
00001804: EAFFFFDF    ;     b gethei
00001808:             ; 
00001808: EA000003    ;     b customend
0000180C:             ; 
0000180C:             ; customfail
0000180C: E28F0091    ;     adrl R0, malloc_panic
00001810: E2800B05    ; 
00001814: EF000003    ;     swi 3
00001818:             ; 
00001818: EA000000    ;     b customret
0000181C:             ; 
0000181C:             ; customend
0000181C: EBFFFF00    ;     bl printoptions
00001820:             ; 
00001820:             ; customret
00001820: E8BD4010    ;     pop {R14, R4}
00001824: E1A0F00E    ;     mov R15, R14 ;;RET
00001828:             ; 
00001828:             ; 
00001828:             ; updategrid
00001828:             ; ;;INP in R0 is the active grid
00001828:             ; ;;INP in R1 is the passive grid
00001828:             ; ;;passive grid is the one being updated based on the value in the activeGrid
00001828:             ; ;;RET --
00001828:             ; ;;for row from 0 to height - 1
00001828:             ; ;;  for col from 0 to width - 1
00001828:             ; ;;      int n = countNeighbours(activeGrid, row, col)
00001828:             ; ;;      int s = activeGrid[row][col]
00001828:             ; ;;      
00001828:             ; ;;      if (s == alive)
00001828:             ; ;;          passiveGrid[row][col] = n == 3 or n == 2
00001828:             ; ;;      else
00001828:             ; ;;          passiveGrid[row][col] = n == 3
00001828:             ; 
00001828:             ; ;;  R4 holds the row
00001828:             ; ;;  R5 holds the col
00001828:             ; ;;  R6 holds the width
00001828:             ; ;;  R7 holds the height
00001828:             ; ;;  R8 holds the active grid
00001828:             ; ;;  R9 holds the passive grid
00001828:             ; 
00001828: E92D47F0    ;     push {R14, R4-R10}
0000182C:             ; 
0000182C: E3500000    ;     cmp R0, #0
00001830: 0A000027    ;     beq updategridfail
00001834: E3510000    ;     cmp R1, #0
00001838: 0A000025    ;     beq updategridfail
0000183C:             ; 
0000183C: E24F60F1    ;     adrl R6, width
00001840: E2466C17    ; 
00001844: E5566000    ;     ldrb R6, [R6]
00001848: E24F7FFF    ;     adrl R7, height
0000184C: E2477B05    ; 
00001850: E5577000    ;     ldrb R7, [R7]
00001854:             ; 
00001854: E1A08000    ;     mov R8, R0
00001858: E1A09001    ;     mov R9, R1
0000185C:             ; 
0000185C: E3A04000    ;     mov R4, #0 ;;row
00001860:             ; updategridrowloop
00001860: E1540007    ;     cmp R4, R7
00001864: 0A00001D    ;     beq updategridrowlend
00001868:             ; 
00001868: E3A05000    ;     mov R5, #0 ;;col
0000186C:             ; updategridcolloop
0000186C: E1550006    ;     cmp R5, R6
00001870: 0A000014    ;     beq updategridccollend
00001874:             ; 
00001874: E1A00008    ;     mov R0, R8
00001878: E1A01004    ;     mov R1, R4
0000187C: E1A02005    ;     mov R2, R5
00001880: EB000018    ;     bl countneighbours
00001884:             ; 
00001884: E0215694    ;     mla R1, R4, R6, R5 ;;R1 = row * width + col
00001888: E7D82001    ;     ldrb R2, [R8, R1] ;;grid[R1]
0000188C:             ;     ;;R0 holds the n count
0000188C: E3520000    ;     cmp R2, #0
00001890: 0A000006    ;     beq updatedead
00001894:             ; 
00001894:             ; updatealive
00001894: E3A03000    ;     mov R3, #0
00001898: E3500003    ;     cmp R0, #3
0000189C: 03A03001    ;     moveq R3, #1
000018A0: E3500002    ;     cmp R0, #2
000018A4: 03A03001    ;     moveq R3, #1
000018A8: E7C93001    ;     strb R3, [R9, R1]
000018AC: EA000003    ;     b updatelcont
000018B0:             ; 
000018B0:             ; updatedead
000018B0: E3A03001    ;     mov R3, #1
000018B4: E3500003    ;     cmp R0, #3
000018B8: 13A03000    ;     movne R3, #0
000018BC: E7C93001    ;     strb R3, [R9, R1]
000018C0:             ; 
000018C0:             ; updatelcont
000018C0: E2855001    ;     add R5, R5, #1
000018C4: EAFFFFE8    ;     b updategridcolloop
000018C8:             ; 
000018C8:             ; updategridccollend
000018C8: E3A05000    ;     mov R5, #0
000018CC: E2844001    ;     add R4, R4, #1
000018D0: EAFFFFE2    ;     b updategridrowloop
000018D4:             ; 
000018D4:             ; updategridfail
000018D4: E28F003F    ;     adrl R0, updatergrid_m_f
000018D8: E2800C15    ; 
000018DC: EF000003    ;     swi 3
000018E0:             ; 
000018E0:             ; updategridrowlend
000018E0:             ; updategridend
000018E0: E8BD47F0    ;     pop {R14, R4-R10}
000018E4: E1A0F00E    ;     mov R15, R14
000018E8:             ; 
000018E8:             ; 
000018E8:             ; countneighbours
000018E8:             ; ;;INP in R0 is the activeGrid
000018E8:             ; ;;INP in R1 is the row
000018E8:             ; ;;INP in R2 is the col
000018E8:             ; ;;OUT in R0 is the number of neighbours
000018E8:             ; 
000018E8:             ; ;;offsets = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
000018E8:             ; ;;tot = 0
000018E8:             ; ;;for offset in offsets
000018E8:             ; ;;  if (isinrange(row + offset[0], col + offset[1]))
000018E8:             ; ;;      tot += grid[row + offset[0]][col + offset[1]]
000018E8:             ; ;;return tot
000018E8: E92D4FF0    ;     push {R14, R4-R11} ;;I used the fp before I knew it wasn't a general purpose one, its fine 
                      ; in this context anyway
000018EC:             ; 
000018EC: E24F40EC    ;     adrl R4, offsets ;;holds the offset
000018F0: E2444B06    ; 
000018F4:             ; 
000018F4: E1A07000    ;     mov R7, R0
000018F8: E1A08001    ;     mov R8, R1
000018FC: E1A09002    ;     mov R9, R2
00001900: E3A0A000    ;     mov R10, #0 ;;R10 holds the total
00001904: E24FB0B9    ;     adrl R11, width
00001908: E24BBB06    ; 
0000190C: E55BB000    ;     ldrb R11, [R11];;R11 holds the width of the grid
00001910:             ; 
00001910: E3A03000    ;     mov R3, #0
00001914:             ; 
00001914:             ; countneighboursloop
00001914: E3530008    ;     cmp R3, #8 ;;change this ccheck to be for R4
00001918: 0A00000F    ;     beq countneighbourslend
0000191C:             ; 
0000191C: E4945004    ;     ldr R5, [R4], #4
00001920: E4946004    ;     ldr R6, [R4], #4
00001924:             ; 
00001924: E0880005    ;     add R0, R8, R5
00001928: E0891006    ;     add R1, R9, R6
0000192C:             ; 
0000192C: E2833001    ;     add R3, R3, #1
00001930:             ; 
00001930: E92D0008    ;     push {R3} ;;I should probably be using a local var on the stack, but I don't yet know how t
                      ; o setup a stack frame properly
00001934: EB00000B    ;     bl isinrange
00001938: E8BD0008    ;     pop {R3}
0000193C:             ; 
0000193C: E3500000    ;     cmp R0, #0
00001940: 0A000004    ;     beq countneighboursskipadd
00001944:             ; 
00001944: E0880005    ;     add R0, R8, R5 ;;new row
00001948: E0891006    ;     add R1, R9, R6 ;;new col ;;can assume that R0, R1 haven't changed as isinrange doesn't edit
                      ;  them, but I'm going to for now
0000194C:             ; 
0000194C: E0201B90    ;     mla R0, R0, R11, R1 ;;find offset
00001950: E7D70000    ;     ldrb R0, [R7, R0]
00001954: E08AA000    ;     add R10, R10, R0 ;;tot += grid[newrow][newcol]
00001958:             ; 
00001958:             ; countneighboursskipadd
00001958: EAFFFFED    ;     b countneighboursloop
0000195C:             ; 
0000195C:             ; countneighbourslend
0000195C:             ; countneighboursend
0000195C: E1A0000A    ;     mov R0, R10
00001960: E8BD4FF0    ;     pop {R14, R4-R11}
00001964: E1A0F00E    ;     mov R15, R14
00001968:             ; 
00001968:             ; 
00001968:             ; isinrange
00001968:             ; ;;INP in R0 is the row
00001968:             ; ;;INP in R1 is the col
00001968:             ; ;;Uses defined width and height
00001968:             ; ;;RET in R0 is 1 if is in range else 0
00001968: E3A02001    ;     mov R2, #1 ;;is valid unless...
0000196C:             ; 
0000196C: E3500000    ;     cmp R0, #0
00001970: BA00000D    ;     blt isinrangefail
00001974:             ; 
00001974: E3510000    ;     cmp R1, #0
00001978: BA00000B    ;     blt isinrangefail
0000197C:             ; 
0000197C: E24F3031    ;     adrl R3, width
00001980: E2433C19    ; 
00001984: E5533000    ;     ldrb R3, [R3]
00001988: E1510003    ;     cmp R1, R3
0000198C: AA000006    ;     bge isinrangefail
00001990:             ; 
00001990: E24F3F51    ;     adrl R3, height
00001994: E2433B06    ; 
00001998: E5533000    ;     ldrb R3, [R3]
0000199C: E1500003    ;     cmp R0, R3
000019A0: AA000001    ;     bge isinrangefail
000019A4:             ; 
000019A4: E3A00001    ;     mov R0, #1
000019A8: EA000000    ;     b isinrangeend
000019AC:             ; 
000019AC:             ; isinrangefail
000019AC: E3A00000    ;     mov R0, #0
000019B0:             ; 
000019B0:             ; isinrangeend
000019B0: E1A0F00E    ;     mov R15, R14
000019B4:             ; 
000019B4:             ; 
000019B4:             ; ;; The heap will be a linked list of free blocks - unlike the Comodo version which stores both 
                      ; free & taken blocks 
000019B4:             ; ;; This is an idea I'm stealing from the C programming book
000019B4:             ; ;; Crate structure
000019B4:             ; ;;  |-ptr to next crate (1 word)
000019B4:             ; ;;  |-ptr to prev crate (1 word)
000019B4:             ; ;;  `-Size (bytes)      (1 word)
000019B4:             ; ;; 
000019B4:             ; 
000019B4:             ; ;;  Traversal of the heap
000019B4:             ; ;;  Unlink in my Comodo implimentation the heap is not a linked list of all Crates (free or not
                      ; )
000019B4:             ; ;;  That made traversing the heap for debugging purposes very easy, in this case taken crates d
                      ; o not point to the next
000019B4:             ; ;;  Instead could start at head and then just go to addr + sizeof(Crate) + size. This should ta
                      ; ke us to the next crate, free or not
000019B4:             ; ;;  
000019B4:             ; setupHeap
000019B4:             ; ;;NO INP
000019B4:             ; ;;NO OUT
000019B4:             ;     ;;we have the heapstart
000019B4:             ;     ;;the end of the heap will be 0x100000 (it will overlap with the stack :) )
000019B4: E24F0F6E    ;     adrl R0, heaphead
000019B8: E2400B06    ; 
000019BC: E5100000    ;     ldr R0, [R0] ;;stores the mem addr of the start of the heap
000019C0: E3A01601    ;     ldr R1, =max_addr ;;stores the end of the heap
000019C4: E3A02801    ;     ldr R2, =stack_size
000019C8: E0411002    ;     sub R1, R1, R2
000019CC:             ; 
000019CC: E0411000    ;     sub R1, R1, R0  ;;HEAPEND - HEAPSTART = TOTAL STORAGE (bytes)
000019D0: E241100C    ;     sub R1, R1, #12 ;;SIZE -= SIZEOF(CRATE) (12 bytes)
000019D4: E5801008    ;     str R1, [R0, #8] ;;set the size of the crate
000019D8: E3A01000    ;     mov R1, #0
000019DC: E5801004    ;     str R1, [R0, #4] ;;set the prev ptr
000019E0: E5801000    ;     str R1, [R0, #0] ;;set the next ptr
000019E4:             ; 
000019E4: E1A0F00E    ;     mov R15, R14
000019E8:             ; 
000019E8:             ; ;; The heap is a linked list of free Crates and so find the header and then go though until one
                      ;  satifies the size requirement
000019E8:             ; ;;  end if next is 0
000019E8:             ; ;;  once found either take over the crate or split it into two new crates
000019E8:             ; ;;  align the bytes amount to 8 byte boundry
000019E8:             ; malloc
000019E8:             ; ;;INP into R0 bytes to allocate
000019E8:             ; ;;OUT into R0 the ptr to the memory or 0 for no memory allocated
000019E8:             ;     ;;step 1 align the bytes
000019E8:             ;     ;;1001010 & 0111 = 0000010 ;2
000019E8:             ;     ;;if 0 goto alignend
000019E8:             ;     ;;1001010 + (8 - 2)
000019E8:             ; 
000019E8:             ; ;;[[NEW]] In order to reduce heap fragmentation I'm going to find the 'best' free crate
000019E8:             ; ;;bestCrateAddr = 0
000019E8:             ; ;;bestCrateSize = INT_MAX
000019E8:             ; ;;currentCrate = heapstart
000019E8:             ; ;;While (currentCrate != 0)
000019E8:             ; ;;  if (currentCrate.size >= requestedSize && bestCrateSize > currentCrate.size)
000019E8:             ; ;;      bestCrateSize = currentCrate.size
000019E8:             ; ;;      bestCrateAddr = currentCrate.addr
000019E8:             ; ;;  currentCrate = currentCrate.next
000019E8:             ; 
000019E8: E92D01F0    ;     push {R4-R8}
000019EC:             ; 
000019EC: E2001007    ;     and R1, R0, #0b0111
000019F0: E3510000    ;     cmp R1, #0
000019F4: 0A000002    ;     beq mallignend
000019F8: E3A03008    ;     mov R3, #0b1000
000019FC: E0432001    ;     sub R2, R3, R1
00001A00: E0800002    ;     add R0, R0, R2
00001A04:             ; 
00001A04:             ; mallignend
00001A04: E24F1F82    ;     adrl R1, heaphead
00001A08: E2411B06    ; 
00001A0C: E5111000    ;     ldr R1, [R1] ;;stores a ptr to the first block
00001A10:             ; 
00001A10: E3A05000    ;     mov R5, #0 ;;bestCrateAddr
00001A14: E3E06000    ;     mov R6, #-1 ;;bestCrateSize
00001A18:             ;     
00001A18:             ; checkcrate
00001A18: E5912008    ;     ldr R2, [R1, #8] ;;Size of the crate
00001A1C: E1520000    ;     cmp R2, R0 ;;bytes in crate - bytes needed
00001A20:             ; 
00001A20: 3A000003    ;     blo nextcrate
00001A24:             ; 
00001A24: E1560002    ;     cmp R6, R2 ;;bestCrateSize - currentCrate.size
00001A28: 3A000001    ;     blo nextcrate
00001A2C:             ; 
00001A2C: E1A06002    ;     mov R6, R2
00001A30: E1A05001    ;     mov R5, R1
00001A34:             ; 
00001A34:             ; nextcrate
00001A34: E5912000    ;     ldr R2, [R1, #0] ;;get the next ptr
00001A38: E3520000    ;     cmp R2, #0
00001A3C: 0A000001    ;     beq cratelend
00001A40: E1A01002    ;     mov R1, R2 ;;swap the current crate with the next crate
00001A44: EAFFFFF3    ;     b checkcrate
00001A48:             ; 
00001A48:             ; cratelend
00001A48: E3550000    ;     cmp R5, #0
00001A4C: 0A000001    ;     beq nocrates
00001A50:             ; 
00001A50: E1A01005    ;     mov R1, R5 ;;for legacy reasons it should be in R1 
00001A54:             ; 
00001A54: EA000001    ;     b foundcrate
00001A58:             ; 
00001A58:             ; nocrates
00001A58: E3A00000    ;     mov R0, #0
00001A5C: EA000019    ;     b mallocEnd
00001A60:             ; 
00001A60:             ; foundcrate
00001A60:             ;     ;;Once a crate that we can use has been found we need to either split the crate or use the 
                      ; crate
00001A60:             ;         ;;We should use the whole crate only when its size < bytesneeded + CrateHeader + 8
00001A60:             ;     ;;This would give the edge case crate 8 bytes [[flag]]
00001A60:             ;     
00001A60:             ;     ;;R1 holds the found crate ptr
00001A60:             ;     ;;R0 is the bytes requested and aligned
00001A60: E2802014    ;     add R2, R0, #20 ;;A crate header is 12 bytes + the extra 8 bytes minimum
00001A64: E5913008    ;     ldr R3, [R1, #8]
00001A68: E1530002    ;     cmp R3, R2
00001A6C: BA00000C    ;     blt usecrate
00001A70:             ; splitcrate
00001A70:             ;     ;;In this case we have a large crate that should be split up.
00001A70:             ;     ;;ATM the crate will just be split up to where the requested memory is at the end of the fr
                      ; ee Crate.
00001A70:             ; 
00001A70: E5913008    ;     ldr R3, [R1, #8] ;;The size of the toSplit Crate
00001A74: E0433000    ;     sub R3, R3, R0 ;; size - bytesRequested
00001A78: E243300C    ;     sub R3, R3, #12 ;; size - bytesRequested - sizeof(Crate)
00001A7C: E5813008    ;     str R3, [R1, #8] ;;toSplit->size = newSize
00001A80:             ; 
00001A80: E0833001    ;     add R3, R3, R1 ;; newSize + toSplit.addr
00001A84: E283400C    ;     add R4, R3, #12 ;; newSize + toSplit.addr + sizeof(Crate) = position of new Crate
00001A88:             ; 
00001A88:             ;     ;;Setup the header for the newCrate
00001A88: E3A02000    ;     mov R2, #0
00001A8C: E5842000    ;     str R2, [R4, #0] ;;next = 0
00001A90: E5842004    ;     str R2, [R4, #4] ;;prev = 0
00001A94: E5840008    ;     str R0, [R4, #8] ;;size = requested and aligned
00001A98:             ; 
00001A98:             ;     ;;MAYBE: can the crates that are taken have a smaller header than those that are free. Take
                      ; n crates need not store the next, prev free nodes
00001A98:             ;     ;;This may complicate things as size would need to be moved around and the size from taken 
                      ; to free would be different. 
00001A98:             ;     ;;This would have been easier if the size of the Crate was stored at the start but it's not
                      ; , I'm probably not going to add this its not worth it.
00001A98:             ; 
00001A98: E284400C    ;     add R4, R4, #12
00001A9C:             ; 
00001A9C: E1A00004    ;     mov R0, R4
00001AA0:             ; 
00001AA0: EA000008    ;     b mallocEnd
00001AA4:             ; 
00001AA4:             ; usecrate
00001AA4:             ;     ;; Simplest option as we can just remove it from the list
00001AA4:             ;     ;; c1 <-> c2 <-> c3 ==> c1 <-> c3
00001AA4: E5912000    ;     ldr R2, [R1, #0] ;;next ptr
00001AA8: E5913004    ;     ldr R3, [R1, #4] ;;prev ptr
00001AAC: E5823004    ;     str R3, [R2, #4] ;;Store c1 into c3's previous
00001AB0: E5832000    ;     str R2, [R3, #0] ;;Store c3 into c1's next
00001AB4:             ; 
00001AB4: E3A00000    ;     mov R0, #0
00001AB8: E5810000    ;     str R0, [R1, #0] ;;clear next
00001ABC: E5810004    ;     str R0, [R1, #4] ;;clear prev (for debugging uses)
00001AC0:             ; 
00001AC0: E1A00001    ;     mov R0, R1 ;;move the found crate's address into the return register
00001AC4: E280000C    ;     add R0, R0, #12
00001AC8:             ; 
00001AC8:             ; mallocEnd
00001AC8: E8BD01F0    ;     pop {R4-R8}
00001ACC: E1A0F00E    ;     mov R15, R14
00001AD0:             ; 
00001AD0:             ; 
00001AD0:             ; printHeap
00001AD0:             ; ;;This is a debugging function that will print the free and taken list
00001AD0:             ; ;;,-----------------------------------------------------------------,
00001AD0:             ; ;;|   large free block  |tkn1   |tkn2       | freed1    | tkn3      |
00001AD0:             ; ;;|                     |       |           |           |           |
00001AD0:             ; ;;|                     |       |           |           |           |
00001AD0:             ; ;;`-----------------------------------------------------------------'
00001AD0:             ; 
00001AD0:             ; ;;  PrintFree() - follow the free list ptrs print addr + size
00001AD0:             ; ;;  PrintAll()  - start at head and go addr + size + 12 to get next, continue to end
00001AD0: E92D47F0    ;     push {R14, R4-R10}
00001AD4:             ; 
00001AD4: EB000025    ;     bl printFree
00001AD8:             ; 
00001AD8: EB000001    ;     bl printAll
00001ADC:             ; 
00001ADC:             ; printHeapend
00001ADC: E8BD47F0    ;     pop {R14, R4-R10}
00001AE0: E1A0F00E    ;     mov R15, R14
00001AE4:             ; 
00001AE4:             ; printAll
00001AE4: E92D41F0    ;     push {R14, R4-R8}
00001AE8:             ; 
00001AE8: E28F00EA    ;     adrl R0, printAll_m
00001AEC: E2800A01    ; 
00001AF0: EF000003    ;     swi 3
00001AF4:             ;     
00001AF4: E28F0FD6    ;     adrl R0, heapstart
00001AF8: E2800A01    ; 
00001AFC: E1A04000    ;     mov R4, R0
00001B00:             ; 
00001B00: E1A05000    ;     mov R5, R0 ;;stores the next expected free node
00001B04:             ; 
00001B04:             ; printAllLoop
00001B04: E5941000    ;     ldr R1, [R4, #0] ;;next ptr
00001B08: E5942004    ;     ldr R2, [R4, #4] ;;prev ptr
00001B0C: E5943008    ;     ldr R3, [R4, #8] ;;size
00001B10:             ; 
00001B10: E1540001    ;     cmp R4, R1
00001B14: 1A000003    ;     bne printAllLoopSkipWarning
00001B18:             ; 
00001B18: E28F000A    ;     adrl R0, printAll_m_e
00001B1C: E2800C11    ; 
00001B20: EF000003    ;     swi 3
00001B24:             ; 
00001B24: E3A05000    ;     mov R5, #0
00001B28:             ; 
00001B28:             ; printAllLoopSkipWarning
00001B28:             ; 
00001B28:             ;     ;;check if this is a free node
00001B28: E1550004    ;     cmp R5, R4
00001B2C:             ; 
00001B2C: 028F00C9    ;     adrleq R0, printAll_m_f
00001B30: 02800A01    ; 
00001B34: 128F00D7    ;     adrlne R0, printAll_m_t
00001B38: 12800A01    ; 
00001B3C: EF000003    ;     swi 3
00001B40:             ; 
00001B40: 1A000000    ;     bne printAllLoopCont
00001B44:             ; 
00001B44: E1A05001    ;     mov R5, R1
00001B48:             ; 
00001B48:             ; printAllLoopCont
00001B48: E1A00004    ;     mov R0, R4
00001B4C: EB000022    ;     bl printblock
00001B50:             ; 
00001B50:             ;     ;;calculate the next block
00001B50:             ;     ;;addr + 12 + size
00001B50:             ; 
00001B50: E284000C    ;     add R0, R4, #12
00001B54: E0800003    ;     add R0, R0, R3
00001B58:             ; 
00001B58: E1A04000    ;     mov R4, R0
00001B5C:             ; 
00001B5C: E354080F    ;     cmp R4, #0xF0000
00001B60: AA000000    ;     bge printAllLend
00001B64:             ;     
00001B64: EAFFFFE6    ;     b printAllLoop
00001B68:             ; 
00001B68:             ; printAllLend
00001B68:             ; printAllEnd
00001B68: E8BD41F0    ;     pop {R14, R4-R8}
00001B6C: E1A0F00E    ;     mov R15, R14
00001B70:             ; 
00001B70:             ; printFree
00001B70: E92D41F0    ;     push {R14, R4-R8}
00001B74:             ; 
00001B74: E28F0EFD    ;     adrl R0, printFree_m
00001B78: E2800000    ; 
00001B7C: EF000003    ;     swi 3
00001B80:             ; 
00001B80: E28F0FB3    ;     adrl R0, heapstart
00001B84: E2800A01    ; 
00001B88: E1A04000    ;     mov R4, R0
00001B8C:             ; 
00001B8C:             ; printFreeloop
00001B8C: E5941000    ;     ldr R1, [R4, #0] ;;next ptr
00001B90: E5942004    ;     ldr R2, [R4, #4] ;;prev ptr
00001B94: E5943008    ;     ldr R3, [R4, #8] ;;size
00001B98:             ; 
00001B98: E28F00BF    ;     adrl R0, printfree_f_m
00001B9C: E2800C0F    ; 
00001BA0: EF000003    ;     swi 3
00001BA4:             ; 
00001BA4: E1A00004    ;     mov R0, R4
00001BA8: EB00000B    ;     bl printblock
00001BAC:             ; 
00001BAC: E3510000    ;     cmp R1, #0
00001BB0: 0A000003    ;     beq printFreelend
00001BB4:             ; 
00001BB4: E1510004    ;     cmp R1, R4
00001BB8: 0A000002    ;     beq printFreeErr
00001BBC:             ; 
00001BBC: E1A04001    ;     mov R4, R1
00001BC0: EAFFFFF1    ;     b printFreeloop
00001BC4:             ; 
00001BC4:             ; printFreelend
00001BC4: EA000002    ;     b printFreeEnd
00001BC8:             ; 
00001BC8:             ; printFreeErr
00001BC8: E28F00CE    ;     adrl R0, printFree_m_e
00001BCC: E2800C0F    ; 
00001BD0: EF000003    ;     swi 3
00001BD4:             ; 
00001BD4:             ; printFreeEnd
00001BD4: E8BD41F0    ;     pop {R14, R4-R8}
00001BD8: E1A0F00E    ;     mov R15, R14
00001BDC:             ; 
00001BDC:             ; printblock
00001BDC:             ; ;;INP in R0 is the addr
00001BDC:             ; ;;INP in R1 is the next
00001BDC:             ; ;;INP in R2 is the prev
00001BDC:             ; ;;INP in R3 is the size
00001BDC:             ; ;;RET --
00001BDC: E92D0010    ;     push {R4}
00001BE0: E1A04000    ;     mov R4, R0
00001BE4:             ; 
00001BE4: E28F0032    ;     adrl R0, cutoff
00001BE8: E2800C0A    ; 
00001BEC: EF000003    ;     swi 3
00001BF0:             ; 
00001BF0: E28F007E    ;     adrl R0, printfree_f_mad
00001BF4: E2800C0F    ; 
00001BF8: EF000003    ;     swi 3
00001BFC:             ; 
00001BFC: E1A00004    ;     mov R0, R4
00001C00: EF000004    ;     swi 4
00001C04:             ; 
00001C04: E3A0000A    ;     ldr R0, =nl
00001C08: EF000000    ;     swi 0
00001C0C:             ; 
00001C0C: E28F0FDB    ;     adrl R0, printfree_f_mnx
00001C10: E2800B03    ; 
00001C14: EF000003    ;     swi 3
00001C18:             ; 
00001C18: E1A00001    ;     mov R0, R1
00001C1C: EF000004    ;     swi 4
00001C20:             ; 
00001C20: E3A0000A    ;     ldr R0, =nl
00001C24: EF000000    ;     swi 0
00001C28:             ; 
00001C28: E28F005A    ;     adrl R0, printfree_f_mpr
00001C2C: E2800C0F    ; 
00001C30: EF000003    ;     swi 3
00001C34:             ; 
00001C34: E1A00002    ;     mov R0, R2
00001C38: EF000004    ;     swi 4
00001C3C:             ; 
00001C3C: E3A0000A    ;     ldr R0, =nl
00001C40: EF000000    ;     swi 0
00001C44:             ; 
00001C44: E28F0FD2    ;     adrl R0, printfree_f_msz
00001C48: E2800B03    ; 
00001C4C: EF000003    ;     swi 3
00001C50:             ; 
00001C50: E1A00003    ;     mov R0, R3
00001C54: EF000004    ;     swi 4
00001C58:             ; 
00001C58: E3A0000A    ;     ldr R0, =nl
00001C5C: EF000000    ;     swi 0
00001C60:             ; 
00001C60: E28F00B6    ;     adrl R0, cutoff
00001C64: E2800C09    ; 
00001C68: EF000003    ;     swi 3
00001C6C:             ; 
00001C6C: E8BD0010    ;     pop {R4}
00001C70: E1A0F00E    ;     mov R15, R14
00001C74:             ; 
00001C74:             ; 
00001C74:             ; free
00001C74:             ; ;;INP in R0 is the mem addr of the data to be freed
00001C74:             ; ;;OUT in R0 is the success code - 0 for mem freed, ¬0 for error ;;probably won't be currently 
                      ; used `=(- -)=' 
00001C74:             ;     ;;In order to free memory we need to add it back to the linked list
00001C74:             ;     ;;Following K&R's version the linked list will be ordered by address this will make finding
                      ;  consecutive memory locations that should be combined easier
00001C74:             ; 
00001C74:             ;     ;;The inputted address of the crate is the address given in malloc and so the start of the 
                      ; crate is that addr - sizeof(Crate) (#12)
00001C74:             ; 
00001C74:             ;     ;;heapHead = first Crate
00001C74:             ;     ;;current = heapHead
00001C74:             ;     ;;while (toFree.addr > current.addr)
00001C74:             ;     ;;  current = current.next
00001C74:             ;     ;;
00001C74:             ;     ;;//Add the toFree Crate inbetween the current and its previous i.e.  A<->B<->C, toFree = D
                      ;  (addr < C, addr > B) ==> A<->B<->D<->C
00001C74:             ;     ;;current->prev->next = toFree
00001C74:             ;     ;;toFree->prev = current.prev
00001C74:             ;     ;;current->prev = toFree
00001C74:             ;     ;;toFree->next = current
00001C74:             ; 
00001C74:             ;     ;; Crate structure
00001C74:             ;     ;;  |-ptr to next crate (1 word)
00001C74:             ;     ;;  |-ptr to prev crate (1 word)
00001C74:             ;     ;;  `-Size (bytes)      (1 word)
00001C74:             ; 
00001C74: E92D41F0    ;     push {R14, R4-R8}
00001C78:             ; 
00001C78: E3500000    ;     cmp R0, #0
00001C7C: 0A000030    ;     beq freeEndZero
00001C80:             ; 
00001C80: E24F1084    ;     adrl R1, heaphead
00001C84: E2411B07    ; 
00001C88: E5111000    ;     ldr R1, [R1] ;;R1 will hold the current
00001C8C: E240000C    ;     sub R0, R0, #12 ;;subtract sizeof(Crate) to get header pointer
00001C90:             ; freeloop
00001C90: E5912000    ;     ldr R2, [R1, #0] ;;load the ptr to the next
00001C94: E1520000    ;     cmp R2, R0 ;;compare the address of the toFree to the address of current->next
00001C98:             ; 
00001C98: AA000003    ;     bge freelend ;;current->next.addr >= toFree.addr
00001C9C:             ; 
00001C9C: E3520000    ;     cmp R2, #0 ;;If there are no more Crates to the right then this could be a new Crate at the
                      ;  end or |F|T| it should merge left 
00001CA0: 0A000009    ;     beq freelendEnd
00001CA4:             ; 
00001CA4: E1A01002    ;     mov R1, R2 ;;current = current.next
00001CA8:             ; 
00001CA8: EAFFFFF8    ;     b freeloop
00001CAC:             ; 
00001CAC:             ; freelend
00001CAC:             ;     ;; R1 holds the current (left)
00001CAC:             ;     ;; R2 holds the c->next (right)
00001CAC: E5912000    ;     ldr R2, [R1, #0]
00001CB0:             ; 
00001CB0:             ;     ;;Setup the ptrs for the crates this will help later on   left<->toFree<->right ;;left,righ
                      ; t can be 0
00001CB0:             ;     ;;We're just adding the new crate to the linked list
00001CB0:             ;     ;;current->next->prev = toFree
00001CB0:             ;     ;;toFree->next = current->next
00001CB0:             ;     ;;current->next = toFree
00001CB0:             ;     ;;toFree->prev = current
00001CB0:             ; 
00001CB0: E5913000    ;     ldr R3, [R1, #0] ;;holds current->next
00001CB4: E3530000    ;     cmp R3, #0
00001CB8: 15830004    ;     strne R0, [R3, #4] ;;current->next->prev = toFree
00001CBC: E5803000    ;     str R3, [R0, #0] ;;toFree->next = current->next
00001CC0: E5810000    ;     str R0, [R1, #0] ;;current->next = toFree
00001CC4: E5801004    ;     str R1, [R0, #4] ;;toFree->prev = current
00001CC8:             ; 
00001CC8: EA000001    ;     b freeMergeCheck
00001CCC:             ; 
00001CCC:             ; freelendEnd
00001CCC:             ; ;;If there are no more Crates to the right then this could be a new Crate at the end or |F|T| i
                      ; t should merge left 
00001CCC:             ; ;;Found a crate (current) that is to the left of the crate as we ran out of ->next ptrs
00001CCC:             ; ;;Need to set current->next = toFree
00001CCC:             ; ;;            toFree->prev = current
00001CCC: E5801004    ;     str R1, [R0, #4] ;;toFree->prev = current
00001CD0: E5810000    ;     str R0, [R1, #0] ;;current->next = toFree
00001CD4:             ; 
00001CD4:             ; freeMergeCheck
00001CD4:             ;     ;;We have a ptr to current. This should be the closest Crate to the left of toFree
00001CD4:             ;     ;;We also have the next Crate (null or not) which is to the right of toFree
00001CD4:             ;     ;;Both of these crates MAY need to be merged but could also have taken crates in between
00001CD4:             ;     ;;First is to check if the crates are adjacent
00001CD4:             ;     ;;  If they are NOT then create a newCrate
00001CD4:             ;     ;;  If they are     then merge both
00001CD4:             ;     ;;  If only one     then merge either left or right
00001CD4:             ; 
00001CD4:             ;     ;;R1 will be left
00001CD4:             ;     ;;R2 will be right
00001CD4:             ; 
00001CD4: E3510000    ;     cmp R1, #0
00001CD8: 01A01000    ;     moveq R1, R0 ;;If there is no left crate then left=toFree
00001CDC: E3520000    ;     cmp R2, #0
00001CE0: 01A02000    ;     moveq R2, R0 ;;If there is no right crate (more likely) then right=toFree
00001CE4:             ; 
00001CE4:             ; verifyLeft
00001CE4:             ;     ;;Check if the left is adjacent
00001CE4:             ;     ;;It will be if (left.addr + sizeof(Crate) + left.size == toFree.addr)
00001CE4:             ; 
00001CE4: E5913008    ;     ldr R3, [R1, #8]
00001CE8: E283300C    ;     add R3, R3, #12 ;;12 is sizeof(Crate) + toFree.size
00001CEC: E0833001    ;     add R3, R3, R1 ;;left.addr + left->size ??
00001CF0:             ; 
00001CF0: E1530000    ;     cmp R3, R0
00001CF4: 11A01000    ;     movne R1, R0
00001CF8:             ; 
00001CF8:             ; verifyRight
00001CF8:             ;     ;;Going from toFree to Right
00001CF8: E5903008    ;     ldr R3, [R0, #8] ;;get size of toFree
00001CFC: E283300C    ;     add R3, R3, #12 ;;12 is sizeof(Crate) + toFree.size
00001D00: E0833000    ;     add R3, R3, R0 ;; + toFree.addr
00001D04:             ; 
00001D04: E1530002    ;     cmp R3, R2
00001D08: 11A02000    ;     movne R2, R0
00001D0C:             ; 
00001D0C:             ; merge
00001D0C:             ;     ;;Merge the two Crates given in R1 and R2
00001D0C:             ;     ;;left can be (left) or (toFree)
00001D0C:             ;     ;;right can be (right) or (toFree)
00001D0C:             ;     ;;If left == right: don't merge; create new Crate
00001D0C:             ;     ;;If left != right: then add to left's size
00001D0C:             ; 
00001D0C: E1510002    ;     cmp R1, R2
00001D10: 0A00000A    ;     beq mergeNew
00001D14:             ; 
00001D14:             ;     ;;The new size is right.addr - left.addr + right->size    from right.addr - left.addr - siz
                      ; eof(Crate) + sizeof(Crate) + right->size
00001D14:             ;     ;;                                                               |left      |right
00001D14:             ;     ;;                                                               |<12>|size||<12>|size|
00001D14:             ;     ;;
00001D14:             ;     ;;                                                               |left      
00001D14:             ;     ;;                                                               |<12>|size           |
00001D14:             ;     ;;
00001D14:             ;     ;;I'm doing it this way as the left and right may not be contiguous i.e. if toFree has a fr
                      ; ee crate on either side
00001D14:             ; 
00001D14: E0423001    ;     sub R3, R2, R1
00001D18: E5924008    ;     ldr R4, [R2, #8]
00001D1C: E0833004    ;     add R3, R3, R4
00001D20: E5813008    ;     str R3, [R1, #8]
00001D24:             ; 
00001D24:             ;     ;;Time to switch some ptrs
00001D24:             ;     ;;Current state left.prev<->left<->right<->right.next (with left or right = toFree) or left
                      ; .prev<->left<->toFree<->right<->right.next
00001D24:             ;     ;;New state would be left.prev<->left<->right.next (with left or right = toFree) or left.pr
                      ; ev<->left<->right.next
00001D24:             ;     ;;Both cases end the same, so get right.next. These could be 0 but it doesn't matter
00001D24:             ;     ;;Next need to change the prev and next ptrs for adjacent Crates
00001D24:             ;     ;;i.e. right->next->prev = left
00001D24:             ; 
00001D24: E5924000    ;     ldr R4, [R2, #0] ;;right->next
00001D28: E1540001    ;     cmp R4, R1      ;;If right->next == current {left->next = 0} else {left->next = right->next
                      ; }
00001D2C: 15814000    ;     strne R4, [R1, #0] ;;left->next = right->next
00001D30: 03A04000    ;     moveq R4, #0       ;;This shouldn't ever be true? how could rnext point to left? left<->mid
                      ; ?<->right<->rnext
00001D34: 05814000    ;     streq R4, [R1, #0] ;;left->next = 0
00001D38:             ; 
00001D38: E3540000    ;     cmp R4, #0
00001D3C: 15841004    ;     strne R1, [R4, #4] ;;right->next->prev = left
00001D40:             ; 
00001D40:             ; mergeNew
00001D40:             ;     ;;The crate has already been setup with its ptrs and had its size as well so don't need to 
                      ; do anything
00001D40: EA000002    ;     b freeEnd
00001D44:             ; 
00001D44:             ; freeEndZero
00001D44: E28F00A7    ;     adrl R0, free_m_zero
00001D48: E2800A01    ; 
00001D4C: EF000003    ;     swi 3
00001D50:             ; 
00001D50:             ; freeEnd
00001D50: E8BD41F0    ;     pop {R14, R4-R8}
00001D54: E1A0F00E    ;     mov R15, R14
00001D58:             ; 
00001D58:             ; memset
00001D58:             ; ;;INP in R0 is startAddr.
00001D58:             ; ;;INP in R1 is endAddr.
00001D58:             ; ;;INP in R2 is the BYTE value to write
00001D58:             ; ;;endAddr. is NOT inclusive i.e. the value at endAddr. will not be overwritten
00001D58:             ; 
00001D58: E92D41F0    ;     push {R14, R4-R8}
00001D5C:             ; 
00001D5C: E1A04000    ;     mov R4, R0
00001D60: E1A05001    ;     mov R5, R1
00001D64: E1A06002    ;     mov R6, R2
00001D68:             ; 
00001D68:             ; ;;align to 4 bytes by writing bytes
00001D68:             ; ;;write as many 4 bytes as possible
00001D68:             ; ;;write remaining bytes
00001D68:             ; ;;
00001D68:             ; ;;To get word to write
00001D68:             ; ;;x = x << 8 orr x
00001D68:             ; ;;x = x << 16 orr x
00001D68: E0457004    ;     sub R7, R5, R4 ;;find the number of bytes to write
00001D6C: E3570010    ;     cmp R7, #16
00001D70: 9A00001F    ;     bls memsetjustwritebytes ;;if we only need to write 16 bytes or less then don't worry about
                      ;  any of this stuff
00001D74:             ; 
00001D74: E3A01003    ;     mov R1, #0b11  ;;e.g. addr: 1000    1011    1010    1001
00001D78: E0200001    ;     eor R0, R0, R1 ;;      eor  0011    0011    0011    0011
00001D7C:             ;                    ;;           1011    1000    1001    1010
00001D7C: E2800001    ;     add R0, R0, #1 ;;           1100    1001    1010    1011
00001D80: E0002001    ;     and R2, R0, R1 ;;           0000    0001    0010    0011
00001D84:             ;     ;; R2 should be the number of bytes to write to align
00001D84:             ; 
00001D84: E3A00000    ;     mov R0, #0
00001D88:             ; memsetalignloop
00001D88: E1500002    ;     cmp R0, R2
00001D8C: 0A000002    ;     beq memsetalignlend
00001D90:             ; 
00001D90: E7C46000    ;     strb R6, [R4, R0]
00001D94: E2800001    ;     add R0, R0, #1
00001D98: EAFFFFFA    ;     b memsetalignloop
00001D9C:             ; 
00001D9C:             ; memsetalignlend
00001D9C: E0844000    ;     add R4, R4, R0 ;;inc the start address to the aligned boundry
00001DA0: E0477000    ;     sub R7, R7, R0 ;;sub from bytes 2 write the amount we've written
00001DA4:             ;     ;;find the number of words to write
00001DA4:             ; 
00001DA4: E3C73003    ;     and R3, R7, #-4 ;;remove last 2 bytes this is the number of words to write (Its still a byt
                      ; e count)
00001DA8:             ; 
00001DA8:             ;     ;;x = x << 8 orr x
00001DA8:             ;     ;;x = x << 16 orr x
00001DA8:             ; 
00001DA8: E1A01406    ;     mov R1, R6, lsl #8
00001DAC: E1811006    ;     orr R1, R1, R6
00001DB0:             ; 
00001DB0: E1A02801    ;     mov R2, R1, lsl #16
00001DB4: E1822001    ;     orr R2, R2, R1
00001DB8:             ; 
00001DB8: E3A00000    ;     mov R0, #0 ;;count
00001DBC:             ; memsetwritewordsloop
00001DBC: E1500003    ;     cmp R0, R3
00001DC0: 0A000002    ;     beq memsetwritewordslend
00001DC4:             ; 
00001DC4: E7842000    ;     str R2, [R4, R0]
00001DC8:             ; 
00001DC8: E2800004    ;     add R0, R0, #4
00001DCC: EAFFFFFA    ;     b memsetwritewordsloop
00001DD0:             ; 
00001DD0:             ; memsetwritewordslend
00001DD0: E0844003    ;     add R4, R4, R3 ;;inc by the bytes we just wrote
00001DD4: E2073003    ;     and R3, R7, #3 ;;find the remaining bytes to write
00001DD8:             ; 
00001DD8: E3A00000    ;     mov R0, #0
00001DDC:             ; memsetwritebytesloop
00001DDC: E1500003    ;     cmp R0, R3
00001DE0: 0A000002    ;     beq memsetwritebyteslend
00001DE4:             ; 
00001DE4: E7C46000    ;     strb R6, [R4, R0]
00001DE8: E2800001    ;     add R0, R0, #1
00001DEC:             ; 
00001DEC: EAFFFFFA    ;     b memsetwritebytesloop
00001DF0:             ; 
00001DF0:             ; memsetwritebyteslend
00001DF0: EA000006    ;     b memsetend ;;should just be done
00001DF4:             ; 
00001DF4:             ; ;;essentially another function
00001DF4:             ; memsetjustwritebytes
00001DF4: E1A00004    ;     mov R0, R4 ;;get start addr
00001DF8:             ; memsetjustwritebytesloop
00001DF8: E1500005    ;     cmp R0, R5
00001DFC: 2A000002    ;     bhs memsetjustwritebyteslend ;;If the current address is greater than the end address then 
                      ; we're all done
00001E00:             ; 
00001E00: E5406000    ;     strb R6, [R0] ;;store the value
00001E04: E2800001    ;     add R0, R0, #1 ;;inc the address
00001E08:             ; 
00001E08: EAFFFFFA    ;     b memsetjustwritebytesloop ;;branch to loop
00001E0C:             ; 
00001E0C:             ; memsetjustwritebyteslend
00001E0C:             ;     ;;nothing to do here
00001E0C: EAFFFFFF    ;     b memsetret
00001E10:             ; memsetend
00001E10:             ; 
00001E10:             ; memsetret
00001E10: E8BD41F0    ;     pop {R14, R4-R8}
00001E14: E1A0F00E    ;     mov R15, R14
00001E18:             ; 
00001E18:             ; align
00001E18:             ; 
00001E18:             ; ;;String defs -- The naming scheme is bad :(
00001E18: 2D 2D 2D 2D ; welcomemsg      defb "-----------Welcome to JCGOL in ARM32-----------", nl, 0
00001E1C: 2D 2D 2D 2D ; 
00001E20: 2D 2D 2D 57 ; 
00001E24: 65 6C 63 6F ; 
00001E28: 6D 65 20 74 ; 
00001E2C: 6F 20 4A 43 ; 
00001E30: 47 4F 4C 20 ; 
00001E34: 69 6E 20 41 ; 
00001E38: 52 4D 33 32 ; 
00001E3C: 2D 2D 2D 2D ; 
00001E40: 2D 2D 2D 2D ; 
00001E44: 2D 2D 2D 0A ; 
00001E48: 00          ; 
00001E4C:             ; align ;;WHY WHY?!?!??!?!
00001E4C: 28 4E 29 65 ; welcome2msg     defb "(N)ew board\n(L)oad a saved board\n(S)ettings\n(P)rint the heap\n(Q)uit",
00001E50: 77 20 62 6F ;  nl, 0
00001E54: 61 72 64 0A ; 
00001E58: 28 4C 29 6F ; 
00001E5C: 61 64 20 61 ; 
00001E60: 20 73 61 76 ; 
00001E64: 65 64 20 62 ; 
00001E68: 6F 61 72 64 ; 
00001E6C: 0A 28 53 29 ; 
00001E70: 65 74 74 69 ; 
00001E74: 6E 67 73 0A ; 
00001E78: 28 50 29 72 ; 
00001E7C: 69 6E 74 20 ; 
00001E80: 74 68 65 20 ; 
00001E84: 68 65 61 70 ; 
00001E88: 0A 28 51 29 ; 
00001E8C: 75 69 74 0A ; 
00001E90: 00          ; 
00001E91: 49 6E 76 61 ; mainchoicefail  defb "Invalid choice please enter 'n' for new board, 'l' for load a board, 's' 
00001E95: 6C 69 64 20 ; to view settings, 'p' to view the heap, or 'q' to close. Not cases sensative", nl, 0
00001E99: 63 68 6F 69 ; 
00001E9D: 63 65 20 70 ; 
00001EA1: 6C 65 61 73 ; 
00001EA5: 65 20 65 6E ; 
00001EA9: 74 65 72 20 ; 
00001EAD: 27 6E 27 20 ; 
00001EB1: 66 6F 72 20 ; 
00001EB5: 6E 65 77 20 ; 
00001EB9: 62 6F 61 72 ; 
00001EBD: 64 2C 20 27 ; 
00001EC1: 6C 27 20 66 ; 
00001EC5: 6F 72 20 6C ; 
00001EC9: 6F 61 64 20 ; 
00001ECD: 61 20 62 6F ; 
00001ED1: 61 72 64 2C ; 
00001ED5: 20 27 73 27 ; 
00001ED9: 20 74 6F 20 ; 
00001EDD: 76 69 65 77 ; 
00001EE1: 20 73 65 74 ; 
00001EE5: 74 69 6E 67 ; 
00001EE9: 73 2C 20 27 ; 
00001EED: 70 27 20 74 ; 
00001EF1: 6F 20 76 69 ; 
00001EF5: 65 77 20 74 ; 
00001EF9: 68 65 20 68 ; 
00001EFD: 65 61 70 2C ; 
00001F01: 20 6F 72 20 ; 
00001F05: 27 71 27 20 ; 
00001F09: 74 6F 20 63 ; 
00001F0D: 6C 6F 73 65 ; 
00001F11: 2E 20 4E 6F ; 
00001F15: 74 20 63 61 ; 
00001F19: 73 65 73 20 ; 
00001F1D: 73 65 6E 73 ; 
00001F21: 61 74 69 76 ; 
00001F25: 65 0A 00    ; 
00001F28: 54 68 61 6E ; mainendmsg      defb "Thank you for playing JCGOL for ARM32", nl, 0
00001F2C: 6B 20 79 6F ; 
00001F30: 75 20 66 6F ; 
00001F34: 72 20 70 6C ; 
00001F38: 61 79 69 6E ; 
00001F3C: 67 20 4A 43 ; 
00001F40: 47 4F 4C 20 ; 
00001F44: 66 6F 72 20 ; 
00001F48: 41 52 4D 33 ; 
00001F4C: 32 0A 00    ; 
00001F4F: 57 6F 75 6C ; askdefaults     defb "Would you like to use the default settings? Y/n: ", 0
00001F53: 64 20 79 6F ; 
00001F57: 75 20 6C 69 ; 
00001F5B: 6B 65 20 74 ; 
00001F5F: 6F 20 75 73 ; 
00001F63: 65 20 74 68 ; 
00001F67: 65 20 64 65 ; 
00001F6B: 66 61 75 6C ; 
00001F6F: 74 20 73 65 ; 
00001F73: 74 74 69 6E ; 
00001F77: 67 73 3F 20 ; 
00001F7B: 59 2F 6E 3A ; 
00001F7F: 20 00       ; 
00001F81: 45 6E 61 62 ; askerase        defb "Enable erase mode? Y/n: ", 0
00001F85: 6C 65 20 65 ; 
00001F89: 72 61 73 65 ; 
00001F8D: 20 6D 6F 64 ; 
00001F91: 65 3F 20 59 ; 
00001F95: 2F 6E 3A 20 ; 
00001F99: 00          ; 
00001F9A: 45 6E 61 62 ; askslow         defb "Enable slow mode? Y/n: ", 0
00001F9E: 6C 65 20 73 ; 
00001FA2: 6C 6F 77 20 ; 
00001FA6: 6D 6F 64 65 ; 
00001FAA: 3F 20 59 2F ; 
00001FAE: 6E 3A 20 00 ; 
00001FB2: 45 6E 61 62 ; askstep         defb "Enable step mode? Y/n: ", 0
00001FB6: 6C 65 20 73 ; 
00001FBA: 74 65 70 20 ; 
00001FBE: 6D 6F 64 65 ; 
00001FC2: 3F 20 59 2F ; 
00001FC6: 6E 3A 20 00 ; 
00001FCA: 43 61 6E 6E ; stepslowwarning defb "Cannot have slow and step mode active at the same time, disabling slow mo
00001FCE: 6F 74 20 68 ; de", nl, 0
00001FD2: 61 76 65 20 ; 
00001FD6: 73 6C 6F 77 ; 
00001FDA: 20 61 6E 64 ; 
00001FDE: 20 73 74 65 ; 
00001FE2: 70 20 6D 6F ; 
00001FE6: 64 65 20 61 ; 
00001FEA: 63 74 69 76 ; 
00001FEE: 65 20 61 74 ; 
00001FF2: 20 74 68 65 ; 
00001FF6: 20 73 61 6D ; 
00001FFA: 65 20 74 69 ; 
00001FFE: 6D 65 2C 20 ; 
00002002: 64 69 73 61 ; 
00002006: 62 6C 69 6E ; 
0000200A: 67 20 73 6C ; 
0000200E: 6F 77 20 6D ; 
00002012: 6F 64 65 0A ; 
00002016: 00          ; 
00002017: 52 65 74 75 ; savedchoice     defb "Return to menu? (n for continue sim) Y/n: ", 0
0000201B: 72 6E 20 74 ; 
0000201F: 6F 20 6D 65 ; 
00002023: 6E 75 3F 20 ; 
00002027: 28 6E 20 66 ; 
0000202B: 6F 72 20 63 ; 
0000202F: 6F 6E 74 69 ; 
00002033: 6E 75 65 20 ; 
00002037: 73 69 6D 29 ; 
0000203B: 20 59 2F 6E ; 
0000203F: 3A 20 00    ; 
00002042: 50 6C 65 61 ; askname         defb "Please enter a name for the grid (enter to input): ", 0
00002046: 73 65 20 65 ; 
0000204A: 6E 74 65 72 ; 
0000204E: 20 61 20 6E ; 
00002052: 61 6D 65 20 ; 
00002056: 66 6F 72 20 ; 
0000205A: 74 68 65 20 ; 
0000205E: 67 72 69 64 ; 
00002062: 20 28 65 6E ; 
00002066: 74 65 72 20 ; 
0000206A: 74 6F 20 69 ; 
0000206E: 6E 70 75 74 ; 
00002072: 29 3A 20 00 ; 
00002076: 45 72 61 73 ; warneraseslow   defb "Erase mode is active it is recommended to also use slow mode", nl, 0
0000207A: 65 20 6D 6F ; 
0000207E: 64 65 20 69 ; 
00002082: 73 20 61 63 ; 
00002086: 74 69 76 65 ; 
0000208A: 20 69 74 20 ; 
0000208E: 69 73 20 72 ; 
00002092: 65 63 6F 6D ; 
00002096: 6D 65 6E 64 ; 
0000209A: 65 64 20 74 ; 
0000209E: 6F 20 61 6C ; 
000020A2: 73 6F 20 75 ; 
000020A6: 73 65 20 73 ; 
000020AA: 6C 6F 77 20 ; 
000020AE: 6D 6F 64 65 ; 
000020B2: 0A 00       ; 
000020B4: 50 6C 65 61 ; askwid          defb "Please enter a width (", 0
000020B8: 73 65 20 65 ; 
000020BC: 6E 74 65 72 ; 
000020C0: 20 61 20 77 ; 
000020C4: 69 64 74 68 ; 
000020C8: 20 28 00    ; 
000020CB: 2D 00       ; dash            defb "-", 0
000020CD: 29 3A 20 00 ; b_close_colon   defb "): ",0
000020D1: 50 6C 65 61 ; askhei          defb "Please enter a height ", 0
000020D5: 73 65 20 65 ; 
000020D9: 6E 74 65 72 ; 
000020DD: 20 61 20 68 ; 
000020E1: 65 69 67 68 ; 
000020E5: 74 20 00    ; 
000020E8: 49 6E 76 61 ; getwidfailmsg   defb "Invalid width please enter a value between ", 0
000020EC: 6C 69 64 20 ; 
000020F0: 77 69 64 74 ; 
000020F4: 68 20 70 6C ; 
000020F8: 65 61 73 65 ; 
000020FC: 20 65 6E 74 ; 
00002100: 65 72 20 61 ; 
00002104: 20 76 61 6C ; 
00002108: 75 65 20 62 ; 
0000210C: 65 74 77 65 ; 
00002110: 65 6E 20 00 ; 
00002114: 49 6E 76 61 ; getheifailmsg   defb "Invalid height please enter a value between ", 0
00002118: 6C 69 64 20 ; 
0000211C: 68 65 69 67 ; 
00002120: 68 74 20 70 ; 
00002124: 6C 65 61 73 ; 
00002128: 65 20 65 6E ; 
0000212C: 74 65 72 20 ; 
00002130: 61 20 76 61 ; 
00002134: 6C 75 65 20 ; 
00002138: 62 65 74 77 ; 
0000213C: 65 65 6E 20 ; 
00002140: 00          ; 
00002141: 53 74 65 70 ; stepmode_m      defb "Step mode is active. After each itteration of the grid press any key to c
00002145: 20 6D 6F 64 ; ontinue to the next or (q)uit to main menu, or (s)ave the current grid", nl, 0
00002149: 65 20 69 73 ; 
0000214D: 20 61 63 74 ; 
00002151: 69 76 65 2E ; 
00002155: 20 41 66 74 ; 
00002159: 65 72 20 65 ; 
0000215D: 61 63 68 20 ; 
00002161: 69 74 74 65 ; 
00002165: 72 61 74 69 ; 
00002169: 6F 6E 20 6F ; 
0000216D: 66 20 74 68 ; 
00002171: 65 20 67 72 ; 
00002175: 69 64 20 70 ; 
00002179: 72 65 73 73 ; 
0000217D: 20 61 6E 79 ; 
00002181: 20 6B 65 79 ; 
00002185: 20 74 6F 20 ; 
00002189: 63 6F 6E 74 ; 
0000218D: 69 6E 75 65 ; 
00002191: 20 74 6F 20 ; 
00002195: 74 68 65 20 ; 
00002199: 6E 65 78 74 ; 
0000219D: 20 6F 72 20 ; 
000021A1: 28 71 29 75 ; 
000021A5: 69 74 20 74 ; 
000021A9: 6F 20 6D 61 ; 
000021AD: 69 6E 20 6D ; 
000021B1: 65 6E 75 2C ; 
000021B5: 20 6F 72 20 ; 
000021B9: 28 73 29 61 ; 
000021BD: 76 65 20 74 ; 
000021C1: 68 65 20 63 ; 
000021C5: 75 72 72 65 ; 
000021C9: 6E 74 20 67 ; 
000021CD: 72 69 64 0A ; 
000021D1: 00          ; 
000021D4:             ; align ;;WHY?!
000021D4: 43 75 72 72 ; optionsp_1      defb "Current options: dims=(", 0 ;;width
000021D8: 65 6E 74 20 ; 
000021DC: 6F 70 74 69 ; 
000021E0: 6F 6E 73 3A ; 
000021E4: 20 64 69 6D ; 
000021E8: 73 3D 28 00 ; 
000021EC: 2C 20 00    ; optionsp_2      defb ", ", 0 ;;height
000021EF: 29 20 73 6C ; optionsp_3      defb ") slowMode=", 0 ;;OFF/ON
000021F3: 6F 77 4D 6F ; 
000021F7: 64 65 3D 00 ; 
000021FB: 20 65 72 61 ; optionsp_4      defb " eraseMode=", 0 ;;^
000021FF: 73 65 4D 6F ; 
00002203: 64 65 3D 00 ; 
00002207: 20 73 74 65 ; optionsp_5      defb " stepMode=", 0  ;;^
0000220B: 70 4D 6F 64 ; 
0000220F: 65 3D 00    ; 
00002212:             ; 
00002212: 59 6F 75 27 ; mainloopittsmsg defb "You've reached the max itterations before waiting for input. You can chan
00002216: 76 65 20 72 ; ge this in settings. Press any key to continue, 'q' to quit, and 's' to save the grid", nl, 0
0000221A: 65 61 63 68 ; 
0000221E: 65 64 20 74 ; 
00002222: 68 65 20 6D ; 
00002226: 61 78 20 69 ; 
0000222A: 74 74 65 72 ; 
0000222E: 61 74 69 6F ; 
00002232: 6E 73 20 62 ; 
00002236: 65 66 6F 72 ; 
0000223A: 65 20 77 61 ; 
0000223E: 69 74 69 6E ; 
00002242: 67 20 66 6F ; 
00002246: 72 20 69 6E ; 
0000224A: 70 75 74 2E ; 
0000224E: 20 59 6F 75 ; 
00002252: 20 63 61 6E ; 
00002256: 20 63 68 61 ; 
0000225A: 6E 67 65 20 ; 
0000225E: 74 68 69 73 ; 
00002262: 20 69 6E 20 ; 
00002266: 73 65 74 74 ; 
0000226A: 69 6E 67 73 ; 
0000226E: 2E 20 50 72 ; 
00002272: 65 73 73 20 ; 
00002276: 61 6E 79 20 ; 
0000227A: 6B 65 79 20 ; 
0000227E: 74 6F 20 63 ; 
00002282: 6F 6E 74 69 ; 
00002286: 6E 75 65 2C ; 
0000228A: 20 27 71 27 ; 
0000228E: 20 74 6F 20 ; 
00002292: 71 75 69 74 ; 
00002296: 2C 20 61 6E ; 
0000229A: 64 20 27 73 ; 
0000229E: 27 20 74 6F ; 
000022A2: 20 73 61 76 ; 
000022A6: 65 20 74 68 ; 
000022AA: 65 20 67 72 ; 
000022AE: 69 64 0A 00 ; 
000022B2:             ; 
000022B2: 43 68 6F 6F ; askgenoption    defb "Choose between (R)andom generation or (D)rawing the grid", 0
000022B6: 73 65 20 62 ; 
000022BA: 65 74 77 65 ; 
000022BE: 65 6E 20 28 ; 
000022C2: 52 29 61 6E ; 
000022C6: 64 6F 6D 20 ; 
000022CA: 67 65 6E 65 ; 
000022CE: 72 61 74 69 ; 
000022D2: 6F 6E 20 6F ; 
000022D6: 72 20 28 44 ; 
000022DA: 29 72 61 77 ; 
000022DE: 69 6E 67 20 ; 
000022E2: 74 68 65 20 ; 
000022E6: 67 72 69 64 ; 
000022EA: 00          ; 
000022EB: 49 6E 76 61 ; setupGrdFailmsg defb "Invalid choice, use `R` for random generation and `d` for drawing the gri
000022EF: 6C 69 64 20 ; d. Not case sensative: ", 0
000022F3: 63 68 6F 69 ; 
000022F7: 63 65 2C 20 ; 
000022FB: 75 73 65 20 ; 
000022FF: 60 52 60 20 ; 
00002303: 66 6F 72 20 ; 
00002307: 72 61 6E 64 ; 
0000230B: 6F 6D 20 67 ; 
0000230F: 65 6E 65 72 ; 
00002313: 61 74 69 6F ; 
00002317: 6E 20 61 6E ; 
0000231B: 64 20 60 64 ; 
0000231F: 60 20 66 6F ; 
00002323: 72 20 64 72 ; 
00002327: 61 77 69 6E ; 
0000232B: 67 20 74 68 ; 
0000232F: 65 20 67 72 ; 
00002333: 69 64 2E 20 ; 
00002337: 4E 6F 74 20 ; 
0000233B: 63 61 73 65 ; 
0000233F: 20 73 65 6E ; 
00002343: 73 61 74 69 ; 
00002347: 76 65 3A 20 ; 
0000234B: 00          ; 
0000234C: 45 6E 74 65 ; askseed         defb "Enter 4 characters to be used as the seed: ", 0
00002350: 72 20 34 20 ; 
00002354: 63 68 61 72 ; 
00002358: 61 63 74 65 ; 
0000235C: 72 73 20 74 ; 
00002360: 6F 20 62 65 ; 
00002364: 20 75 73 65 ; 
00002368: 64 20 61 73 ; 
0000236C: 20 74 68 65 ; 
00002370: 20 73 65 65 ; 
00002374: 64 3A 20 00 ; 
00002378: 55 73 69 6E ; drawinfomsg     defb "Using '1' and '0' choose the value of the current cell. Use enter to go t
0000237C: 67 20 27 31 ; o next line", nl, 0
00002380: 27 20 61 6E ; 
00002384: 64 20 27 30 ; 
00002388: 27 20 63 68 ; 
0000238C: 6F 6F 73 65 ; 
00002390: 20 74 68 65 ; 
00002394: 20 76 61 6C ; 
00002398: 75 65 20 6F ; 
0000239C: 66 20 74 68 ; 
000023A0: 65 20 63 75 ; 
000023A4: 72 72 65 6E ; 
000023A8: 74 20 63 65 ; 
000023AC: 6C 6C 2E 20 ; 
000023B0: 55 73 65 20 ; 
000023B4: 65 6E 74 65 ; 
000023B8: 72 20 74 6F ; 
000023BC: 20 67 6F 20 ; 
000023C0: 74 6F 20 6E ; 
000023C4: 65 78 74 20 ; 
000023C8: 6C 69 6E 65 ; 
000023CC: 0A 00       ; 
000023CE: 49 6E 76 61 ; drawfailmsg     defb "Invalid input please enter 1 or 0, or enter for next line: ", nl, 0
000023D2: 6C 69 64 20 ; 
000023D6: 69 6E 70 75 ; 
000023DA: 74 20 70 6C ; 
000023DE: 65 61 73 65 ; 
000023E2: 20 65 6E 74 ; 
000023E6: 65 72 20 31 ; 
000023EA: 20 6F 72 20 ; 
000023EE: 30 2C 20 6F ; 
000023F2: 72 20 65 6E ; 
000023F6: 74 65 72 20 ; 
000023FA: 66 6F 72 20 ; 
000023FE: 6E 65 78 74 ; 
00002402: 20 6C 69 6E ; 
00002406: 65 3A 20 0A ; 
0000240A: 00          ; 
0000240B: 47 72 69 64 ; gridfailmsg     defb "Grid was not properly initialised, consider smaller dims", nl, 0
0000240F: 20 77 61 73 ; 
00002413: 20 6E 6F 74 ; 
00002417: 20 70 72 6F ; 
0000241B: 70 65 72 6C ; 
0000241F: 79 20 69 6E ; 
00002423: 69 74 69 61 ; 
00002427: 6C 69 73 65 ; 
0000242B: 64 2C 20 63 ; 
0000242F: 6F 6E 73 69 ; 
00002433: 64 65 72 20 ; 
00002437: 73 6D 61 6C ; 
0000243B: 6C 65 72 20 ; 
0000243F: 64 69 6D 73 ; 
00002443: 0A 00       ; 
00002445: 54 68 65 72 ; gridsavefail    defb "There was an error allocating memory for the grid save", nl, 0
00002449: 65 20 77 61 ; 
0000244D: 73 20 61 6E ; 
00002451: 20 65 72 72 ; 
00002455: 6F 72 20 61 ; 
00002459: 6C 6C 6F 63 ; 
0000245D: 61 74 69 6E ; 
00002461: 67 20 6D 65 ; 
00002465: 6D 6F 72 79 ; 
00002469: 20 66 6F 72 ; 
0000246D: 20 74 68 65 ; 
00002471: 20 67 72 69 ; 
00002475: 64 20 73 61 ; 
00002479: 76 65 0A 00 ; 
0000247D: 54 68 65 72 ; gridloadempty   defb "There are no saved grids, returning to main menu", nl, 0
00002481: 65 20 61 72 ; 
00002485: 65 20 6E 6F ; 
00002489: 20 73 61 76 ; 
0000248D: 65 64 20 67 ; 
00002491: 72 69 64 73 ; 
00002495: 2C 20 72 65 ; 
00002499: 74 75 72 6E ; 
0000249D: 69 6E 67 20 ; 
000024A1: 74 6F 20 6D ; 
000024A5: 61 69 6E 20 ; 
000024A9: 6D 65 6E 75 ; 
000024AD: 0A 00       ; 
000024AF: 7C 69 6E 64 ; gridloadpindex  defb "|index: ", 0
000024B3: 65 78 3A 20 ; 
000024B7: 00          ; 
000024B8: 7C 6E 61 6D ; gridloadpname   defb "|name: ", 0
000024BC: 65 3A 20 00 ; 
000024C0: 7C 77 69 64 ; gridloadpwidth  defb "|width: ", 0
000024C4: 74 68 3A 20 ; 
000024C8: 00          ; 
000024C9: 7C 68 65 69 ; gridloadpheight defb "|height: ", 0
000024CD: 67 68 74 3A ; 
000024D1: 20 00       ; 
000024D3: 50 6C 65 61 ; loadboardaski   defb "Please enter the index of the grid to load, or enter a negative index to 
000024D7: 73 65 20 65 ; not load a grid. (press enter to input)", nl, 0
000024DB: 6E 74 65 72 ; 
000024DF: 20 74 68 65 ; 
000024E3: 20 69 6E 64 ; 
000024E7: 65 78 20 6F ; 
000024EB: 66 20 74 68 ; 
000024EF: 65 20 67 72 ; 
000024F3: 69 64 20 74 ; 
000024F7: 6F 20 6C 6F ; 
000024FB: 61 64 2C 20 ; 
000024FF: 6F 72 20 65 ; 
00002503: 6E 74 65 72 ; 
00002507: 20 61 20 6E ; 
0000250B: 65 67 61 74 ; 
0000250F: 69 76 65 20 ; 
00002513: 69 6E 64 65 ; 
00002517: 78 20 74 6F ; 
0000251B: 20 6E 6F 74 ; 
0000251F: 20 6C 6F 61 ; 
00002523: 64 20 61 20 ; 
00002527: 67 72 69 64 ; 
0000252B: 2E 20 28 70 ; 
0000252F: 72 65 73 73 ; 
00002533: 20 65 6E 74 ; 
00002537: 65 72 20 74 ; 
0000253B: 6F 20 69 6E ; 
0000253F: 70 75 74 29 ; 
00002543: 0A 00       ; 
00002545: 52 65 74 75 ; loadboardretmsg defb "Returning to main menu", nl, 0
00002549: 72 6E 69 6E ; 
0000254D: 67 20 74 6F ; 
00002551: 20 6D 61 69 ; 
00002555: 6E 20 6D 65 ; 
00002559: 6E 75 0A 00 ; 
0000255D: 49 6E 76 61 ; loadboardifail  defb "Invalid input given for the index", nl, 0
00002561: 6C 69 64 20 ; 
00002565: 69 6E 70 75 ; 
00002569: 74 20 67 69 ; 
0000256D: 76 65 6E 20 ; 
00002571: 66 6F 72 20 ; 
00002575: 74 68 65 20 ; 
00002579: 69 6E 64 65 ; 
0000257D: 78 0A 00    ; 
00002580: 49 6E 76 61 ; loadboardirerr  defb "Invalid index, out of range", nl, 0
00002584: 6C 69 64 20 ; 
00002588: 69 6E 64 65 ; 
0000258C: 78 2C 20 6F ; 
00002590: 75 74 20 6F ; 
00002594: 66 20 72 61 ; 
00002598: 6E 67 65 0A ; 
0000259C: 00          ; 
0000259D: 45 72 72 6F ; loadboardmlcerr defb "Error allocating memory for loaded grid. Returing to main menu", nl, 0
000025A1: 72 20 61 6C ; 
000025A5: 6C 6F 63 61 ; 
000025A9: 74 69 6E 67 ; 
000025AD: 20 6D 65 6D ; 
000025B1: 6F 72 79 20 ; 
000025B5: 66 6F 72 20 ; 
000025B9: 6C 6F 61 64 ; 
000025BD: 65 64 20 67 ; 
000025C1: 72 69 64 2E ; 
000025C5: 20 52 65 74 ; 
000025C9: 75 72 69 6E ; 
000025CD: 67 20 74 6F ; 
000025D1: 20 6D 61 69 ; 
000025D5: 6E 20 6D 65 ; 
000025D9: 6E 75 0A 00 ; 
000025DD: 53 75 63 63 ; loadboardsucmsg defb "Successfully loaded the grid", nl, 0
000025E1: 65 73 73 66 ; 
000025E5: 75 6C 6C 79 ; 
000025E9: 20 6C 6F 61 ; 
000025ED: 64 65 64 20 ; 
000025F1: 74 68 65 20 ; 
000025F5: 67 72 69 64 ; 
000025F9: 0A 00       ; 
000025FB: 4C 69 73 74 ; listgridmsg     defb "Listing all availible saved grids", nl, 0
000025FF: 69 6E 67 20 ; 
00002603: 61 6C 6C 20 ; 
00002607: 61 76 61 69 ; 
0000260B: 6C 69 62 6C ; 
0000260F: 65 20 73 61 ; 
00002613: 76 65 64 20 ; 
00002617: 67 72 69 64 ; 
0000261B: 73 0A 00    ; 
0000261E: 2D 2D 2D 2D ; cutoff          defb "-----------------", nl, 0
00002622: 2D 2D 2D 2D ; 
00002626: 2D 2D 2D 2D ; 
0000262A: 2D 2D 2D 2D ; 
0000262E: 2D 0A 00    ; 
00002631: 45 72 72 6F ; changearrverr_m defb "Error invalid value given (1-255) inclusive. Re-enter: ", nl, 0
00002635: 72 20 69 6E ; 
00002639: 76 61 6C 69 ; 
0000263D: 64 20 76 61 ; 
00002641: 6C 75 65 20 ; 
00002645: 67 69 76 65 ; 
00002649: 6E 20 28 31 ; 
0000264D: 2D 32 35 35 ; 
00002651: 29 20 69 6E ; 
00002655: 63 6C 75 73 ; 
00002659: 69 76 65 2E ; 
0000265D: 20 52 65 2D ; 
00002661: 65 6E 74 65 ; 
00002665: 72 3A 20 0A ; 
00002669: 00          ; 
0000266A:             ; 
0000266A: 53 65 74 74 ; s_m1            defb "Settings", nl, "|-[0] stepMode_d     - The following 4 settings are the d
0000266E: 69 6E 67 73 ; efault values for the options", nl, "|-[1] slowMode_d     - Slow mode is ignored if step mode i
00002672: 0A 7C 2D 5B ; s ON", nl, "|-[2] eraseMode_d", nl, "|-[3] Dims_d", nl, 0
00002676: 30 5D 20 73 ; 
0000267A: 74 65 70 4D ; 
0000267E: 6F 64 65 5F ; 
00002682: 64 20 20 20 ; 
00002686: 20 20 2D 20 ; 
0000268A: 54 68 65 20 ; 
0000268E: 66 6F 6C 6C ; 
00002692: 6F 77 69 6E ; 
00002696: 67 20 34 20 ; 
0000269A: 73 65 74 74 ; 
0000269E: 69 6E 67 73 ; 
000026A2: 20 61 72 65 ; 
000026A6: 20 74 68 65 ; 
000026AA: 20 64 65 66 ; 
000026AE: 61 75 6C 74 ; 
000026B2: 20 76 61 6C ; 
000026B6: 75 65 73 20 ; 
000026BA: 66 6F 72 20 ; 
000026BE: 74 68 65 20 ; 
000026C2: 6F 70 74 69 ; 
000026C6: 6F 6E 73 0A ; 
000026CA: 7C 2D 5B 31 ; 
000026CE: 5D 20 73 6C ; 
000026D2: 6F 77 4D 6F ; 
000026D6: 64 65 5F 64 ; 
000026DA: 20 20 20 20 ; 
000026DE: 20 2D 20 53 ; 
000026E2: 6C 6F 77 20 ; 
000026E6: 6D 6F 64 65 ; 
000026EA: 20 69 73 20 ; 
000026EE: 69 67 6E 6F ; 
000026F2: 72 65 64 20 ; 
000026F6: 69 66 20 73 ; 
000026FA: 74 65 70 20 ; 
000026FE: 6D 6F 64 65 ; 
00002702: 20 69 73 20 ; 
00002706: 4F 4E 0A 7C ; 
0000270A: 2D 5B 32 5D ; 
0000270E: 20 65 72 61 ; 
00002712: 73 65 4D 6F ; 
00002716: 64 65 5F 64 ; 
0000271A: 0A 7C 2D 5B ; 
0000271E: 33 5D 20 44 ; 
00002722: 69 6D 73 5F ; 
00002726: 64 0A 00    ; 
00002729: 7C 2D 5B 34 ; s_m2            defb "|-[4] range          - The range of values that the dims can have (1-255 
0000272D: 5D 20 72 61 ; && range_min < range_max)", nl, 0
00002731: 6E 67 65 20 ; 
00002735: 20 20 20 20 ; 
00002739: 20 20 20 20 ; 
0000273D: 20 2D 20 54 ; 
00002741: 68 65 20 72 ; 
00002745: 61 6E 67 65 ; 
00002749: 20 6F 66 20 ; 
0000274D: 76 61 6C 75 ; 
00002751: 65 73 20 74 ; 
00002755: 68 61 74 20 ; 
00002759: 74 68 65 20 ; 
0000275D: 64 69 6D 73 ; 
00002761: 20 63 61 6E ; 
00002765: 20 68 61 76 ; 
00002769: 65 20 28 31 ; 
0000276D: 2D 32 35 35 ; 
00002771: 20 26 26 20 ; 
00002775: 72 61 6E 67 ; 
00002779: 65 5F 6D 69 ; 
0000277D: 6E 20 3C 20 ; 
00002781: 72 61 6E 67 ; 
00002785: 65 5F 6D 61 ; 
00002789: 78 29 0A 00 ; 
0000278D: 7C 2D 5B 35 ; s_m3            defb "|-[5] Icons          - The characters printed for an alive/dead/ptr cell"
00002791: 5D 20 49 63 ; ,nl, "|-[6] itters         - The number of itterations in the non-step version before it will w
00002795: 6F 6E 73 20 ; ait for input", nl, 0
00002799: 20 20 20 20 ; 
0000279D: 20 20 20 20 ; 
000027A1: 20 2D 20 54 ; 
000027A5: 68 65 20 63 ; 
000027A9: 68 61 72 61 ; 
000027AD: 63 74 65 72 ; 
000027B1: 73 20 70 72 ; 
000027B5: 69 6E 74 65 ; 
000027B9: 64 20 66 6F ; 
000027BD: 72 20 61 6E ; 
000027C1: 20 61 6C 69 ; 
000027C5: 76 65 2F 64 ; 
000027C9: 65 61 64 2F ; 
000027CD: 70 74 72 20 ; 
000027D1: 63 65 6C 6C ; 
000027D5: 0A 7C 2D 5B ; 
000027D9: 36 5D 20 69 ; 
000027DD: 74 74 65 72 ; 
000027E1: 73 20 20 20 ; 
000027E5: 20 20 20 20 ; 
000027E9: 20 20 2D 20 ; 
000027ED: 54 68 65 20 ; 
000027F1: 6E 75 6D 62 ; 
000027F5: 65 72 20 6F ; 
000027F9: 66 20 69 74 ; 
000027FD: 74 65 72 61 ; 
00002801: 74 69 6F 6E ; 
00002805: 73 20 69 6E ; 
00002809: 20 74 68 65 ; 
0000280D: 20 6E 6F 6E ; 
00002811: 2D 73 74 65 ; 
00002815: 70 20 76 65 ; 
00002819: 72 73 69 6F ; 
0000281D: 6E 20 62 65 ; 
00002821: 66 6F 72 65 ; 
00002825: 20 69 74 20 ; 
00002829: 77 69 6C 6C ; 
0000282D: 20 77 61 69 ; 
00002831: 74 20 66 6F ; 
00002835: 72 20 69 6E ; 
00002839: 70 75 74 0A ; 
0000283D: 00          ; 
0000283E: 60 2D 5B 37 ; s_m4            defb "`-[7] Drawing erase  - Bool for if when drawing the grid it should erase 
00002842: 5D 20 44 72 ; the previous one", nl, 0
00002846: 61 77 69 6E ; 
0000284A: 67 20 65 72 ; 
0000284E: 61 73 65 20 ; 
00002852: 20 2D 20 42 ; 
00002856: 6F 6F 6C 20 ; 
0000285A: 66 6F 72 20 ; 
0000285E: 69 66 20 77 ; 
00002862: 68 65 6E 20 ; 
00002866: 64 72 61 77 ; 
0000286A: 69 6E 67 20 ; 
0000286E: 74 68 65 20 ; 
00002872: 67 72 69 64 ; 
00002876: 20 69 74 20 ; 
0000287A: 73 68 6F 75 ; 
0000287E: 6C 64 20 65 ; 
00002882: 72 61 73 65 ; 
00002886: 20 74 68 65 ; 
0000288A: 20 70 72 65 ; 
0000288E: 76 69 6F 75 ; 
00002892: 73 20 6F 6E ; 
00002896: 65 0A 00    ; 
00002899: 45 6E 74 65 ; s_m             defb "Enter the index of the setting to edit or -1 to return to the menu (press
0000289D: 72 20 74 68 ;  enter to input): ", 0
000028A1: 65 20 69 6E ; 
000028A5: 64 65 78 20 ; 
000028A9: 6F 66 20 74 ; 
000028AD: 68 65 20 73 ; 
000028B1: 65 74 74 69 ; 
000028B5: 6E 67 20 74 ; 
000028B9: 6F 20 65 64 ; 
000028BD: 69 74 20 6F ; 
000028C1: 72 20 2D 31 ; 
000028C5: 20 74 6F 20 ; 
000028C9: 72 65 74 75 ; 
000028CD: 72 6E 20 74 ; 
000028D1: 6F 20 74 68 ; 
000028D5: 65 20 6D 65 ; 
000028D9: 6E 75 20 28 ; 
000028DD: 70 72 65 73 ; 
000028E1: 73 20 65 6E ; 
000028E5: 74 65 72 20 ; 
000028E9: 74 6F 20 69 ; 
000028ED: 6E 70 75 74 ; 
000028F1: 29 3A 20 00 ; 
000028F5: 45 72 72 6F ; s_m_err         defb "Error invalid index. Re-enter: ", 0
000028F9: 72 20 69 6E ; 
000028FD: 76 61 6C 69 ; 
00002901: 64 20 69 6E ; 
00002905: 64 65 78 2E ; 
00002909: 20 52 65 2D ; 
0000290D: 65 6E 74 65 ; 
00002911: 72 3A 20 00 ; 
00002918:             ; align
00002918:             ; 
00002918: 53 6C 6F 77 ; currentslow     defb "Slow_d: ", 0
0000291C: 5F 64 3A 20 ; 
00002920: 00          ; 
00002921: 45 72 61 73 ; currenterase    defb "Erase_d: ", 0
00002925: 65 5F 64 3A ; 
00002929: 20 00       ; 
0000292B: 53 74 65 70 ; currentstep     defb "Step_d: ", 0
0000292F: 5F 64 3A 20 ; 
00002933: 00          ; 
00002934: 44 69 6D 73 ; currentDims     defb "Dims: ", 0
00002938: 3A 20 00    ; 
0000293B: 52 61 6E 67 ; currentRange    defb "Range: ", 0
0000293F: 65 3A 20 00 ; 
00002943: 49 74 74 65 ; currentItters   defb "Itters: ", 0
00002947: 72 73 3A 20 ; 
0000294B: 00          ; 
0000294C: 45 72 61 73 ; currentdraweras defb "Erase when drawing: ", 0
00002950: 65 20 77 68 ; 
00002954: 65 6E 20 64 ; 
00002958: 72 61 77 69 ; 
0000295C: 6E 67 3A 20 ; 
00002960: 00          ; 
00002961: 28 00       ; bracket_open    defb "(", 0
00002963: 2C 20 00    ; comma_space     defb ", ", 0
00002966: 29 00       ; bracket_close   defb ")", 0
00002968: 41 6C 69 76 ; currenticons_1  defb "Alive: ", 0
0000296C: 65 3A 20 00 ; 
00002970: 44 65 61 64 ; currenticons_2  defb "Dead: ", 0
00002974: 3A 20 00    ; 
00002977: 50 74 72 3A ; currenticons_3  defb "Ptr: ", 0
0000297B: 20 00       ; 
0000297D: 45 6E 74 65 ; currenticons_a  defb "Enter 3 character (not seperated) for the values of the alive/dead/ptr ch
00002981: 72 20 33 20 ; aracters: ", 0
00002985: 63 68 61 72 ; 
00002989: 61 63 74 65 ; 
0000298D: 72 20 28 6E ; 
00002991: 6F 74 20 73 ; 
00002995: 65 70 65 72 ; 
00002999: 61 74 65 64 ; 
0000299D: 29 20 66 6F ; 
000029A1: 72 20 74 68 ; 
000029A5: 65 20 76 61 ; 
000029A9: 6C 75 65 73 ; 
000029AD: 20 6F 66 20 ; 
000029B1: 74 68 65 20 ; 
000029B5: 61 6C 69 76 ; 
000029B9: 65 2F 64 65 ; 
000029BD: 61 64 2F 70 ; 
000029C1: 74 72 20 63 ; 
000029C5: 68 61 72 61 ; 
000029C9: 63 74 65 72 ; 
000029CD: 73 3A 20 00 ; 
000029D1: 45 72 72 6F ; mallocerr_m     defb "Error getting memory from malloc", nl, 0
000029D5: 72 20 67 65 ; 
000029D9: 74 74 69 6E ; 
000029DD: 67 20 6D 65 ; 
000029E1: 6D 6F 72 79 ; 
000029E5: 20 66 72 6F ; 
000029E9: 6D 20 6D 61 ; 
000029ED: 6C 6C 6F 63 ; 
000029F1: 0A 00       ; 
000029F3: 45 72 72 6F ; getstringerr_m  defb "Error getting string, could be malloc error", nl, 0
000029F7: 72 20 67 65 ; 
000029FB: 74 74 69 6E ; 
000029FF: 67 20 73 74 ; 
00002A03: 72 69 6E 67 ; 
00002A07: 2C 20 63 6F ; 
00002A0B: 75 6C 64 20 ; 
00002A0F: 62 65 20 6D ; 
00002A13: 61 6C 6C 6F ; 
00002A17: 63 20 65 72 ; 
00002A1B: 72 6F 72 0A ; 
00002A1F: 00          ; 
00002A20: 49 74 74 65 ; currentitter    defb "Itters: ", 0
00002A24: 72 73 3A 20 ; 
00002A28: 00          ; 
00002A29: 45 6E 74 65 ; currentaskx     defb "Enter value for x (input with enter): ", 0
00002A2D: 72 20 76 61 ; 
00002A31: 6C 75 65 20 ; 
00002A35: 66 6F 72 20 ; 
00002A39: 78 20 28 69 ; 
00002A3D: 6E 70 75 74 ; 
00002A41: 20 77 69 74 ; 
00002A45: 68 20 65 6E ; 
00002A49: 74 65 72 29 ; 
00002A4D: 3A 20 00    ; 
00002A50: 45 6E 74 65 ; currentasky     defb "Enter value for y (input with enter): ", 0
00002A54: 72 20 76 61 ; 
00002A58: 6C 75 65 20 ; 
00002A5C: 66 6F 72 20 ; 
00002A60: 79 20 28 69 ; 
00002A64: 6E 70 75 74 ; 
00002A68: 20 77 69 74 ; 
00002A6C: 68 20 65 6E ; 
00002A70: 74 65 72 29 ; 
00002A74: 3A 20 00    ; 
00002A77: 45 6E 74 65 ; currentasknew   defb "Enter new value: ", 0
00002A7B: 72 20 6E 65 ; 
00002A7F: 77 20 76 61 ; 
00002A83: 6C 75 65 3A ; 
00002A87: 20 00       ; 
00002A89: 45 6E 74 65 ; currentasknew_B defb "Enter new value (0 or 1): ", 0
00002A8D: 72 20 6E 65 ; 
00002A91: 77 20 76 61 ; 
00002A95: 6C 75 65 20 ; 
00002A99: 28 30 20 6F ; 
00002A9D: 72 20 31 29 ; 
00002AA1: 3A 20 00    ; 
00002AA4: 45 72 72 6F ; currentasknew_E defb "Error invalid re-enter: ", 0
00002AA8: 72 20 69 6E ; 
00002AAC: 76 61 6C 69 ; 
00002AB0: 64 20 72 65 ; 
00002AB4: 2D 65 6E 74 ; 
00002AB8: 65 72 3A 20 ; 
00002ABC: 00          ; 
00002ABD: 49 6E 76 61 ; currentarrerr   defb "Invalid value entered re-enter: ", 0
00002AC1: 6C 69 64 20 ; 
00002AC5: 76 61 6C 75 ; 
00002AC9: 65 20 65 6E ; 
00002ACD: 74 65 72 65 ; 
00002AD1: 64 20 72 65 ; 
00002AD5: 2D 65 6E 74 ; 
00002AD9: 65 72 3A 20 ; 
00002ADD: 00          ; 
00002ADE: 49 6E 76 61 ; changearrsizmsg defb "Invalid, x >= y.", nl, 0
00002AE2: 6C 69 64 2C ; 
00002AE6: 20 78 20 3E ; 
00002AEA: 3D 20 79 2E ; 
00002AEE: 0A 00       ; 
00002AF0: 49 6E 76 61 ; changeittere_m  defb "Invalid itter value. Re-enter: ", nl, 0
00002AF4: 6C 69 64 20 ; 
00002AF8: 69 74 74 65 ; 
00002AFC: 72 20 76 61 ; 
00002B00: 6C 75 65 2E ; 
00002B04: 20 52 65 2D ; 
00002B08: 65 6E 74 65 ; 
00002B0C: 72 3A 20 0A ; 
00002B10: 00          ; 
00002B11: 45 6E 74 65 ; getitters_m     defb "Enter the max itterations (1-255): ", 0
00002B15: 72 20 74 68 ; 
00002B19: 65 20 6D 61 ; 
00002B1D: 78 20 69 74 ; 
00002B21: 74 65 72 61 ; 
00002B25: 74 69 6F 6E ; 
00002B29: 73 20 28 31 ; 
00002B2D: 2D 32 35 35 ; 
00002B31: 29 3A 20 00 ; 
00002B35:             ; 
00002B38:             ; align ;; w   h   y
00002B38:             ; 
00002B38: 43 75 72 72 ; currentset_m    defb "Current settings: (", 0
00002B3C: 65 6E 74 20 ; 
00002B40: 73 65 74 74 ; 
00002B44: 69 6E 67 73 ; 
00002B48: 3A 20 28 00 ; 
00002B4C:             ; ;;Current settings (stepMode_d: On/Off  slowMode_d: On/Off  eraseMode_d: On/Off  Dims_d:(x,y)
00002B4C:             ; ;;                  Range:(x,y)  Alive_c:X  Dead_c:Y  Ptr_c:Z  Itters:xx  EwD:On/Off)
00002B4C:             ; 
00002B4C:             ; ;;debug for heap
00002B4C: 50 72 69 6E ; printFree_m     defb "Printing free list", nl
00002B50: 74 69 6E 67 ; 
00002B54: 20 66 72 65 ; 
00002B58: 65 20 6C 69 ; 
00002B5C: 73 74 0A    ; 
00002B5F: 46 6F 75 6E ; printfree_f_m   defb "Found a new free item", nl, 0
00002B63: 64 20 61 20 ; 
00002B67: 6E 65 77 20 ; 
00002B6B: 66 72 65 65 ; 
00002B6F: 20 69 74 65 ; 
00002B73: 6D 0A 00    ; 
00002B76: 41 64 64 72 ; printfree_f_mad defb "Address: ", 0
00002B7A: 65 73 73 3A ; 
00002B7E: 20 00       ; 
00002B80: 4E 65 78 74 ; printfree_f_mnx defb "Next   : ", 0
00002B84: 20 20 20 3A ; 
00002B88: 20 00       ; 
00002B8A: 50 72 65 76 ; printfree_f_mpr defb "Prev   : ", 0
00002B8E: 20 20 20 3A ; 
00002B92: 20 00       ; 
00002B94: 53 69 7A 65 ; printfree_f_msz defb "Size   : ", 0
00002B98: 20 20 20 3A ; 
00002B9C: 20 00       ; 
00002B9E: 5B 5B 21 21 ; printFree_m_e   defb "[[!!]] Error circular Crate found. Ending printFree [[!!]]", nl, 0
00002BA2: 5D 5D 20 45 ; 
00002BA6: 72 72 6F 72 ; 
00002BAA: 20 63 69 72 ; 
00002BAE: 63 75 6C 61 ; 
00002BB2: 72 20 43 72 ; 
00002BB6: 61 74 65 20 ; 
00002BBA: 66 6F 75 6E ; 
00002BBE: 64 2E 20 45 ; 
00002BC2: 6E 64 69 6E ; 
00002BC6: 67 20 70 72 ; 
00002BCA: 69 6E 74 46 ; 
00002BCE: 72 65 65 20 ; 
00002BD2: 5B 5B 21 21 ; 
00002BD6: 5D 5D 0A 00 ; 
00002BDA:             ; 
00002BDA: 50 72 69 6E ; printAll_m      defb "Printing all elements in the heap", nl, 0
00002BDE: 74 69 6E 67 ; 
00002BE2: 20 61 6C 6C ; 
00002BE6: 20 65 6C 65 ; 
00002BEA: 6D 65 6E 74 ; 
00002BEE: 73 20 69 6E ; 
00002BF2: 20 74 68 65 ; 
00002BF6: 20 68 65 61 ; 
00002BFA: 70 0A 00    ; 
00002BFD: 54 68 69 73 ; printAll_m_f    defb "This is a Free block", nl, 0
00002C01: 20 69 73 20 ; 
00002C05: 61 20 46 72 ; 
00002C09: 65 65 20 62 ; 
00002C0D: 6C 6F 63 6B ; 
00002C11: 0A 00       ; 
00002C13: 54 68 69 73 ; printAll_m_t    defb "This is a Taken block", nl, 0
00002C17: 20 69 73 20 ; 
00002C1B: 61 20 54 61 ; 
00002C1F: 6B 65 6E 20 ; 
00002C23: 62 6C 6F 63 ; 
00002C27: 6B 0A 00    ; 
00002C2A: 5B 5B 21 21 ; printAll_m_e    defb "[[!!]] Error circular crate found, NO LONGER PRINTING FREE CLASSIFIERS [[
00002C2E: 5D 5D 20 45 ; !!]]", nl, 0
00002C32: 72 72 6F 72 ; 
00002C36: 20 63 69 72 ; 
00002C3A: 63 75 6C 61 ; 
00002C3E: 72 20 63 72 ; 
00002C42: 61 74 65 20 ; 
00002C46: 66 6F 75 6E ; 
00002C4A: 64 2C 20 4E ; 
00002C4E: 4F 20 4C 4F ; 
00002C52: 4E 47 45 52 ; 
00002C56: 20 50 52 49 ; 
00002C5A: 4E 54 49 4E ; 
00002C5E: 47 20 46 52 ; 
00002C62: 45 45 20 43 ; 
00002C66: 4C 41 53 53 ; 
00002C6A: 49 46 49 45 ; 
00002C6E: 52 53 20 5B ; 
00002C72: 5B 21 21 5D ; 
00002C76: 5D 0A 00    ; 
00002C79:             ; 
00002C79: 48 65 72 65 ; printHeap_end_m defb "Here's the heap at the end of the program!", nl, 0
00002C7D: 27 73 20 74 ; 
00002C81: 68 65 20 68 ; 
00002C85: 65 61 70 20 ; 
00002C89: 61 74 20 74 ; 
00002C8D: 68 65 20 65 ; 
00002C91: 6E 64 20 6F ; 
00002C95: 66 20 74 68 ; 
00002C99: 65 20 70 72 ; 
00002C9D: 6F 67 72 61 ; 
00002CA1: 6D 21 0A 00 ; 
00002CA5:             ; 
00002CA5: 4D 61 6C 6C ; malloc_panic    defb "Malloc failed, cannot recover. Please consider reporting this to your nea
00002CA9: 6F 63 20 66 ; rest duck", nl, 0
00002CAD: 61 69 6C 65 ; 
00002CB1: 64 2C 20 63 ; 
00002CB5: 61 6E 6E 6F ; 
00002CB9: 74 20 72 65 ; 
00002CBD: 63 6F 76 65 ; 
00002CC1: 72 2E 20 50 ; 
00002CC5: 6C 65 61 73 ; 
00002CC9: 65 20 63 6F ; 
00002CCD: 6E 73 69 64 ; 
00002CD1: 65 72 20 72 ; 
00002CD5: 65 70 6F 72 ; 
00002CD9: 74 69 6E 67 ; 
00002CDD: 20 74 68 69 ; 
00002CE1: 73 20 74 6F ; 
00002CE5: 20 79 6F 75 ; 
00002CE9: 72 20 6E 65 ; 
00002CED: 61 72 65 73 ; 
00002CF1: 74 20 64 75 ; 
00002CF5: 63 6B 0A 00 ; 
00002CF9: 48 65 61 70 ; heapNotEmpty_m  defb "Heap is not empty i.e. freelist[0].next != 0 || freelist[0].size + freeli
00002CFD: 20 69 73 20 ; st[0].addr + 12 != HEAPEND\nIf you are not James please regard this as an intended feature. If 
00002D01: 6E 6F 74 20 ; you are James please fix :)", nl, 0
00002D05: 65 6D 70 74 ; 
00002D09: 79 20 69 2E ; 
00002D0D: 65 2E 20 66 ; 
00002D11: 72 65 65 6C ; 
00002D15: 69 73 74 5B ; 
00002D19: 30 5D 2E 6E ; 
00002D1D: 65 78 74 20 ; 
00002D21: 21 3D 20 30 ; 
00002D25: 20 7C 7C 20 ; 
00002D29: 66 72 65 65 ; 
00002D2D: 6C 69 73 74 ; 
00002D31: 5B 30 5D 2E ; 
00002D35: 73 69 7A 65 ; 
00002D39: 20 2B 20 66 ; 
00002D3D: 72 65 65 6C ; 
00002D41: 69 73 74 5B ; 
00002D45: 30 5D 2E 61 ; 
00002D49: 64 64 72 20 ; 
00002D4D: 2B 20 31 32 ; 
00002D51: 20 21 3D 20 ; 
00002D55: 48 45 41 50 ; 
00002D59: 45 4E 44 0A ; 
00002D5D: 49 66 20 79 ; 
00002D61: 6F 75 20 61 ; 
00002D65: 72 65 20 6E ; 
00002D69: 6F 74 20 4A ; 
00002D6D: 61 6D 65 73 ; 
00002D71: 20 70 6C 65 ; 
00002D75: 61 73 65 20 ; 
00002D79: 72 65 67 61 ; 
00002D7D: 72 64 20 74 ; 
00002D81: 68 69 73 20 ; 
00002D85: 61 73 20 61 ; 
00002D89: 6E 20 69 6E ; 
00002D8D: 74 65 6E 64 ; 
00002D91: 65 64 20 66 ; 
00002D95: 65 61 74 75 ; 
00002D99: 72 65 2E 20 ; 
00002D9D: 49 66 20 79 ; 
00002DA1: 6F 75 20 61 ; 
00002DA5: 72 65 20 4A ; 
00002DA9: 61 6D 65 73 ; 
00002DAD: 20 70 6C 65 ; 
00002DB1: 61 73 65 20 ; 
00002DB5: 66 69 78 20 ; 
00002DB9: 3A 29 0A 00 ; 
00002DBD: 48 65 61 70 ; heapEmpty_m     defb "Heap is empty! SUCCESS!", nl, 0
00002DC1: 20 69 73 20 ; 
00002DC5: 65 6D 70 74 ; 
00002DC9: 79 21 20 53 ; 
00002DCD: 55 43 43 45 ; 
00002DD1: 53 53 21 0A ; 
00002DD5: 00          ; 
00002DD6: 41 74 74 65 ; free_m_addr     defb "Attempting to free address: ", 0
00002DDA: 6D 70 74 69 ; 
00002DDE: 6E 67 20 74 ; 
00002DE2: 6F 20 66 72 ; 
00002DE6: 65 65 20 61 ; 
00002DEA: 64 64 72 65 ; 
00002DEE: 73 73 3A 20 ; 
00002DF2: 00          ; 
00002DF3: 5B 5B 21 21 ; free_m_zero     defb "[[!!]] Info: Free was given a null ptr", nl, 0
00002DF7: 5D 5D 20 49 ; 
00002DFB: 6E 66 6F 3A ; 
00002DFF: 20 46 72 65 ; 
00002E03: 65 20 77 61 ; 
00002E07: 73 20 67 69 ; 
00002E0B: 76 65 6E 20 ; 
00002E0F: 61 20 6E 75 ; 
00002E13: 6C 6C 20 70 ; 
00002E17: 74 72 0A 00 ; 
00002E1B:             ; 
00002E1B: 46 61 69 6C ; updatergrid_m_f defb "Failed to update grids, one or more are null", nl, 0
00002E1F: 65 64 20 74 ; 
00002E23: 6F 20 75 70 ; 
00002E27: 64 61 74 65 ; 
00002E2B: 20 67 72 69 ; 
00002E2F: 64 73 2C 20 ; 
00002E33: 6F 6E 65 20 ; 
00002E37: 6F 72 20 6D ; 
00002E3B: 6F 72 65 20 ; 
00002E3F: 61 72 65 20 ; 
00002E43: 6E 75 6C 6C ; 
00002E47: 0A 00       ; 
00002E49:             ; 
00002E49: 4F 4E 00    ; on_msg          defb "ON", 0
00002E4C: 4F 46 46 00 ; off_msg         defb "OFF", 0
00002E50: 2C 00       ; comma           defb ",", 0
00002E52:             ; 
00002E54:             ; align
00002E54: 00000000    ; heapstart       defw 0 ;;points to the end of the data this is where the heap can then begin
00002E58:             ; Remaining literals

Symbol Table: Labels
: max_addr                          00100000  Value
: stack_size                        00010000  Value
: nl                                0000000A  Value
: backspace                         00000008  Value
: minBuffSize                       00000008  Value
: enter                             0000000A  Value
: minSaveSize                       00000008  Value
: sizeofSaveI                       0000000C  Value
: heaphead                          00000004  Local -- ARM
: offsets                           00000008  Local -- ARM
: gridA                             00000048  Local -- ARM
: gridB                             0000004C  Local -- ARM
: erase_b                           00000050  Local -- ARM
: slow_b                            00000051  Local -- ARM
: step_b                            00000052  Local -- ARM
: width                             00000053  Local -- ARM
: height                            00000054  Local -- ARM
: range_min                         00000055  Local -- ARM
: range_max                         00000056  Local -- ARM
: maxitters                         00000057  Local -- ARM
: drawerase_b                       00000058  Local -- ARM
: alive_c                           00000059  Local -- ARM
: dead_c                            0000005A  Local -- ARM
: ptr_c                             0000005B  Local -- ARM
: erase_b_d                         0000005C  Local -- ARM
: slow_b_d                          0000005D  Local -- ARM
: step_b_d                          0000005E  Local -- ARM
: width_d                           0000005F  Local -- ARM
: height_d                          00000060  Local -- ARM
: _start                            00000064  Local -- ARM
: main                              00000090  Local -- ARM
: mainmenu                          000000C4  Local -- ARM
: mainchoice                        000000DC  Local -- ARM
: showHeap                          00000124  Local -- ARM
: mainloopstart                     0000012C  Local -- ARM
: mainloop                          00000160  Local -- ARM
: mainloopcont                      00000184  Local -- ARM
: mainloopdostep                    000001A0  Local -- ARM
: mainloopskipstep                  000001D8  Local -- ARM
: mainloopskipslow                  000001E0  Local -- ARM
: gridFail                          000001FC  Local -- ARM
: mainMallocFail                    00000208  Local -- ARM
: mainEnd                           00000218  Local -- ARM
: assertheapempty                   0000023C  Local -- ARM
: assertionfail                     00000278  Local -- ARM
: assertionsuccess                  00000288  Local -- ARM
: mainEndEnd                        00000294  Local -- ARM
: mainfree                          000002A0  Local -- ARM
: mainfreeloop                      000002B8  Local -- ARM
: mainfreelend                      000002F0  Local -- ARM
: mainfreeend                       00000300  Local -- ARM
: printcurrentsettinglist           00000308  Local -- ARM
: printcurrentsettings              00000344  Local -- ARM
: settingsmenu                      00000508  Local -- ARM
: changesetting                     00000538  Local -- ARM
: changesettingget                  00000548  Local -- ARM
: changesettingserr                 0000058C  Local -- ARM
: changesettingsmallocfail          0000059C  Local -- ARM
: changesettingscont                000005AC  Local -- ARM
: jumps                             000005B8  Local -- ARM
: getjump                           000005D8  Local -- ARM
: changearr                         0000062C  Local -- ARM
: changearrget                      00000640  Local -- ARM
: changearrsizeerr                  0000068C  Local -- ARM
: changearrset                      0000069C  Local -- ARM
: changearrmallocerr                000006B4  Local -- ARM
: changearrend                      000006BC  Local -- ARM
: changearrendend                   000006C0  Local -- ARM
: changearrgetvalidint              000006C8  Local -- ARM
: changearrgetvalidintget           000006CC  Local -- ARM
: changearrgetvalidinterr           00000704  Local -- ARM
: changearrgetvalidintcont          00000718  Local -- ARM
: changearrgvmallocerr              0000072C  Local -- ARM
: changearrgetvalidintend           00000734  Local -- ARM
: changearrgvendend                 0000073C  Local -- ARM
: printdims                         00000744  Local -- ARM
: changestep                        00000798  Local -- ARM
: changeslow                        000007B0  Local -- ARM
: changeerase                       000007C8  Local -- ARM
: changebool                        000007E0  Local -- ARM
: changebool_cont                   00000820  Local -- ARM
: changebool_set                    0000084C  Local -- ARM
: changeboolend                     0000087C  Local -- ARM
: changedims                        00000884  Local -- ARM
: changedimscont                    000008B4  Local -- ARM
: changerange                       000008B8  Local -- ARM
: changerangecont                   000008E8  Local -- ARM
: changeicons                       000008EC  Local -- ARM
: changeiconsmallerr                00000938  Local -- ARM
: printicons                        00000948  Local -- ARM
: printiconsend                     0000099C  Local -- ARM
: changeitter                       000009A0  Local -- ARM
: changeitterget                    000009C4  Local -- ARM
: changeittergetcont                000009EC  Local -- ARM
: changeittererr                    00000A24  Local -- ARM
: changeitterend                    00000A38  Local -- ARM
: changedrawerase                   00000A54  Local -- ARM
: changedraweraseend                00000A6C  Local -- ARM
: newboard                          00000A70  Local -- ARM
: newboardcont                      00000A98  Local -- ARM
: loadboard                         00000AC0  Local -- ARM
: loadboardaskindex                 00000AD4  Local -- ARM
: loadboardaskindexcont             00000B08  Local -- ARM
: loadboardindex                    00000B50  Local -- ARM
: loadboardmain                     00000B6C  Local -- ARM
: loadboardmallocB                  00000BB0  Local -- ARM
: loadboardskipB                    00000BC4  Local -- ARM
: loadboardmallocfail               00000BE4  Local -- ARM
: loadboardret                      00000BF4  Local -- ARM
: loadboardempty                    00000C00  Local -- ARM
: loadboarderr                      00000C00  Local -- ARM
: loadboardsucc                     00000C04  Local -- ARM
: newline                           00000C08  Local -- ARM
: step                              00000C14  Local -- ARM
: stepcont                          00000C68  Local -- ARM
: stependfail                       00000CA8  Local -- ARM
: stependsucc                       00000CB0  Local -- ARM
: stepend                           00000CB4  Local -- ARM
: listGrids                         00000CBC  Local -- ARM
: listGridsLoop                     00000CF0  Local -- ARM
: listGridsEmpty                    00000D84  Local -- ARM
: listGridsLend                     00000D90  Local -- ARM
: listGridsEnd                      00000D90  Local -- ARM
: saveGrid                          00000D98  Local -- ARM
: saveGridResize                    00000DBC  Local -- ARM
: saveGridAdd                       00000DF4  Local -- ARM
: saveGridFailMalloc                00000E5C  Local -- ARM
: saveGridSucc                      00000E64  Local -- ARM
: saveGridEnd                       00000E68  Local -- ARM
: erase                             00000E70  Local -- ARM
: eraseloop                         00000E74  Local -- ARM
: eraseend                          00000E8C  Local -- ARM
: slow                              00000E90  Local -- ARM
: slowloop                          00000E98  Local -- ARM
: slowend                           00000EB8  Local -- ARM
: heapclean                         00000EBC  Local -- ARM
: heapcleanloop                     00000ED8  Local -- ARM
: heapcleanend                      00000EEC  Local -- ARM
: strlen                            00000EF0  Local -- ARM
: strlenloop                        00000EFC  Local -- ARM
: strlenend                         00000F10  Local -- ARM
: strtoi                            00000F18  Local -- ARM
: strtoiloop                        00000F58  Local -- ARM
: strtoilend                        00000F8C  Local -- ARM
: strtoifailminus                   00000F94  Local -- ARM
: strtoifailoutrange                00000F9C  Local -- ARM
: strtoifailnonnum                  00000FA4  Local -- ARM
: strtoiendfail                     00000FA8  Local -- ARM
: strtoiendsucc                     00000FB0  Local -- ARM
: strtoiend                         00000FB4  Local -- ARM
: memcpy                            00000FBC  Local -- ARM
: memcpywordsloop                   00000FE4  Local -- ARM
: memcpywordslend                   00000FFC  Local -- ARM
: memcpyallbytes                    0000100C  Local -- ARM
: memcpybytes                       00001018  Local -- ARM
: memcpybytesloop                   0000101C  Local -- ARM
: memcpybyteslend                   00001034  Local -- ARM
: memcpyend                         00001038  Local -- ARM
: getstring                         00001040  Local -- ARM
: getstringloop                     00001074  Local -- ARM
: getstringloopskipsize             00001084  Local -- ARM
: skipMax                           00001098  Local -- ARM
: getstringlcont                    000010A4  Local -- ARM
: getstringresize                   000010BC  Local -- ARM
: getstringlend                     000010F4  Local -- ARM
: getstringResizeEnd                00001100  Local -- ARM
: getstringErr                      00001138  Local -- ARM
: getstringEnd                      00001140  Local -- ARM
: getstringEndEnd                   0000114C  Local -- ARM
: tolower                           00001154  Local -- ARM
: setupGrid                         0000115C  Local -- ARM
: setupGridAsk                      000011C4  Local -- ARM
: setupdrawing                      000011F4  Local -- ARM
: setuprandom                       00001218  Local -- ARM
: setupstart                        0000124C  Local -- ARM
: setuprowloop                      00001250  Local -- ARM
: setupcolloop                      0000125C  Local -- ARM
: dorandom                          00001270  Local -- ARM
: dodrawstart                       00001284  Local -- ARM
: dodraw                            0000129C  Local -- ARM
: dodrawfail                        000012F8  Local -- ARM
: dodrawsucc                        00001308  Local -- ARM
: dodrawsuccskiperase               00001334  Local -- ARM
: setupcollcont                     0000133C  Local -- ARM
: setupcollend                      0000134C  Local -- ARM
: setuprowlend                      00001354  Local -- ARM
: setupGridFail                     0000135C  Local -- ARM
: setupGridEnd                      0000136C  Local -- ARM
: drawgrid                          00001374  Local -- ARM
: drawgridrowloop                   00001398  Local -- ARM
: drawgridcolloop                   000013A4  Local -- ARM
: drawgridprintcurrent              000013E0  Local -- ARM
: drawgridcollcont                  000013F0  Local -- ARM
: drawgridcollend                   00001400  Local -- ARM
: drawgridrowlend                   00001414  Local -- ARM
: drawgridend                       0000141C  Local -- ARM
: printoptions                      00001424  Local -- ARM
: setupOptions                      000014F8  Local -- ARM
: setupOptionsDEnd                  000015A8  Local -- ARM
: setupCustom                       000015B4  Local -- ARM
: setupCustomskipslow               00001684  Local -- ARM
: printrange                        00001698  Local -- ARM
: setupCustomDimsCheck              000016E0  Local -- ARM
: getwid                            000016F8  Local -- ARM
: getwidFail                        00001764  Local -- ARM
: getheisetup                       00001778  Local -- ARM
: gethei                            00001788  Local -- ARM
: getheiFail                        000017F4  Local -- ARM
: customfail                        0000180C  Local -- ARM
: customend                         0000181C  Local -- ARM
: customret                         00001820  Local -- ARM
: updategrid                        00001828  Local -- ARM
: updategridrowloop                 00001860  Local -- ARM
: updategridcolloop                 0000186C  Local -- ARM
: updatealive                       00001894  Local -- ARM
: updatedead                        000018B0  Local -- ARM
: updatelcont                       000018C0  Local -- ARM
: updategridccollend                000018C8  Local -- ARM
: updategridfail                    000018D4  Local -- ARM
: updategridrowlend                 000018E0  Local -- ARM
: updategridend                     000018E0  Local -- ARM
: countneighbours                   000018E8  Local -- ARM
: countneighboursloop               00001914  Local -- ARM
: countneighboursskipadd            00001958  Local -- ARM
: countneighbourslend               0000195C  Local -- ARM
: countneighboursend                0000195C  Local -- ARM
: isinrange                         00001968  Local -- ARM
: isinrangefail                     000019AC  Local -- ARM
: isinrangeend                      000019B0  Local -- ARM
: setupHeap                         000019B4  Local -- ARM
: malloc                            000019E8  Local -- ARM
: mallignend                        00001A04  Local -- ARM
: checkcrate                        00001A18  Local -- ARM
: nextcrate                         00001A34  Local -- ARM
: cratelend                         00001A48  Local -- ARM
: nocrates                          00001A58  Local -- ARM
: foundcrate                        00001A60  Local -- ARM
: splitcrate                        00001A70  Local -- ARM
: usecrate                          00001AA4  Local -- ARM
: mallocEnd                         00001AC8  Local -- ARM
: printHeap                         00001AD0  Local -- ARM
: printHeapend                      00001ADC  Local -- ARM
: printAll                          00001AE4  Local -- ARM
: printAllLoop                      00001B04  Local -- ARM
: printAllLoopSkipWarning           00001B28  Local -- ARM
: printAllLoopCont                  00001B48  Local -- ARM
: printAllLend                      00001B68  Local -- ARM
: printAllEnd                       00001B68  Local -- ARM
: printFree                         00001B70  Local -- ARM
: printFreeloop                     00001B8C  Local -- ARM
: printFreelend                     00001BC4  Local -- ARM
: printFreeErr                      00001BC8  Local -- ARM
: printFreeEnd                      00001BD4  Local -- ARM
: printblock                        00001BDC  Local -- ARM
: free                              00001C74  Local -- ARM
: freeloop                          00001C90  Local -- ARM
: freelend                          00001CAC  Local -- ARM
: freelendEnd                       00001CCC  Local -- ARM
: freeMergeCheck                    00001CD4  Local -- ARM
: verifyLeft                        00001CE4  Local -- ARM
: verifyRight                       00001CF8  Local -- ARM
: merge                             00001D0C  Local -- ARM
: mergeNew                          00001D40  Local -- ARM
: freeEndZero                       00001D44  Local -- ARM
: freeEnd                           00001D50  Local -- ARM
: memset                            00001D58  Local -- ARM
: memsetalignloop                   00001D88  Local -- ARM
: memsetalignlend                   00001D9C  Local -- ARM
: memsetwritewordsloop              00001DBC  Local -- ARM
: memsetwritewordslend              00001DD0  Local -- ARM
: memsetwritebytesloop              00001DDC  Local -- ARM
: memsetwritebyteslend              00001DF0  Local -- ARM
: memsetjustwritebytes              00001DF4  Local -- ARM
: memsetjustwritebytesloop          00001DF8  Local -- ARM
: memsetjustwritebyteslend          00001E0C  Local -- ARM
: memsetend                         00001E10  Local -- ARM
: memsetret                         00001E10  Local -- ARM
: welcomemsg                        00001E18  Local -- ARM
: welcome2msg                       00001E4C  Local -- ARM
: mainchoicefail                    00001E91  Local -- ARM
: mainendmsg                        00001F28  Local -- ARM
: askdefaults                       00001F4F  Local -- ARM
: askerase                          00001F81  Local -- ARM
: askslow                           00001F9A  Local -- ARM
: askstep                           00001FB2  Local -- ARM
: stepslowwarning                   00001FCA  Local -- ARM
: savedchoice                       00002017  Local -- ARM
: askname                           00002042  Local -- ARM
: warneraseslow                     00002076  Local -- ARM
: askwid                            000020B4  Local -- ARM
: dash                              000020CB  Local -- ARM
: b_close_colon                     000020CD  Local -- ARM
: askhei                            000020D1  Local -- ARM
: getwidfailmsg                     000020E8  Local -- ARM
: getheifailmsg                     00002114  Local -- ARM
: stepmode_m                        00002141  Local -- ARM
: optionsp_1                        000021D4  Local -- ARM
: optionsp_2                        000021EC  Local -- ARM
: optionsp_3                        000021EF  Local -- ARM
: optionsp_4                        000021FB  Local -- ARM
: optionsp_5                        00002207  Local -- ARM
: mainloopittsmsg                   00002212  Local -- ARM
: askgenoption                      000022B2  Local -- ARM
: setupGrdFailmsg                   000022EB  Local -- ARM
: askseed                           0000234C  Local -- ARM
: drawinfomsg                       00002378  Local -- ARM
: drawfailmsg                       000023CE  Local -- ARM
: gridfailmsg                       0000240B  Local -- ARM
: gridsavefail                      00002445  Local -- ARM
: gridloadempty                     0000247D  Local -- ARM
: gridloadpindex                    000024AF  Local -- ARM
: gridloadpname                     000024B8  Local -- ARM
: gridloadpwidth                    000024C0  Local -- ARM
: gridloadpheight                   000024C9  Local -- ARM
: loadboardaski                     000024D3  Local -- ARM
: loadboardretmsg                   00002545  Local -- ARM
: loadboardifail                    0000255D  Local -- ARM
: loadboardirerr                    00002580  Local -- ARM
: loadboardmlcerr                   0000259D  Local -- ARM
: loadboardsucmsg                   000025DD  Local -- ARM
: listgridmsg                       000025FB  Local -- ARM
: cutoff                            0000261E  Local -- ARM
: changearrverr_m                   00002631  Local -- ARM
: s_m1                              0000266A  Local -- ARM
: s_m2                              00002729  Local -- ARM
: s_m3                              0000278D  Local -- ARM
: s_m4                              0000283E  Local -- ARM
: s_m                               00002899  Local -- ARM
: s_m_err                           000028F5  Local -- ARM
: currentslow                       00002918  Local -- ARM
: currenterase                      00002921  Local -- ARM
: currentstep                       0000292B  Local -- ARM
: currentDims                       00002934  Local -- ARM
: currentRange                      0000293B  Local -- ARM
: currentItters                     00002943  Local -- ARM
: currentdraweras                   0000294C  Local -- ARM
: bracket_open                      00002961  Local -- ARM
: comma_space                       00002963  Local -- ARM
: bracket_close                     00002966  Local -- ARM
: currenticons_1                    00002968  Local -- ARM
: currenticons_2                    00002970  Local -- ARM
: currenticons_3                    00002977  Local -- ARM
: currenticons_a                    0000297D  Local -- ARM
: mallocerr_m                       000029D1  Local -- ARM
: getstringerr_m                    000029F3  Local -- ARM
: currentitter                      00002A20  Local -- ARM
: currentaskx                       00002A29  Local -- ARM
: currentasky                       00002A50  Local -- ARM
: currentasknew                     00002A77  Local -- ARM
: currentasknew_B                   00002A89  Local -- ARM
: currentasknew_E                   00002AA4  Local -- ARM
: currentarrerr                     00002ABD  Local -- ARM
: changearrsizmsg                   00002ADE  Local -- ARM
: changeittere_m                    00002AF0  Local -- ARM
: getitters_m                       00002B11  Local -- ARM
: currentset_m                      00002B38  Local -- ARM
: printFree_m                       00002B4C  Local -- ARM
: printfree_f_m                     00002B5F  Local -- ARM
: printfree_f_mad                   00002B76  Local -- ARM
: printfree_f_mnx                   00002B80  Local -- ARM
: printfree_f_mpr                   00002B8A  Local -- ARM
: printfree_f_msz                   00002B94  Local -- ARM
: printFree_m_e                     00002B9E  Local -- ARM
: printAll_m                        00002BDA  Local -- ARM
: printAll_m_f                      00002BFD  Local -- ARM
: printAll_m_t                      00002C13  Local -- ARM
: printAll_m_e                      00002C2A  Local -- ARM
: printHeap_end_m                   00002C79  Local -- ARM
: malloc_panic                      00002CA5  Local -- ARM
: heapNotEmpty_m                    00002CF9  Local -- ARM
: heapEmpty_m                       00002DBD  Local -- ARM
: free_m_addr                       00002DD6  Local -- ARM
: free_m_zero                       00002DF3  Local -- ARM
: updatergrid_m_f                   00002E1B  Local -- ARM
: on_msg                            00002E49  Local -- ARM
: off_msg                           00002E4C  Local -- ARM
: comma                             00002E50  Local -- ARM
: heapstart                         00002E54  Local -- ARM
