KMD
00000000:             ; ;;  This is my second rendition of JCGOL in ARM assembly for Komodo
00000000:             ; ;;  
00000000:             ; ;;  This will attempt to follow the ARM 32bit calling convention 
00000000:             ; ;;      R0-3 are argument registers, scratch
00000000:             ; ;;      R4-10 are local variable registers and should be saved before use in a function
00000000:             ; ;;      R11 - FP
00000000:             ; ;;      R12 - IPC
00000000:             ; ;;      R13 - SP
00000000:             ; ;;      R14 - LR
00000000:             ; ;;      R15 - PC
00000000:             ; ;;
00000000:             ; ;;  The plan
00000000:             ; ;;  - Create a simple `heap` allocator for the grid and input
00000000:             ; ;;  - Ask the user
00000000:             ; ;;      |-Use default? Y - skip below
00000000:             ; ;;      |-dims of the grid
00000000:             ; ;;      |   `-Will need a way to get a string input and convert to an integer (make sure to cat
                      ; ch -ve)
00000000:             ; ;;      |-slow mode
00000000:             ; ;;      `-erase mode
00000000:             ; ;;  - ask for generation mode
00000000:             ; ;;      |-If random ask for seed
00000000:             ; ;;      |   `-For generation roll the seed to create a pseudorandom value for each `pixel`
00000000:             ; ;;      `-If draw then get them to draw the grid one `pixel` at a time
00000000:             ; ;;  - Allocate two grids, the pointers to which will swap after a frame. One is used to count t
                      ; he neighbours the other for the new cell value.
00000000:             ; ;;  - loop
00000000:             ; ;;      |-count neighbours
00000000:             ; ;;      |-update inactive grid
00000000:             ; ;;      |-swap grids
00000000:             ; ;;      |-draw active grid
00000000:             ; ;;      `-goto loop
00000000:             ; 
00000000:             ; 
00000000:             ; ;;SINGLE STEP mode allows you to save the current state of the board into a list, also give it 
                      ; a name
00000000:             ; ;;At the main menu you can load a saved grid
00000000:             ; 
00000000:             ; ;;Grid info struct
00000000:             ; ;;  - SaveInfoStruct* array
00000000:             ; ;;  - int max size of arr
00000000:             ; ;;  - int current position in arr
00000000:             ; 
00000000:             ; ;;Save info struct
00000000:             ; ;;  -address of grid [4 BYTES]
00000000:             ; ;;  -char* to the name [4 BYTES]
00000000:             ; ;;  -width of grid (1 BYTE)
00000000:             ; ;;  -height of grid (1 BYTE)
00000000:             ; 
00000000:             ; 
00000000:             ; ;;  CURRENT ISSUES/TODOS
00000000:             ; ;;  |-More testing of malloc & free need to be done
00000000:             ; ;;  |-Think about minimising the fragmentation of the heap - find the best free block instead o
                      ; f the first
00000000:             ; ;;  |
00000000:             ; ;;  |-Need to add the saveGrid and LoadGrids methods
00000000:             ; ;;  |-Need to restructure the gridInfo struct - it needs the ptr to arr, maxsize, and current i
                      ; ndex - this will shift the sp offset to not n + m + 4 % 8 == 0
00000000:             ; ;;  |-Need to copy the grid when saving to allow the current grid to be used again
00000000:             ; ;;  `-When we're in the menu should the current grids be freed?
00000000:             ; max_addr    EQU  0x100000
00000000:             ; stack_size  EQU  0x10000
00000000:             ; nl      EQU  10
00000000:             ; backspace   EQU  8
00000000:             ; minBuffSize EQU  8
00000000:             ; enter       EQU  nl
00000000:             ; minSaveSize EQU  8
00000000:             ; sizeofSaveI EQU  12 ;;10 bytes + 2 bytes of padding
00000000:             ; 
00000000:             ; _start
00000000:             ;     ;;prepare the stack
00000000: E3A0D601    ;     ldr R13, =max_addr
00000004: E3A0E000    ;     mov R14, #0 ;; allow for `returning` from _start
00000008: E92D4000    ;     push {R14}
0000000C:             ; 
0000000C:             ;     ;;[[temp]] clean the heap
0000000C: EB00014E    ;     bl heapclean
00000010:             ; 
00000010:             ;     ;;setup heap
00000010: E28F0F7A    ;     adrl R0, heapstart
00000014: E2800B05    ; 
00000018: E58F0E00    ;     str R0, heaphead
0000001C: EB000319    ;     bl setupHeap
00000020:             ; 
00000020: E3A0000E    ;     mov R0, #14
00000024: EB000322    ;     bl malloc
00000028:             ; 
00000028: EB000002    ;     bl main
0000002C:             ; 
0000002C: E8BD4000    ;     pop {R14}
00000030: EF000002    ;     swi 2
00000034: E1A0F00E    ;     mov R15, R14
00000038:             ; 
00000038:             ; main
00000038: E92D4FF0    ;     push {fp, R14, R4-R10} ;;8 registers saved
0000003C:             ; 
0000003C: E28DB01C    ;     add fp, sp, #28 ;;(r - 1) * 4
00000040: E24DD010    ;     sub sp, sp, #16 ;;reserve 12 bytes (4 bytes to align?) on the stack for the pointer to the 
                      ; list of saved grids + the maxSize of the array
00000044:             ; 
00000044:             ;     ;;The gridInfo struct
00000044:             ;     ;;set the current position of the pointer
00000044: E3A00000    ;     mov R0, #0
00000048: E58D0008    ;     str R0, [sp, #8]
0000004C:             ; 
0000004C:             ;     ;;set the number of elements(save info structs) that can be stored in the array at the mome
                      ; nt
0000004C: E3A00008    ;     ldr R0, =minSaveSize
00000050: E58D0004    ;     str R0, [sp, #4]
00000054:             ; 
00000054:             ;     ;;minsize * sizeof(SaveInfo) = number of bytes needed for the array
00000054: E3A0100C    ;     ldr R1, =sizeofSaveI
00000058: E0000190    ;     mul R0, R0, R1
0000005C: EB000314    ;     bl malloc ;;allocate the array on the heap
00000060:             ; 
00000060: E58D0000    ;     str R0, [sp, #0] ;;store the address
00000064:             ; 
00000064:             ; mainmenu
00000064: E28F0005    ;     adrl R0, welcomemsg
00000068: E2800C0E    ; 
0000006C: EF000003    ;     swi 3
00000070:             ; 
00000070: E28F002A    ;     adrl R0, welcome2msg
00000074: E2800C0E    ; 
00000078: EF000003    ;     swi 3
0000007C:             ; 
0000007C:             ; mainchoice
0000007C: EF000001    ;     swi 1
00000080: E3800020    ;     orr R0, R0, #32
00000084: E1A04000    ;     mov R4, R0
00000088:             ; 
00000088: E354006E    ;     cmp R4, #'n' ;;new board generation
0000008C: 0A000008    ;     beq newboard
00000090:             ; 
00000090: E354006C    ;     cmp R4, #'l' ;;load a saved board
00000094: E1A0000D    ;     mov R0, sp ;;load the info ptr
00000098: 0A00000F    ;     beq loadboard
0000009C:             ; 
0000009C: E3540071    ;     cmp R4, #'q' ;;quit
000000A0: 0A00008D    ;     beq mainEnd
000000A4:             ; 
000000A4: E28F0042    ;     adrl R0, mainchoicefail
000000A8: E2800C0E    ; 
000000AC: EF000003    ;     swi 3
000000B0:             ; 
000000B0: EAFFFFF1    ;     b mainchoice
000000B4:             ; 
000000B4:             ;     ;;R4 will hold the active grid, R5 will hold the passive grid
000000B4:             ;     ;;Active is used to count neighbours, passive is used to place updated values in 
000000B4:             ;     ;;either can be drawn, just drawn in a different position
000000B4:             ; 
000000B4:             ; newboard
000000B4: E3A00001    ;     mov R0, #1;;should get dims
000000B8: EB000229    ;     bl setupOptions
000000BC:             ; 
000000BC: EB0001C1    ;     bl setupGrid
000000C0:             ;     
000000C0: E59F4D9C    ;     ldr R4, gridA
000000C4: E59F5D9C    ;     ldr R5, gridB
000000C8:             ; 
000000C8: E3540000    ;     cmp R4, #0
000000CC: 0A00007F    ;     beq gridFail
000000D0: E3550000    ;     cmp R5, #0
000000D4: 0A00007D    ;     beq gridFail
000000D8:             ; 
000000D8: EA000056    ;     b mainloopstart
000000DC:             ; 
000000DC:             ; loadboard
000000DC:             ; ;;INP in R0 is the ptr to the SaveInfoHeader struct i.e. ptr to arr, current pos, max size
000000DC:             ; ;;RET in R0 0 for success in which case go to main loop, n/0 for err in which case return to ma
                      ; in menu
000000DC:             ; ;;display the saved grids
000000DC:             ; ;;ask for the index
000000DC:             ; ;;load the grids with the saved info
000000DC:             ; ;;ask the user for the settings
000000DC: E1A04000    ;     mov R4, R0 ;;save the struct ptr
000000E0:             ; 
000000E0:             ;     ;;pass ptr to listgrids
000000E0: EB0000A9    ;     bl listGrids
000000E4:             ; 
000000E4: E5940008    ;     ldr R0, [R4, #8] ;;get the current position
000000E8: E3500000    ;     cmp R0, #0
000000EC: 0A00004F    ;     beq loadboardempty
000000F0:             ; 
000000F0:             ; loadboardaskindex
000000F0:             ;     ;;The grid has now been printed out we need to get the index to load
000000F0: E28F00F6    ;     adrl R0, loadboardaski
000000F4: E2800C13    ; 
000000F8: EF000003    ;     swi 3
000000FC:             ; 
000000FC: E3A0000A    ;     ldr R0, =enter
00000100: E3E01000    ;     mov R1, #-1
00000104: E3A02001    ;     mov R2, #1
00000108: EB000170    ;     bl getstring
0000010C: E1A05000    ;     mov R5, R0
00000110:             ; 
00000110: EB000077    ;     bl newline
00000114:             ; 
00000114: E1A00005    ;     mov R0, R5
00000118: EB000122    ;     bl strtoi
0000011C: E1A06000    ;     mov R6, R0
00000120: E1A07001    ;     mov R7, R1
00000124:             ;     ;;ERR codes
00000124:             ;     ;;  0 is success
00000124:             ;     ;;  1 is attempted -ve
00000124:             ;     ;;  2 is use of non-numeric characters
00000124:             ;     ;;  3 is value out of range of integer
00000124:             ;     ;;  4 is null string given
00000124:             ; 
00000124: E1A00005    ;     mov R0, R5
00000128: EB00030B    ;     bl free
0000012C:             ; 
0000012C: E1A00006    ;     mov R0, R6
00000130: E1A01007    ;     mov R1, R7
00000134:             ; 
00000134: E3510001    ;     cmp R1, #1
00000138: 0A000039    ;     beq loadboardret
0000013C:             ; 
0000013C: E3510000    ;     cmp R1, #0
00000140: 0A000003    ;     beq loadboardindex
00000144:             ; 
00000144: E28F0014    ;     adrl R0, loadboardifail
00000148: E2800B05    ; 
0000014C: EF000003    ;     swi 3
00000150:             ; 
00000150: EAFFFFE6    ;     b loadboardaskindex
00000154:             ; 
00000154:             ; loadboardindex
00000154:             ; ;;we now have an index lets check if its in range and then load the board
00000154:             ;     ;;should be +ve so don't need to check < 0
00000154: E5941008    ;     ldr R1, [R4, #8] ;;get the current position, this is where things get added so index < curr
                      ; entposition
00000158: E1500001    ;     cmp R0, R1
0000015C: BA000003    ;     blt loadboardmain
00000160:             ; 
00000160: E28F001B    ;     adrl R0, loadboardirerr
00000164: E2800B05    ; 
00000168: EF000003    ;     swi 3
0000016C: EAFFFFDF    ;     b loadboardaskindex
00000170:             ; 
00000170:             ; loadboardmain
00000170:             ; ;;now we know that the index is valid we can load the grid
00000170:             ; ;;
00000170:             ; ;;need to free current grid
00000170:             ; ;;need to create a copy of the snapshot and set gridA to it 
00000170:             ; ;;return to main menu
00000170: E5941000    ;     ldr R1, [R4, #0] ;;get the array of grids
00000174: E3A0200C    ;     ldr R2, =sizeofSaveI
00000178: E0201290    ;     mla R0, R0, R2, R1 ;;R0 = index * sizeofSaveI + grid.addr
0000017C:             ; 
0000017C: E5905000    ;     ldr R5, [R0, #0] ;;get the address of that grid
00000180: E5D06008    ;     ldrb R6, [R0, #8] ;;get the width
00000184: E5D07009    ;     ldrb R7, [R0, #9] ;;get the height
00000188:             ; 
00000188: E0000796    ;     mul R0, R6, R7 ;;get the required size
0000018C: E1A09000    ;     mov R9, R0 ;;save the number of bytes
00000190:             ; 
00000190: EB0002C7    ;     bl malloc
00000194:             ; 
00000194: E3500000    ;     cmp R0, #0
00000198: 0A00001D    ;     beq loadboardmallocfail
0000019C:             ; 
0000019C: E1A08000    ;     mov R8, R0 ;;save the new grid arr
000001A0:             ; 
000001A0:             ;     ;;need to copy the saved grid into the new grid
000001A0:             ; 
000001A0: E1A00005    ;     mov R0, R5  ;;src is the saved grid
000001A4: E1A01008    ;     mov R1, R8  ;;dst is the new grid
000001A8: E1A02009    ;     mov R2, R9  ;;bytes is in R9 already from width and height
000001AC: EB000126    ;     bl memcpy
000001B0:             ; 
000001B0: E59F0CAC    ;     ldr R0, gridA
000001B4: EB0002E8    ;     bl free
000001B8:             ; 
000001B8: E58F8CA4    ;     str R8, gridA
000001BC:             ; 
000001BC:             ;     ;;also need to check if the old gridB is big enough
000001BC: E5DF8CAB    ;     ldrb R8, width
000001C0: E5DFACA8    ;     ldrb R10, height
000001C4: E1560008    ;     cmp R6, R8
000001C8: 1A000002    ;     bne loadboardmallocB
000001CC: E157000A    ;     cmp R7, R10
000001D0: 1A000000    ;     bne loadboardmallocB
000001D4:             ; 
000001D4: EA000006    ;     b loadboardskipB
000001D8:             ; 
000001D8:             ; loadboardmallocB
000001D8: E59F0C88    ;     ldr R0, gridB
000001DC: EB0002DE    ;     bl free
000001E0:             ; 
000001E0: E1A00009    ;     mov R0, R9
000001E4: EB0002B2    ;     bl malloc
000001E8:             ; 
000001E8: E3500000    ;     cmp R0, #0
000001EC: 0A000008    ;     beq loadboardmallocfail
000001F0:             ; 
000001F0: E58F0C70    ;     str R0, gridB
000001F4:             ; 
000001F4:             ; loadboardskipB
000001F4: E5CF6C73    ;     strb R6, width
000001F8: E5CF7C70    ;     strb R7, height ;;overwrite the active grid information
000001FC:             ; 
000001FC: E28F0FF7    ;     adrl R0, loadboardsucmsg
00000200: E2800A01    ; 
00000204: EF000003    ;     swi 3
00000208:             ; 
00000208: E3A00000    ;     mov R0, #0 ;;skip asking dims as they've been loaded
0000020C: EB0001D4    ;     bl setupOptions
00000210:             ; 
00000210: EA000007    ;     b loadboardsucc
00000214:             ; 
00000214:             ; loadboardmallocfail
00000214: E28F0FE1    ;     adrl R0, loadboardmlcerr
00000218: E2800A01    ; 
0000021C: EF000003    ;     swi 3
00000220:             ; 
00000220: EA000002    ;     b loadboarderr
00000224:             ; 
00000224:             ; loadboardret
00000224: E28F0FC7    ;     adrl R0, loadboardretmsg
00000228: E2800A01    ; 
0000022C: EF000003    ;     swi 3
00000230:             ; 
00000230:             ; loadboardempty
00000230:             ; loadboarderr
00000230: EAFFFF8B    ;     b mainmenu
00000234:             ; loadboardsucc
00000234: EAFFFFFF    ;     b mainloopstart
00000238:             ; 
00000238:             ; 
00000238:             ; ;;update loop
00000238:             ; ;;    - loop
00000238:             ; ;;      |-count neighbours
00000238:             ; ;;      |-update inactive grid
00000238:             ; ;;      |-swap grids
00000238:             ; ;;      |-draw grid
00000238:             ; ;;      |-[slow?] - slow() - loops for some time to increase waiting time
00000238:             ; ;;      |-[step?] - step() - waits for input, s and q will have effects
00000238:             ; ;;      |-[erase?] - erase() - \b until grid is gone
00000238:             ; ;;      `-goto loop
00000238:             ; mainloopstart
00000238:             ;     ;;load the slow, step, and erase booleans
00000238: E5DF6C2D    ;     ldrb R6, slow_b
0000023C: E5DF7C28    ;     ldrb R7, erase_b
00000240: E5DF8C26    ;     ldrb R8, step_b
00000244:             ; 
00000244: E59F4C18    ;     ldr R4, gridA
00000248: E59F5C18    ;     ldr R5, gridB
0000024C:             ; 
0000024C:             ;     ;;(width * height) * 2 + 1 + height
0000024C: E5DF0C1B    ;     ldrb R0, width
00000250: E5DF1C18    ;     ldrb R1, height
00000254: E0000190    ;     mul R0, R0, R1
00000258: E1A00080    ;     mov R0, R0, lsl #1
0000025C: E2800001    ;     add R0, R0, #1
00000260: E0800001    ;     add R0, R0, R1
00000264: E1A09000    ;     mov R9, R0      ;;R9 holds the itterations for erase, so it doesn't have to calc it every t
                      ; ime
00000268:             ; 
00000268:             ; mainloop
00000268: E1A00004    ;     mov R0, R4
0000026C: E1A01005    ;     mov R1, R5
00000270: EB000233    ;     bl updategrid
00000274:             ; 
00000274: E1A00004    ;     mov R0, R4
00000278: EB00019C    ;     bl drawgrid
0000027C:             ; 
0000027C: E3580001    ;     cmp R8, #1
00000280: 1A000009    ;     bne mainloopskipstep
00000284:             ; 
00000284: E1A0000D    ;     mov R0, sp
00000288: E1A01004    ;     mov R1, R4 ;;give the active grid
0000028C: EB00001B    ;     bl step
00000290: E3500000    ;     cmp R0, #0
00000294: 0A000004    ;     beq mainloopskipstep
00000298:             ;     
00000298:             ;     ;;If R0 is #1 then free and go to the main menu
00000298:             ;     ;;free the current grid
00000298: E59F0BC4    ;     ldr R0, gridA
0000029C: EB0002AE    ;     bl free
000002A0: E59F0BC0    ;     ldr R0, gridB
000002A4: EB0002AC    ;     bl free
000002A8:             ; 
000002A8: EAFFFF6D    ;     b mainmenu
000002AC:             ; 
000002AC:             ; mainloopskipstep
000002AC: E3560001    ;     cmp R6, #1
000002B0: 0B00009A    ;     bleq slow
000002B4:             ; 
000002B4: E3570001    ;     cmp R7, #1
000002B8: 01A00009    ;     moveq R0, R9
000002BC: 0B00008F    ;     bleq erase
000002C0:             ; 
000002C0: E1A00004    ;     mov R0, R4
000002C4: E1A04005    ;     mov R4, R5
000002C8: E1A05000    ;     mov R5, R0 ;;SWAP the active and passive
000002CC:             ; 
000002CC: EAFFFFE5    ;     b mainloop
000002D0:             ; 
000002D0:             ; gridFail
000002D0: E28F001D    ;     adrl R0, gridfailmsg
000002D4: E2800C11    ; 
000002D8: EF000003    ;     swi 3
000002DC:             ; 
000002DC:             ; mainEnd
000002DC:             ;     ;;need to free all of the memory, saved grids (grids + names) + current grids
000002DC:             ; 
000002DC: E28F00A9    ;     adrl R0, mainendmsg
000002E0: E2800C0D    ; 
000002E4: EF000003    ;     swi 3
000002E8:             ; 
000002E8: E24BD018    ;     sub sp, fp, #24 ;;???
000002EC: E8BD47F0    ;     pop {R14, R4-R10}
000002F0: E1A0F00E    ;     mov R15, R14
000002F4:             ; 
000002F4:             ; newline
000002F4: E3A0000A    ;     ldr R0, =nl
000002F8: EF000000    ;     swi 0
000002FC:             ; 
000002FC: E1A0F00E    ;     mov R15, R14
00000300:             ; 
00000300:             ; step
00000300:             ; ;;INP in R0 is the gridHeaderStruct ptr [[todo]]
00000300:             ; ;;INP in R1 is the active grid ptr
00000300:             ; ;;OUT in R0 is 1 if should return to main menu, else 0.
00000300:             ; 
00000300:             ; ;;get user input
00000300:             ; ;;if q -> jump to main menu
00000300:             ; ;;if s -> ask for name, bl saveGrid with name
00000300: E92D41F0    ;     push {R14, R4-R8}
00000304: E1A04000    ;     mov R4, R0 ;;save the struct 
00000308: E1A05001    ;     mov R5, R1
0000030C:             ; 
0000030C: EF000001    ;     swi 1
00000310:             ; 
00000310: E3500071    ;     cmp R0, #'q'
00000314: 0A000017    ;     beq stependfail ;;bad name, shame I can't change it eh
00000318:             ; 
00000318: E3500073    ;     cmp R0, #'s'
0000031C: 1A000017    ;     bne stependsucc
00000320:             ; 
00000320: E28F007F    ;     adrl R0, askname
00000324: E2800C0E    ; 
00000328: EF000003    ;     swi 3
0000032C:             ; 
0000032C: E3A0000A    ;     ldr R0, =enter
00000330: E3E01000    ;     mov R1, #-1
00000334: E3A02001    ;     mov R2, #1
00000338: EB0000E4    ;     bl getstring
0000033C:             ; 
0000033C: E1A01000    ;     mov R1, R0 ;;char* name
00000340: E1A00004    ;     mov R0, R4 ;;gridinfo* 
00000344: E1A02005    ;     mov R2, R5 ;;active grid
00000348: EB000036    ;     bl saveGrid
0000034C:             ; 
0000034C: EBFFFFE8    ;     bl newline
00000350:             ; 
00000350: E28F0F89    ;     adrl R0, savedchoice
00000354: E2800B03    ; 
00000358: EF000003    ;     swi 3
0000035C:             ; 
0000035C: EF000001    ;     swi 1
00000360: EF000000    ;     swi 0
00000364: E3500059    ;     cmp R0, #'Y'
00000368:             ; 
00000368: E3A0000A    ;     ldr R0, =nl
0000036C: EF000000    ;     swi 0
00000370:             ; 
00000370: 0A000000    ;     beq stependfail
00000374: EA000001    ;     b stependsucc
00000378:             ; 
00000378:             ; stependfail
00000378: E3A00001    ;     mov R0, #1
0000037C: EA000000    ;     b stepend
00000380:             ; 
00000380:             ; stependsucc
00000380: E3A00000    ;     mov R0, #0
00000384:             ; 
00000384:             ; stepend
00000384: E8BD41F0    ;     pop {R14, R4-R8}
00000388: E1A0F00E    ;     mov R15, R14
0000038C:             ; 
0000038C:             ; listGrids
0000038C:             ; ;;INP in R0 is the ptr to the gridInfo struct
0000038C:             ; ;;RET --
0000038C:             ; ;;Grid info struct
0000038C:             ; ;;  - SaveInfoStruct* array
0000038C:             ; ;;  - int max size of arr
0000038C:             ; ;;  - int current position in arr
0000038C:             ; 
0000038C:             ; ;;loops through the array of grids (if any) printing their names, and dims, ask to print grid
0000038C: E92D47F0    ;     push {R14, R4-R10}
00000390:             ; 
00000390: E5904000    ;     ldr R4, [R0, #0] ;;get the array ptr
00000394: E5905008    ;     ldr R5, [R0, #8] ;;current position
00000398:             ; 
00000398: E3550000    ;     cmp R5, #0
0000039C: 0A00001C    ;     beq listGridsEmpty
000003A0:             ; 
000003A0:             ; ;;if current position == 1: print("There are no saved grids")
000003A0:             ; ;;for i from 0 to current position
000003A0:             ; ;;  getname(4)
000003A0:             ; ;;  getwidth(8)
000003A0:             ; ;;  getheight(9)
000003A0:             ; ;;  print("There is a grid called %s with dims (%d, %d)")
000003A0: E3A01000    ;     mov R1, #0 ;;i
000003A4: E3A0200C    ;     ldr R2, =sizeofSaveI
000003A8:             ; listGridsLoop
000003A8: E1510005    ;     cmp R1, R5
000003AC: 0A00001B    ;     beq listGridsLend
000003B0:             ; 
000003B0: E0234291    ;     mla R3, R1, R2, R4 ;;R3 = i * sizeof(saveInfo) + array
000003B4: E5936004    ;     ldr R6, [R3, #4] ;;load the name ptr
000003B8: E5D37008    ;     ldrb R7, [R3, #8] ;;load the width
000003BC: E5D38009    ;     ldrb R8, [R3, #9] ;;load the height
000003C0:             ; 
000003C0: E1A00001    ;     mov R0, R1
000003C4: EF000004    ;     swi 4
000003C8:             ; 
000003C8: E3A0003A    ;     mov R0, #':'
000003CC: EF000000    ;     swi 0
000003D0:             ; 
000003D0: E1A00006    ;     mov R0, R6
000003D4: EF000003    ;     swi 3
000003D8:             ; 
000003D8: EBFFFFC5    ;     bl newline
000003DC:             ; 
000003DC: E28F00F9    ;     adrl R0, gridloadpwidth
000003E0: E2800A01    ; 
000003E4: EF000003    ;     swi 3
000003E8:             ; 
000003E8: E1A00007    ;     mov R0, R7
000003EC: EF000004    ;     swi 4
000003F0:             ; 
000003F0: EBFFFFBF    ;     bl newline
000003F4:             ; 
000003F4: E28F00E9    ;     adrl R0, gridloadpheight
000003F8: E2800A01    ; 
000003FC: EF000003    ;     swi 3
00000400:             ; 
00000400: E1A00008    ;     mov R0, R8
00000404: EF000004    ;     swi 4
00000408:             ; 
00000408: EBFFFFB9    ;     bl newline
0000040C:             ; 
0000040C:             ;     ;;[[Prob]  Printing the grid uses the stored width and height, I could change it to use a p
                      ; assed in
0000040C:             ;     ;;             version but do the other areas have enough registers to cope? probably not.
0000040C:             ;     ;;             Would have to swap the width and height with the loaded versions - I really 
                      ; don't like this idea
0000040C:             ; 
0000040C: E2811001    ;     add R1, R1, #1
00000410:             ; 
00000410: EAFFFFE4    ;     b listGridsLoop
00000414:             ; 
00000414:             ; listGridsEmpty
00000414: E28F004B    ;     adrl R0, gridloadempty
00000418: E2800A01    ; 
0000041C: EF000003    ;     swi 3
00000420:             ; 
00000420:             ; listGridsLend
00000420:             ; listGridsEnd
00000420: E8BD47F0    ;     pop {R14, R4-R10}
00000424: E1A0F00E    ;     mov R15, R14
00000428:             ; 
00000428:             ; saveGrid
00000428:             ; ;;INP in R0 is the ptr gridInfo struct (in the main's stackframe)
00000428:             ; ;;INP in R1 is the char* to the name
00000428:             ; ;;INP in R2 is the active grid
00000428:             ; ;;RET in R0 is an errcode or 0 for success. 1 for malloc error
00000428:             ; 
00000428:             ; ;;if reachedCap -> realloc + inc maxsize
00000428:             ; ;;copy the current grid to another loc and place info in gridArr
00000428:             ; ;;inc current index
00000428: E92D47F0    ;     push {R14, R4-R10}
0000042C:             ; 
0000042C: E1A04000    ;     mov R4, R0
00000430: E1A05001    ;     mov R5, R1
00000434: E1A0A002    ;     mov R10, R2
00000438:             ; 
00000438: E5942008    ;     ldr R2, [R4, #8] ;;get the current index
0000043C: E5943004    ;     ldr R3, [R4, #4] ;;get the maxsize
00000440:             ; 
00000440: E1520003    ;     cmp R2, R3
00000444: 0A000000    ;     beq saveGridResize
00000448: EA00000D    ;     b saveGridAdd
0000044C:             ; 
0000044C:             ; saveGridResize
0000044C:             ;     ;;maxsize in R3
0000044C: E1A06083    ;     mov R6, R3, lsl #1 ;;double the capacity
00000450: E3A0700C    ;     ldr R7, =sizeofSaveI
00000454: E0070796    ;     mul R7, R6, R7 ;;get the number of bytes
00000458:             ; 
00000458: E1A00007    ;     mov R0, R7
0000045C: EB000214    ;     bl malloc ;;get the new grid
00000460:             ; 
00000460: E3500000    ;     cmp R0, #0 ;;if malloc failed then don't do any saving
00000464: 0A000020    ;     beq saveGridFailMalloc
00000468:             ; 
00000468: E1A01000    ;     mov R1, R0
0000046C: E1A08000    ;     mov R8, R0 ;;save of ptr
00000470:             ; 
00000470:             ;     ;;now that we have the new grid we need to memcpy the bytes from the original into the new 
                      ; one
00000470: E5940000    ;     ldr R0, [R4, #0] ;;get the array ptr
00000474:             ;     ;;R1 has the malloced address
00000474: E1A020A7    ;     mov R2, R7, lsr #1 ;;not great, this is the double cap halfed, means no mul again
00000478: EB000073    ;     bl memcpy
0000047C:             ; 
0000047C:             ;     ;;assume success because I didn't give memcpy an err code :)
0000047C:             ;     ;;need to store the new size and arr ptr in the gridinfo struct
0000047C:             ; 
0000047C: E5848000    ;     str R8, [R4, #0]
00000480: E5846004    ;     str R6, [R4, #4]
00000484:             ; 
00000484:             ; saveGridAdd
00000484:             ; ;;add the current grid to the array
00000484: E5946000    ;     ldr R6, [R4, #0] ;;get the arr ptr
00000488: E5947008    ;     ldr R7, [R4, #8] ;;get current index
0000048C:             ; 
0000048C:             ;     ;;ptr is 4 bytes
0000048C:             ;     ;;we're adding the struct of 
0000048C:             ;     ;;  |-grid*     (ptr)
0000048C:             ;     ;;  |-char*     (ptr)
0000048C:             ;     ;;  |-width     (byte)
0000048C:             ;     ;;  `-height    (byte)
0000048C:             ; 
0000048C:             ;     ;;we need to copy the current array
0000048C: E5DF89DB    ;     ldrb R8, width
00000490: E5DF99D8    ;     ldrb R9, height
00000494: E0080998    ;     mul R8, R8, R9 ;;get the number of bytes in grid
00000498:             ; 
00000498: E1A00008    ;     mov R0, R8
0000049C: EB000204    ;     bl malloc ;;allocate a new grid
000004A0:             ; 
000004A0: E3500000    ;     cmp R0, #0
000004A4: 0A000010    ;     beq saveGridFailMalloc
000004A8:             ; 
000004A8: E92D0100    ;     push {R8} ;; :(
000004AC:             ; 
000004AC: E3A0800C    ;     ldr R8, =sizeofSaveI
000004B0: E0266897    ;     mla R6, R7, R8, R6 ;;currentindex * sizeof(Gridinfo) + arrptr
000004B4: E5860000    ;     str R0, [R6, #0] ;;store the grid*
000004B8: E5865004    ;     str R5, [R6, #4] ;;store the char*
000004BC: E5DF89AB    ;     ldrb R8, width
000004C0: E5C68008    ;     strb R8, [R6, #8]
000004C4: E5C69009    ;     strb R9, [R6, #9]
000004C8:             ; 
000004C8: E8BD0100    ;     pop {R8}
000004CC:             ; 
000004CC: E1A01000    ;     mov R1, R0 ;;dst
000004D0: E1A0000A    ;     mov R0, R10 ;;src
000004D4: E1A02008    ;     mov R2, R8 ;;num bytes
000004D8: EB00005B    ;     bl memcpy ;;copy the grid into the new location
000004DC:             ; 
000004DC:             ;     ;;inc the position
000004DC: E5940008    ;     ldr R0, [R4, #8]
000004E0: E2800001    ;     add R0, R0, #1
000004E4: E5840008    ;     str R0, [R4, #8]
000004E8:             ; 
000004E8: EA000001    ;     b saveGridSucc
000004EC:             ; 
000004EC:             ; saveGridFailMalloc
000004EC: E3A00001    ;     mov R0, #1
000004F0: EA000000    ;     b saveGridEnd
000004F4:             ; 
000004F4:             ; saveGridSucc
000004F4: E3A00000    ;     mov R0, #0
000004F8:             ; 
000004F8:             ; saveGridEnd
000004F8: E8BD47F0    ;     pop {R14, R4-R10}
000004FC: E1A0F00E    ;     mov R15, R14
00000500:             ; 
00000500:             ; erase
00000500:             ; ;;INP in R0 is the itters
00000500:             ; ;;for (width * height + 1) * 2 + 1
00000500:             ; ;;      print('\b')
00000500: E1A01000    ;     mov R1, R0
00000504:             ; 
00000504:             ; eraseloop
00000504: E3510000    ;     cmp R1, #0
00000508: 0A000003    ;     beq eraseend
0000050C:             ; 
0000050C: E3A00008    ;     ldr R0, =backspace
00000510: EF000000    ;     swi 0
00000514:             ; 
00000514: E2411001    ;     sub R1, R1, #1
00000518: EAFFFFF9    ;     b eraseloop
0000051C:             ; 
0000051C:             ; eraseend
0000051C: E1A0F00E    ;     mov R15, R14
00000520:             ; 
00000520:             ; slow
00000520: E3A010FF    ;     mov R1, #0xFF
00000524: E1A01081    ;     mov R1, R1, lsl #1
00000528:             ; 
00000528:             ; slowloop
00000528: E3510000    ;     cmp R1, #0
0000052C: 0A000005    ;     beq slowend
00000530:             ; 
00000530: E3A00020    ;     mov R0, #' '
00000534: EF000000    ;     swi 0
00000538: E3A00008    ;     ldr R0, =backspace
0000053C: EF000000    ;     swi 0
00000540:             ; 
00000540: E2411001    ;     sub R1, R1, #1
00000544: EAFFFFF7    ;     b slowloop
00000548:             ; 
00000548:             ; slowend
00000548: E1A0F00E    ;     mov R15, R14
0000054C:             ; 
0000054C:             ; heapclean
0000054C:             ; ;;zero out all memory in the heap (debugging uses)
0000054C: E28F00AC    ;     adrl R0, heapstart
00000550: E2800A01    ; 
00000554: E3A01601    ;     ldr R1, =max_addr ;;stores the end of the heap
00000558: E3A02801    ;     ldr R2, =stack_size
0000055C: E0411002    ;     sub R1, R1, R2 ;; R1 = max_addr - stack_size which should be the heap end
00000560: E3C11003    ;     and R1, R1, #-4 ;;align to 4 byte boundry just in case
00000564: E3A03000    ;     mov R3, #0
00000568:             ; heapcleanloop ;;starting at heapstart
00000568: E1500001    ;     cmp R0, R1
0000056C: 0A000002    ;     beq heapcleanend
00000570: E5003000    ;     str R3, [R0] ;;store 0 in loc
00000574: E2800004    ;     add R0, R0, #4 ;;inc by a word
00000578: EAFFFFFA    ;     b heapcleanloop
0000057C:             ; heapcleanend
0000057C: E1A0F00E    ;     mov R15, R14
00000580:             ; 
00000580:             ; 
00000580:             ; strlen
00000580:             ; ;;INP in R0 is the address of the string
00000580:             ; ;;OUT in R0 is the length of the null terminated string
00000580:             ; 
00000580:             ; ;;len = 0
00000580:             ; ;;while(inp[len] != \0) {len++;}
00000580:             ; ;;return len
00000580:             ; 
00000580: E3A01000    ;     mov R1, #0 ;;len
00000584: E3500000    ;     cmp R0, #0
00000588: 0A000004    ;     beq strlenend
0000058C:             ; 
0000058C:             ; strlenloop
0000058C: E7D02001    ;     ldrb R2, [R0, R1]
00000590: E3520000    ;     cmp R2, #0
00000594: 0A000001    ;     beq strlenend
00000598: E2811001    ;     add R1, R1, #1
0000059C: EAFFFFFA    ;     b strlenloop
000005A0:             ; 
000005A0:             ; strlenend
000005A0: E1A00001    ;     mov R0, R1
000005A4: E1A0F00E    ;     mov R15, R14
000005A8:             ; 
000005A8:             ; strtoi
000005A8:             ; ;;INP in R0 is the address of the string
000005A8:             ; ;;OUT in R0 is the value created
000005A8:             ; ;;OUT in R1 is the err code
000005A8:             ; ;;
000005A8:             ; ;;ERR codes
000005A8:             ; ;;  0 is success
000005A8:             ; ;;  1 is attempted -ve
000005A8:             ; ;;  2 is use of non-numeric characters
000005A8:             ; ;;  3 is value out of range of integer
000005A8:             ; ;;  4 is null string given
000005A8:             ; 
000005A8:             ; ;;  example inp
000005A8:             ; ;;  12234       len = 5
000005A8:             ; ;;      ^-find end
000005A8:             ; ;;  tot = 0
000005A8:             ; ;;  for i from end to 0:
000005A8:             ; ;;      tot += inp[i] * (10 ** (len(inp) - i - 1))
000005A8:             ; ;;  +some checks for valid input
000005A8:             ; 
000005A8:             ; ;;This will take in an address to the start of a string and attempt to convert it into an integ
                      ; er
000005A8:             ; ;;String is only valid when all characters are numerical
000005A8:             ; ;;For now it does not accept -ve numbers
000005A8:             ; 
000005A8: E92D41F0    ;     push {R14, R4-R8}
000005AC: E1A04000    ;     mov R4, R0  ;;R4 holds the addr
000005B0:             ; 
000005B0: E3500000    ;     cmp R0, #0
000005B4: 03A01004    ;     moveq R1, #4
000005B8: 0A00001E    ;     beq strtoiendfail ;;null given so err code = 4 and end
000005BC:             ; 
000005BC: EBFFFFEF    ;     bl strlen
000005C0: E1A05000    ;     mov R5, R0  ;;R5 holds the len of the string
000005C4:             ; 
000005C4: E3550000    ;     cmp R5, #0
000005C8: 0A00001C    ;     beq strtoiendsucc ;;if len(string) == 0 then return 0
000005CC:             ; 
000005CC: E5D46000    ;     ldrb R6, [R4, #0]
000005D0: E356002D    ;     cmp R6, #45
000005D4: 0A000012    ;     beq strtoifailminus
000005D8:             ; 
000005D8: E3A06000    ;     mov R6, #0  ;;R6 holds the total
000005DC: E3A07001    ;     mov R7, #1  ;;R7 holds the **
000005E0: E2458001    ;     sub R8, R5, #1  ;;R8 is i which starts at end (len - 1)
000005E4: E3A0300A    ;     mov R3, #10 ;;mul to **
000005E8:             ; 
000005E8:             ; strtoiloop
000005E8: E3580000    ;     cmp R8, #0
000005EC: BA00000A    ;     blt strtoilend
000005F0:             ; 
000005F0: E7D42008    ;     ldrb R2, [R4, R8]
000005F4: E2422030    ;     sub R2, R2, #48
000005F8:             ; 
000005F8: E3520000    ;     cmp R2, #0
000005FC: BA00000C    ;     blt strtoifailnonnum
00000600: E3520009    ;     cmp R2, #9
00000604: CA00000A    ;     bgt strtoifailnonnum
00000608:             ; 
00000608: E0266792    ;     mla R6, R2, R7, R6 ;;total = (inp[i] * (**)) + total -> total += inp[i] * (**)
0000060C: 6A000006    ;     bvs strtoifailoutrange
00000610: E0070397    ;     mul R7, R7, R3
00000614:             ; 
00000614: E2488001    ;     sub R8, R8, #1
00000618:             ; 
00000618: EAFFFFF2    ;     b strtoiloop
0000061C:             ; 
0000061C:             ; 
0000061C:             ; ;;branches are expensive - should this just be rep RET? probably doesn't matter at this scale
0000061C:             ; strtoilend
0000061C: E1A00006    ;     mov R0, R6
00000620: EA000006    ;     b strtoiendsucc
00000624:             ; 
00000624:             ; strtoifailminus
00000624: E3A01001    ;     mov R1, #1
00000628: EA000002    ;     b strtoiendfail
0000062C:             ; 
0000062C:             ; strtoifailoutrange
0000062C: E3A01003    ;     mov R1, #3
00000630: EA000000    ;     b strtoiendfail
00000634:             ; 
00000634:             ; strtoifailnonnum
00000634: E3A01002    ;     mov R1, #2
00000638:             ; 
00000638:             ; strtoiendfail
00000638: E3A00000    ;     mov R0, #0
0000063C: EA000000    ;     b strtoiend
00000640:             ; 
00000640:             ; strtoiendsucc
00000640: E3A01000    ;     mov R1, #0
00000644:             ; 
00000644:             ; strtoiend
00000644: E8BD41F0    ;     pop {R14, R4-R8}
00000648: E1A0F00E    ;     mov R15, R14
0000064C:             ; 
0000064C:             ; memcpy
0000064C:             ; ;;INP in R0 is the addr of src
0000064C:             ; ;;INP in R1 is the addr of dst
0000064C:             ; ;;INP in R2 is the number of bytes to copy
0000064C:             ; 
0000064C:             ; ;;check if src and dst are alliged
0000064C:             ; ;;If different then write bytes
0000064C:             ; ;;If same then go to 4byte boundry
0000064C:             ; ;;  Write words of bytes2copy / 4
0000064C:             ; ;;  Write remaining bytes
0000064C: E92D41F0    ;     push {R14, R4-R8}
00000650:             ; 
00000650: E2004003    ;     and R4, R0, #0b11
00000654: E2015003    ;     and R5, R1, #0b11
00000658:             ; 
00000658: E1540005    ;     cmp R4, R5
0000065C: 1A00000E    ;     bne memcpyallbytes
00000660:             ; 
00000660:             ;     ;;If they are the same then cpy R4 bytes and then do words
00000660: E0422004    ;     sub R2, R2, R4;; bytes2cpy -= bytes we are about to write
00000664: E1A03004    ;     mov R3, R4
00000668: EB00000E    ;     bl memcpybytes
0000066C:             ; 
0000066C:             ;     ;;Now find the number of words that can be written i.e. bytes2cpy / 4 (bytes2cpy >> 2)
0000066C: E3C23003    ;     and R3, R2, #-4 ;;the number of bytes to write that make up the words
00000670: E3A04000    ;     mov R4, #0 ;;i
00000674:             ; memcpywordsloop
00000674: E1540003    ;     cmp R4, R3
00000678: 0A000003    ;     beq memcpywordslend
0000067C:             ; 
0000067C: E7906004    ;     ldr R6, [R0, R4]
00000680: E7816004    ;     str R6, [R1, R4]
00000684:             ;     
00000684: E2844004    ;     add R4, R4, #4
00000688:             ; 
00000688: EAFFFFF9    ;     b memcpywordsloop
0000068C:             ;     
0000068C:             ; memcpywordslend
0000068C:             ; ;;Now copy the remaining bytes
0000068C: E2022003    ;     and R2, R2, #0b11
00000690: E1A03002    ;     mov R3, R2
00000694: EB000003    ;     bl memcpybytes
00000698: EA00000A    ;     b memcpyend
0000069C:             ; 
0000069C:             ; memcpyallbytes
0000069C: E1A03002    ;     mov R3, R2
000006A0: EB000000    ;     bl memcpybytes
000006A4: EA000007    ;     b memcpyend
000006A8:             ; 
000006A8:             ; memcpybytes
000006A8:             ; ;;This is an internal function to memcpy and so doesn't follow the calling convention, it also 
                      ; assumes values are in place from memcpy
000006A8:             ; ;;for (int i = 0; i < byte2cpy; i++) {
000006A8:             ; ;;      *(dst + i) = *(src + i)
000006A8:             ; ;;INP in R3 is the number of bytes to copy
000006A8: E3A05000    ;     mov R5, #0 ;;i
000006AC:             ; memcpybytesloop
000006AC: E1550003    ;     cmp R5, R3
000006B0: 0A000003    ;     beq memcpybyteslend ;;i < bytes2cpy
000006B4:             ; 
000006B4: E7D04005    ;     ldrb R4, [R0, R5]
000006B8: E7C14005    ;     strb R4, [R1, R5] ;;dst[i] = src[i]
000006BC:             ; 
000006BC: E2855001    ;     add R5, R5, #1 ;;i++
000006C0:             ; 
000006C0: EAFFFFF9    ;     b memcpybytesloop
000006C4:             ; 
000006C4:             ; memcpybyteslend
000006C4: E1A0F00E    ;     mov R15, R14
000006C8:             ; 
000006C8:             ; memcpyend
000006C8: E8BD41F0    ;     pop {R14, R4-R8}
000006CC: E1A0F00E    ;     mov R15, R14
000006D0:             ; 
000006D0:             ; getstring
000006D0:             ; ;;INP in R0 the terminator character
000006D0:             ; ;;INP in R1 the max number of characters or -1 for no max
000006D0:             ; ;;INP in R2 boolean (non-0/0) for if letters should be printed out as well
000006D0:             ; ;;RET in R0 a ptr to the memory address
000006D0:             ; ;;
000006D0:             ; ;;Dynamically allocate memory to support large string
000006D0:             ; 
000006D0:             ; ;;buff = malloc(minBytes)
000006D0:             ; ;;while (input != terminator && pos < maxchars) 
000006D0:             ; ;;  buff[pos] = input
000006D0:             ; ;;  putchar(input)
000006D0:             ; ;;  if (pos > buffSize)
000006D0:             ; ;;      nBuff = malloc(buffSize << 1)
000006D0:             ; ;;      memcpy from buff to nBuff
000006D0:             ; ;;      free buff
000006D0:             ; ;;      buff = nBuff
000006D0:             ; 
000006D0: E92D47F0    ;     push {R14, R4-R10}
000006D4:             ; 
000006D4: E1A08000    ;     mov R8, R0 ;;now holds terminator
000006D8: E1A09001    ;     mov R9, R1 ;;nax chars
000006DC: E3590000    ;     cmp R9, #0
000006E0: 0A000031    ;     beq getstringEnd
000006E4:             ;     ;sub R9, R9, #1 ;;reduce by 1 to use later
000006E4: E1A0A002    ;     mov R10, R2 ;;print bool
000006E8:             ; 
000006E8: E3A06008    ;     ldr R6, =minBuffSize ;;R6 will hold the current size of the buffer
000006EC: E1A00006    ;     mov R0, R6
000006F0: EB00016F    ;     bl malloc
000006F4: E1A04000    ;     mov R4, R0 ;;R4 is the address of the buffer
000006F8:             ; 
000006F8: E3A05000    ;     mov R5, #0 ;;R5 is the loop counter/index into buffer
000006FC:             ; getstringloop
000006FC: E3790001    ;     cmp R9, #-1
00000700: 0A000001    ;     beq getstringloopskipsize
00000704: E1550009    ;     cmp R5, R9 ;;position - maxsize
00000708:             ;                       ;;pos 2 means 3 characters written
00000708: AA000019    ;     bge getstringlend ;;if position >= maxsize
0000070C:             ; getstringloopskipsize
0000070C: EF000001    ;     swi 1 ;;get input
00000710: E1500008    ;     cmp R0, R8 ;;is input == terminator character
00000714: 0A000016    ;     beq getstringlend
00000718:             ; 
00000718: E3790001    ;     cmp R9, #-1
0000071C: 0AFFFFFF    ;     beq skipMax
00000720:             ;     
00000720:             ; skipMax
00000720: E1550006    ;     cmp R5, R6
00000724: E92D0001    ;     push {R0}
00000728: AA000005    ;     bge getstringresize
0000072C:             ; 
0000072C:             ; getstringlcont
0000072C: E8BD0001    ;     pop {R0}
00000730: E7C40005    ;     strb R0, [R4, R5] ;;buff[pos] = input
00000734:             ; 
00000734: E35A0000    ;     cmp R10, #0
00000738: 1F000000    ;     swine 0 ;;output the character to the screen if R10 is not 0
0000073C:             ; 
0000073C: E2855001    ;     add R5, R5, #1
00000740:             ; 
00000740: EAFFFFED    ;     b getstringloop
00000744:             ; 
00000744:             ; getstringresize
00000744:             ;     ;;r6 will hold new buffer
00000744: E1A00086    ;     mov R0, R6, lsl #1
00000748: EB000159    ;     bl malloc
0000074C: E1A07000    ;     mov R7, R0
00000750:             ; 
00000750: E1A00004    ;     mov R0, R4 ;;old buff
00000754: E1A01007    ;     mov R1, R7 ;;newBuff
00000758: E1A02005    ;     mov R2, R5 ;;bytes to write
0000075C: EBFFFFBA    ;     bl memcpy
00000760:             ; 
00000760: E1A00004    ;     mov R0, R4
00000764: EB00017C    ;     bl free
00000768: E1A04007    ;     mov R4, R7
0000076C:             ; 
0000076C: E1A06086    ;     mov R6, R6, lsl #1
00000770:             ; 
00000770: EAFFFFED    ;     b getstringlcont
00000774:             ; 
00000774:             ; getstringlend
00000774:             ;     ;;need to add a \0
00000774:             ;     ;;need to check if the buffer is completely full -> resize buffer to +1? (will be aligned t
                      ; o 8 in malloc!) then copy
00000774:             ;     ;;I could have the buffers always leave a space open for the \0? but this is kind of an edg
                      ; e case?
00000774: E1550006    ;     cmp R5, R6 ;;position to size of buffer
00000778: 0A000000    ;     beq getstringResizeEnd
0000077C:             ; 
0000077C: EA00000A    ;     b getstringEnd
00000780:             ; 
00000780:             ; getstringResizeEnd
00000780: E2860001    ;     add R0, R6, #1
00000784: EB00014A    ;     bl malloc
00000788: E1A07000    ;     mov R7, R0
0000078C:             ; 
0000078C: E1A00004    ;     mov R0, R4;;old buff
00000790: E1A01007    ;     mov R1, R7;;new buff
00000794: E1A02005    ;     mov R2, R5;;bytes2write
00000798: EBFFFFAB    ;     bl memcpy
0000079C:             ; 
0000079C: E1A00004    ;     mov R0, R4
000007A0: EB00016D    ;     bl free
000007A4: E1A04007    ;     mov R4, R7
000007A8:             ; 
000007A8: E2866001    ;     add R6, R6, #1 ;;not needed
000007AC:             ; 
000007AC:             ; getstringEnd
000007AC: E3A00000    ;     mov R0, #0
000007B0: E7C40005    ;     strb R0, [R4, R5]
000007B4:             ; 
000007B4: E1A00004    ;     mov R0, R4
000007B8:             ; 
000007B8: E8BD47F0    ;     pop {R14, R4-R10}
000007BC: E1A0F00E    ;     mov R15, R14
000007C0:             ; 
000007C0:             ; tolower
000007C0:             ; ;;INP in R0 is a character
000007C0:             ; ;;OUT in R0 is the character.lower()
000007C0: E3800020    ;     orr R0, R0, #32
000007C4: E1A0F00E    ;     mov R15, R14
000007C8:             ; 
000007C8:             ; setupGrid
000007C8:             ; ;;INP --
000007C8:             ; ;;RET --
000007C8:             ; ;;The values addresses of the grids will now be set, can still be 0
000007C8:             ; ;; ask for generation mode
000007C8:             ; ;;      |-If random ask for seed
000007C8:             ; ;;      |   `-For generation roll the seed to create a pseudorandom value for each `pixel`
000007C8:             ; ;;      `-If draw then get them to draw the grid one `pixel` at a time
000007C8: E92D47F0    ;     push {R14, R4-R10}
000007CC:             ; 
000007CC:             ;     ;;generate the main grid
000007CC: E5DF669B    ;     ldrb R6, width
000007D0: E5DF7698    ;     ldrb R7, height
000007D4:             ; 
000007D4: E0000796    ;     mul R0, R6, R7 ;;width * height = num of bytes to malloc
000007D8:             ; 
000007D8: E1A05000    ;     mov R5, R0
000007DC: EB000134    ;     bl malloc
000007E0: E1A04000    ;     mov R4, R0
000007E4: E58F4678    ;     str R4, gridA
000007E8:             ; 
000007E8: E1A00005    ;     mov R0, R5
000007EC: EB000130    ;     bl malloc
000007F0: E58F0670    ;     str R0, gridB
000007F4:             ; 
000007F4: E3550000    ;     cmp R5, #0
000007F8: 0A00003A    ;     beq setupGridFail
000007FC: E3540000    ;     cmp R4, #0
00000800: 0A000038    ;     beq setupGridFail
00000804:             ; 
00000804:             ;     ;;R4 holds the gridA addr
00000804:             ;     ;;R6 holds the width
00000804:             ;     ;;R7 holds the height
00000804:             ; 
00000804: E28F00FE    ;     adrl R0, askgenoption
00000808: E2800C0A    ; 
0000080C: EF000003    ;     swi 3
00000810:             ; setupGridAsk
00000810: EF000001    ;     swi 1
00000814: E3800020    ;     orr R0, R0, #32
00000818:             ; 
00000818: E1A01000    ;     mov R1, R0
0000081C: EBFFFEB4    ;     bl newline
00000820:             ; 
00000820: E3510064    ;     cmp R1, #'d'
00000824: 0A000005    ;     beq setupdrawing
00000828:             ; 
00000828: E3510072    ;     cmp R1, #'r'
0000082C: 0A000005    ;     beq setuprandom
00000830:             ; 
00000830: E28F000B    ;     adrl R0, setupGrdFailmsg
00000834: E2800C0B    ; 
00000838: EF000003    ;     swi 3
0000083C: EAFFFFF3    ;     b setupGridAsk
00000840:             ; 
00000840:             ; setupdrawing
00000840: E3A09000    ;     mov R9, #0
00000844: EA000006    ;     b setupstart
00000848:             ; 
00000848:             ; setuprandom
00000848: E3A00000    ;     mov R0, #0
0000084C: E3A01004    ;     mov R1, #4
00000850: E3A02001    ;     mov R2, #1
00000854: EBFFFF9D    ;     bl getstring
00000858:             ; 
00000858: E1A08000    ;     mov R8, R0
0000085C:             ; 
0000085C: EBFFFEA4    ;     bl newline
00000860:             ; 
00000860: E3A09001    ;     mov R9, #1
00000864:             ; 
00000864:             ; setupstart
00000864:             ; ;;This is probably not a good way to do it as there is more branching in the middle of a loop t
                      ; hat is executed alot
00000864:             ; ;;I'm doing it this way `not because it is easy, but because I though it would be easy`
00000864:             ; ;;Reduces the need for writing another loop :)
00000864:             ; ;;R9 holds the mode (1 for random, 0 for draw)
00000864:             ; ;;R8 will hold the seed for random
00000864:             ; ;;for row from 0 to height - 1
00000864:             ; ;;  for col from 0 to width - 1
00000864:             ; ;;      if (random)
00000864:             ; ;;          grid[row][col] = ((seed rol 1) || row) && 1
00000864:             ; ;;      else
00000864:             ; ;;          grid[row][col] = input() == 1
00000864: E3A05000    ;     mov R5, #0 ;; row
00000868:             ; setuprowloop
00000868: E1550007    ;     cmp R5, R7
0000086C: 0A00001D    ;     beq setuprowlend
00000870:             ; 
00000870: E3A0A000    ;     mov R10, #0 ;;col
00000874:             ; setupcolloop
00000874: E15A0006    ;     cmp R10, R6
00000878: 0A000018    ;     beq setupcollend
0000087C:             ; 
0000087C: E3590001    ;     cmp R9, #1
00000880: 0A000000    ;     beq dorandom
00000884: EA000004    ;     b dodraw
00000888:             ; 
00000888:             ; ;;dorandom and dodraw will get their value for this position and then place it in R2
00000888:             ; ;;R3 is free at this point
00000888:             ; dorandom
00000888:             ;     ;;seed in R8
00000888: E1A080E8    ;     mov R8, R8, ror #1
0000088C: E00A3005    ;     and R3, R10, R5
00000890: E0288003    ;     eor R8, R8, R3
00000894: E2082001    ;     and R2, R8, #1
00000898: EA000009    ;     b setupcollcont
0000089C:             ; dodraw
0000089C:             ;     ;;get input, validate 1 or 0
0000089C:             ;     ;;if invalid print error loop back
0000089C:             ;     ;;-_- I've just realised I want to print the grid each time as well R0-R3 are scratch
0000089C: EF000001    ;     swi 1
000008A0:             ; 
000008A0: E3500031    ;     cmp R0, #'1'
000008A4: 0A000005    ;     beq dodrawsucc
000008A8: E3500030    ;     cmp R0, #'0'
000008AC: 0A000003    ;     beq dodrawsucc
000008B0:             ; 
000008B0: E28F0FC6    ;     adrl R0, drawfailmsg
000008B4: E2800B02    ; 
000008B8: EF000003    ;     swi 3
000008BC:             ; 
000008BC: EAFFFFF6    ;     b dodraw
000008C0:             ; 
000008C0:             ; dodrawsucc
000008C0: E2402030    ;     sub R2, R0, #48 ;;could be xor?
000008C4:             ; 
000008C4:             ; setupcollcont
000008C4:             ;     ;;place the value in R2 into the grid[row][col]
000008C4:             ;     ;;row * width + col
000008C4:             ; 
000008C4: E023A695    ;     mla R3, R5, R6, R10 ;;R3 = row * width + col
000008C8: E7C42003    ;     strb R2, [R4, R3] ;;grid offset by R3
000008CC:             ; 
000008CC: E3590000    ;     cmp R9, #0
000008D0: 01A00004    ;     moveq R0, R4
000008D4: 0B000005    ;     bleq drawgrid ;;print the new state of the grid if this is drawing mode
000008D8:             ; 
000008D8: E28AA001    ;     add R10, R10, #1
000008DC: EAFFFFE4    ;     b setupcolloop
000008E0:             ; setupcollend
000008E0: E2855001    ;     add R5, R5, #1
000008E4: EAFFFFDF    ;     b setuprowloop
000008E8:             ; setuprowlend
000008E8:             ;     ;;grid has been setup
000008E8:             ; 
000008E8:             ; setupGridFail
000008E8:             ; setupGridEnd
000008E8: E8BD47F0    ;     pop {R14, R4-R10}
000008EC: E1A0F00E    ;     mov R15, R14
000008F0:             ; 
000008F0:             ; 
000008F0:             ; ;;[[TODO]] the heap may not be blank (when heapclean is removed) and so need to 0 the mem. Mayb
                      ; e add option to malloc or add calloc (not the same)
000008F0:             ; drawgrid
000008F0:             ; ;;INP in R0 is the grid address to draw
000008F0:             ; 
000008F0:             ; ;;for row from 0 to height - 1
000008F0:             ; ;;  for col from 0 to width - 1
000008F0:             ; ;;      print('X' if grid[row][col] else '_')
000008F0:             ; ;;  print(newline)
000008F0:             ; ;;print(newline)
000008F0: E92D01F0    ;     push {R4-R8}
000008F4:             ; 
000008F4: E1A06000    ;     mov R6, R0
000008F8:             ; 
000008F8: E5DF456F    ;     ldrb R4, width
000008FC: E5DF556C    ;     ldrb R5, height
00000900:             ; 
00000900: E3A02000    ;     mov R2, #0 ;;row
00000904:             ; drawgridrowloop
00000904: E1520005    ;     cmp R2, R5
00000908: 0A000011    ;     beq drawgridrowlend
0000090C:             ; 
0000090C: E3A01000    ;     mov R1, #0 ;;col
00000910:             ; drawgridcolloop
00000910: E1510004    ;     cmp R1, R4
00000914: 0A000009    ;     beq drawgridcollend
00000918:             ; 
00000918: E0231492    ;     mla R3, R2, R4, R1 ;;R3 = row * width + col
0000091C: E7D63003    ;     ldrb R3, [R6, R3]
00000920:             ; 
00000920: E3530001    ;     cmp R3, #1
00000924: 03A00058    ;     moveq R0, #'X'
00000928: 13A0002D    ;     movne R0, #'-'
0000092C:             ; 
0000092C: EF000000    ;     swi 0
00000930:             ; 
00000930: E3A00020    ;     mov R0, #' '
00000934: EF000000    ;     swi 0
00000938:             ; 
00000938: E2811001    ;     add R1, R1, #1
0000093C: EAFFFFF3    ;     b drawgridcolloop
00000940:             ; 
00000940:             ; drawgridcollend
00000940: E3A01000    ;     mov R1, #0
00000944: E2822001    ;     add R2, R2, #1
00000948: E3A0000A    ;     mov R0, #10
0000094C: EF000000    ;     swi 0
00000950: EAFFFFEB    ;     b drawgridrowloop
00000954:             ; 
00000954:             ; drawgridrowlend
00000954: E3A0000A    ;     mov R0, #10
00000958: EF000000    ;     swi 0
0000095C:             ; drawgridend
0000095C: E8BD01F0    ;     pop {R4-R8}
00000960: E1A0F00E    ;     mov R15, R14
00000964:             ; 
00000964:             ; 
00000964:             ; setupOptions
00000964:             ; ;;INP in R0 is 1 if should ask for dims 0 for skip
00000964: E92D4010    ;     push {R14, R4}
00000968: E1A04000    ;     mov R4, R0
0000096C:             ; 
0000096C: E28F0D1D    ;     adrl R0, askdefaults ;;ask q
00000970: EF000003    ;     swi 3
00000974: EF000001    ;     swi 1   ;;get character answer
00000978: EF000000    ;     swi 0
0000097C: E3500059    ;     cmp R0, #'Y'
00000980: E3A0000A    ;     ldr R0, =nl
00000984: EF000000    ;     swi 0
00000988:             ; 
00000988: 1A00000E    ;     bne setupCustom
0000098C:             ; 
0000098C: E28F002A    ;     adrl R0, usingDefault
00000990: E2800C09    ; 
00000994: EF000003    ;     swi 3
00000998:             ; 
00000998: E3A00000    ;     mov R0, #0
0000099C: E5CF04C8    ;     strb R0, erase_b
000009A0: E5CF04C5    ;     strb R0, slow_b
000009A4: E3A00001    ;     mov R0, #1
000009A8: E5CF04BE    ;     strb R0, step_b
000009AC:             ; 
000009AC: E3540000    ;     cmp R4, #0
000009B0: 0A000002    ;     beq setupOptionsDSkipDims
000009B4:             ; 
000009B4: E3A00012    ;     mov R0, #18
000009B8: E5CF04AF    ;     strb R0, width
000009BC: E5CF04AC    ;     strb R0, height
000009C0:             ; 
000009C0:             ; setupOptionsDSkipDims
000009C0: E8BD4010    ;     pop {R14, R4}
000009C4: E1A0F00E    ;     mov R15, R14 ;;RET
000009C8:             ; 
000009C8:             ; setupCustom
000009C8:             ; ;;ask for erase, slow, step, and conditionally dims
000009C8:             ; 
000009C8:             ; ;;ask step
000009C8:             ; ;;ask erase
000009C8:             ; ;;if (!step)
000009C8:             ; ;;  if erase
000009C8:             ; ;;      print(recommend slow)
000009C8:             ; ;;  ask slow
000009C8:             ; 
000009C8: E3A01001    ;     mov R1, #1
000009CC:             ; 
000009CC: E28F0043    ;     adrl R0, askstep
000009D0: E2800C07    ; 
000009D4: EF000003    ;     swi 3
000009D8: EF000001    ;     swi 1
000009DC: EF000000    ;     swi 0 
000009E0: E3500059    ;     cmp R0, #'Y' 
000009E4: E3A0000A    ;     ldr R0, =nl
000009E8: EF000000    ;     swi 0
000009EC: 13A01000    ;     movne R1, #0
000009F0: E5CF1476    ;     strb R1, step_b
000009F4:             ; 
000009F4: E3A01001    ;     mov R1, #1
000009F8:             ; 
000009F8: E28F00E6    ;     adrl R0, askerase
000009FC: E2800C06    ; 
00000A00: EF000003    ;     swi 3
00000A04: EF000001    ;     swi 1
00000A08: EF000000    ;     swi 0
00000A0C: E3500059    ;     cmp R0, #'Y'
00000A10: E3A0000A    ;     ldr R0, =nl
00000A14: EF000000    ;     swi 0
00000A18: 13A01000    ;     movne R1, #0
00000A1C: E5CF1448    ;     strb R1, erase_b
00000A20:             ; 
00000A20: E5DF0446    ;     ldrb R0, step_b
00000A24: E3500001    ;     cmp R0, #1
00000A28: 0A00000F    ;     beq setupCustomskipslow
00000A2C:             ; 
00000A2C: E3510001    ;     cmp R1, #1 ;;if erase is on
00000A30: E28F0092    ;     adrl R0, warneraseslow
00000A34: E2800C07    ; 
00000A38: 0F000003    ;     swieq 3
00000A3C:             ; 
00000A3C: E3A01001    ;     mov R1, #1
00000A40:             ;  
00000A40: E28F00B7    ;     adrl R0, askslow
00000A44: E2800C06    ; 
00000A48: EF000003    ;     swi 3
00000A4C: EF000001    ;     swi 1
00000A50: EF000000    ;     swi 0 
00000A54: E3500059    ;     cmp R0, #'Y' 
00000A58: E3A0000A    ;     ldr R0, =nl
00000A5C: EF000000    ;     swi 0
00000A60: 13A01000    ;     movne R1, #0
00000A64: E5CF1401    ;     strb R1, slow_b
00000A68:             ; 
00000A68: EA000001    ;     b setupCustomDimsCheck
00000A6C:             ; 
00000A6C:             ; setupCustomskipslow
00000A6C: E3A00000    ;     mov R0, #0
00000A70: E5CF03F5    ;     strb R0, slow_b
00000A74:             ; 
00000A74:             ; setupCustomDimsCheck
00000A74: E3540000    ;     cmp R4, #0
00000A78: 0A00002F    ;     beq customend
00000A7C:             ; 
00000A7C: E28F0FE1    ;     adrl R0, askwid
00000A80: E2800B01    ; 
00000A84: EF000003    ;     swi 3
00000A88:             ;     
00000A88:             ; getwid
00000A88: E3A0000A    ;     ldr R0, =enter
00000A8C: E3A01002    ;     mov R1, #2
00000A90: E3A02001    ;     mov R2, #1
00000A94: EBFFFF0D    ;     bl getstring
00000A98: E1A04000    ;     mov R4, R0
00000A9C:             ; 
00000A9C: EBFFFEC1    ;     bl strtoi
00000AA0: E1A05000    ;     mov R5, R0
00000AA4:             ;     
00000AA4: E1A00004    ;     mov R0, R4
00000AA8: EB0000AB    ;     bl free ;;free the collected string
00000AAC:             ; 
00000AAC: E1A01005    ;     mov R1, R5
00000AB0:             ; 
00000AB0: EBFFFE0F    ;     bl newline
00000AB4:             ; 
00000AB4: E351001E    ;     cmp R1, #30
00000AB8: CA000003    ;     bgt getwidFail
00000ABC: E3510000    ;     cmp R1, #0
00000AC0: DA000001    ;     ble getwidFail
00000AC4:             ; 
00000AC4: E5CF13A3    ;     strb R1, width
00000AC8:             ; 
00000AC8: EA000003    ;     b getheisetup
00000ACC:             ; 
00000ACC:             ; getwidFail
00000ACC: E28F0071    ;     adrl R0, getwidfailmsg
00000AD0: E2800C07    ; 
00000AD4: EF000003    ;     swi 3
00000AD8:             ; 
00000AD8: EAFFFFEA    ;     b getwid
00000ADC:             ; 
00000ADC:             ; getheisetup
00000ADC: E28F0042    ;     adrl R0, askhei
00000AE0: E2800C07    ; 
00000AE4: EF000003    ;     swi 3
00000AE8:             ; 
00000AE8:             ; gethei
00000AE8: E3A0000A    ;     ldr R0, =enter
00000AEC: E3A01002    ;     mov R1, #2
00000AF0: E3A02001    ;     mov R2, #1
00000AF4: EBFFFEF5    ;     bl getstring
00000AF8: E1A04000    ;     mov R4, R0
00000AFC:             ; 
00000AFC: EBFFFEA9    ;     bl strtoi
00000B00: E1A05000    ;     mov R5, R0
00000B04:             ; 
00000B04: E1A00004    ;     mov R0, R4
00000B08: EB000093    ;     bl free
00000B0C:             ; 
00000B0C: E1A01005    ;     mov R1, R5
00000B10:             ; 
00000B10: EBFFFDF7    ;     bl newline
00000B14:             ; 
00000B14: E351001E    ;     cmp R1, #30
00000B18: CA000003    ;     bgt getheiFail
00000B1C: E3510000    ;     cmp R1, #0
00000B20: DA000001    ;     ble getheiFail
00000B24:             ; 
00000B24: E5CF1344    ;     strb R1, height
00000B28:             ; 
00000B28: EA000003    ;     b customend
00000B2C:             ; 
00000B2C:             ; getheiFail
00000B2C: E28F004D    ;     adrl R0, getheifailmsg
00000B30: E2800C07    ; 
00000B34: EF000003    ;     swi 3
00000B38:             ; 
00000B38: EAFFFFEA    ;     b gethei
00000B3C:             ; 
00000B3C:             ; customend
00000B3C: E8BD4010    ;     pop {R14, R4}
00000B40: E1A0F00E    ;     mov R15, R14 ;;RET
00000B44:             ; 
00000B44:             ; 
00000B44:             ; updategrid
00000B44:             ; ;;INP in R0 is the active grid
00000B44:             ; ;;INP in R1 is the passive grid
00000B44:             ; ;;passive grid is the one being updated based on the value in the activeGrid
00000B44:             ; ;;RET --
00000B44:             ; ;;for row from 0 to height - 1
00000B44:             ; ;;  for col from 0 to width - 1
00000B44:             ; ;;      int n = countNeighbours(activeGrid, row, col)
00000B44:             ; ;;      int s = activeGrid[row][col]
00000B44:             ; ;;      
00000B44:             ; ;;      if (s == alive)
00000B44:             ; ;;          passiveGrid[row][col] = n == 3 or n == 2
00000B44:             ; ;;      else
00000B44:             ; ;;          passiveGrid[row][col] = n == 3
00000B44:             ; 
00000B44:             ; ;;  R4 holds the row
00000B44:             ; ;;  R5 holds the col
00000B44:             ; ;;  R6 holds the width
00000B44:             ; ;;  R7 holds the height
00000B44:             ; ;;  R8 holds the active grid
00000B44:             ; ;;  R9 holds the passive grid
00000B44:             ; 
00000B44: E92D47F0    ;     push {R14, R4-R10}
00000B48:             ; 
00000B48: E5DF631F    ;     ldrb R6, width
00000B4C: E5DF731C    ;     ldrb R7, height
00000B50:             ; 
00000B50: E1A08000    ;     mov R8, R0
00000B54: E1A09001    ;     mov R9, R1
00000B58:             ; 
00000B58: E3A04000    ;     mov R4, #0 ;;row
00000B5C:             ; updategridrowloop
00000B5C: E1540007    ;     cmp R4, R7
00000B60: 0A00001A    ;     beq updategridrowlend
00000B64:             ; 
00000B64: E3A05000    ;     mov R5, #0 ;;col
00000B68:             ; updategridcolloop
00000B68: E1550006    ;     cmp R5, R6
00000B6C: 0A000014    ;     beq updategridccollend
00000B70:             ; 
00000B70: E1A00008    ;     mov R0, R8
00000B74: E1A01004    ;     mov R1, R4
00000B78: E1A02005    ;     mov R2, R5
00000B7C: EB000015    ;     bl countneighbours
00000B80:             ; 
00000B80: E0215694    ;     mla R1, R4, R6, R5 ;;R1 = row * width + col
00000B84: E7D82001    ;     ldrb R2, [R8, R1] ;;grid[R1]
00000B88:             ;     ;;R0 holds the n count
00000B88: E3520000    ;     cmp R2, #0
00000B8C: 0A000006    ;     beq updatedead
00000B90:             ; 
00000B90:             ; updatealive
00000B90: E3A03000    ;     mov R3, #0
00000B94: E3500003    ;     cmp R0, #3
00000B98: 03A03001    ;     moveq R3, #1
00000B9C: E3500002    ;     cmp R0, #2
00000BA0: 03A03001    ;     moveq R3, #1
00000BA4: E7C93001    ;     strb R3, [R9, R1]
00000BA8: EA000003    ;     b updatelcont
00000BAC:             ; 
00000BAC:             ; updatedead
00000BAC: E3A03001    ;     mov R3, #1
00000BB0: E3500003    ;     cmp R0, #3
00000BB4: 13A03000    ;     movne R3, #0
00000BB8: E7C93001    ;     strb R3, [R9, R1]
00000BBC:             ; 
00000BBC:             ; updatelcont
00000BBC: E2855001    ;     add R5, R5, #1
00000BC0: EAFFFFE8    ;     b updategridcolloop
00000BC4:             ; 
00000BC4:             ; updategridccollend
00000BC4: E3A05000    ;     mov R5, #0
00000BC8: E2844001    ;     add R4, R4, #1
00000BCC: EAFFFFE2    ;     b updategridrowloop
00000BD0:             ; 
00000BD0:             ; updategridrowlend
00000BD0:             ; updategridend
00000BD0: E8BD47F0    ;     pop {R14, R4-R10}
00000BD4: E1A0F00E    ;     mov R15, R14
00000BD8:             ; 
00000BD8:             ; 
00000BD8:             ; countneighbours
00000BD8:             ; ;;INP in R0 is the activeGrid
00000BD8:             ; ;;INP in R1 is the row
00000BD8:             ; ;;INP in R2 is the col
00000BD8:             ; ;;OUT in R0 is the number of neighbours
00000BD8:             ; 
00000BD8:             ; ;;offsets = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
00000BD8:             ; ;;tot = 0
00000BD8:             ; ;;for offset in offsets
00000BD8:             ; ;;  if (isinrange(row + offset[0], col + offset[1]))
00000BD8:             ; ;;      tot += grid[row + offset[0]][col + offset[1]]
00000BD8:             ; ;;return tot
00000BD8: E92D4FF0    ;     push {R14, R4-R11} ;;I used the fp before I knew it wasn't a general purpose one, its fine 
                      ; in this context anyway
00000BDC:             ; 
00000BDC: E28F4D09    ;     adrl R4, offsets ;;holds the offset
00000BE0:             ; 
00000BE0: E1A07000    ;     mov R7, R0
00000BE4: E1A08001    ;     mov R8, R1
00000BE8: E1A09002    ;     mov R9, R2
00000BEC: E3A0A000    ;     mov R10, #0 ;;R10 holds the total
00000BF0: E5DFB277    ;     ldrb R11, width;;R11 holds the width of the grid
00000BF4:             ; 
00000BF4: E3A03000    ;     mov R3, #0
00000BF8:             ; 
00000BF8:             ; countneighboursloop
00000BF8: E3530008    ;     cmp R3, #8 ;;change this ccheck to be for R4
00000BFC: 0A00000F    ;     beq countneighbourslend
00000C00:             ; 
00000C00: E4945004    ;     ldr R5, [R4], #4
00000C04: E4946004    ;     ldr R6, [R4], #4
00000C08:             ; 
00000C08: E0880005    ;     add R0, R8, R5
00000C0C: E0891006    ;     add R1, R9, R6
00000C10:             ; 
00000C10: E2833001    ;     add R3, R3, #1
00000C14:             ; 
00000C14: E92D0008    ;     push {R3} ;;I should probably be using a local var on the stack, but I don't yet know how t
                      ; o setup a stack frame properly
00000C18: EB00000B    ;     bl isinrange
00000C1C: E8BD0008    ;     pop {R3}
00000C20:             ; 
00000C20: E3500000    ;     cmp R0, #0
00000C24: 0A000004    ;     beq countneighboursskipadd
00000C28:             ; 
00000C28: E0880005    ;     add R0, R8, R5 ;;new row
00000C2C: E0891006    ;     add R1, R9, R6 ;;new col ;;can assume that R0, R1 haven't changed as isinrange doesn't edit
                      ;  them, but I'm going to for now
00000C30:             ; 
00000C30: E0201B90    ;     mla R0, R0, R11, R1 ;;find offset
00000C34: E7D70000    ;     ldrb R0, [R7, R0]
00000C38: E08AA000    ;     add R10, R10, R0 ;;tot += grid[newrow][newcol]
00000C3C:             ; 
00000C3C:             ; countneighboursskipadd
00000C3C: EAFFFFED    ;     b countneighboursloop
00000C40:             ; 
00000C40:             ; countneighbourslend
00000C40:             ; countneighboursend
00000C40: E1A0000A    ;     mov R0, R10
00000C44: E8BD4FF0    ;     pop {R14, R4-R11}
00000C48: E1A0F00E    ;     mov R15, R14
00000C4C:             ; 
00000C4C:             ; 
00000C4C:             ; isinrange
00000C4C:             ; ;;INP in R0 is the row
00000C4C:             ; ;;INP in R1 is the col
00000C4C:             ; ;;Uses defined width and height
00000C4C:             ; ;;RET in R0 is 1 if is in range else 0
00000C4C: E3A02001    ;     mov R2, #1 ;;is valid unless...
00000C50:             ; 
00000C50: E3500000    ;     cmp R0, #0
00000C54: BA000009    ;     blt isinrangefail
00000C58:             ; 
00000C58: E3510000    ;     cmp R1, #0
00000C5C: BA000007    ;     blt isinrangefail
00000C60:             ; 
00000C60: E5DF3207    ;     ldrb R3, width
00000C64: E1510003    ;     cmp R1, R3
00000C68: AA000004    ;     bge isinrangefail
00000C6C:             ; 
00000C6C: E5DF31FC    ;     ldrb R3, height
00000C70: E1500003    ;     cmp R0, R3
00000C74: AA000001    ;     bge isinrangefail
00000C78:             ; 
00000C78: E3A00001    ;     mov R0, #1
00000C7C: EA000000    ;     b isinrangeend
00000C80:             ; 
00000C80:             ; isinrangefail
00000C80: E3A00000    ;     mov R0, #0
00000C84:             ; 
00000C84:             ; isinrangeend
00000C84: E1A0F00E    ;     mov R15, R14
00000C88:             ; 
00000C88:             ; 
00000C88:             ; ;; The heap will be a linked list of free blocks - unlike the Comodo version which stores both 
                      ; free & taken blocks 
00000C88:             ; ;; This is an idea I'm stealing from the C programming book
00000C88:             ; ;; Crate structure
00000C88:             ; ;;  |-ptr to next crate (1 word)
00000C88:             ; ;;  |-ptr to prev crate (1 word)
00000C88:             ; ;;  `-Size (bytes)      (1 word)
00000C88:             ; ;; 
00000C88:             ; 
00000C88:             ; ;;  Traversal of the heap
00000C88:             ; ;;  Unlink in my Comodo implimentation the heap is not a linked list of all Crates (free or not
                      ; )
00000C88:             ; ;;  That made traversing the heap for debugging purposes very easy, in this case taken crates d
                      ; o not point to the next
00000C88:             ; ;;  Instead could start at head and then just go to addr + sizeof(Crate) + size. This should ta
                      ; ke us to the next crate, free or not
00000C88:             ; ;;  
00000C88:             ; setupHeap
00000C88:             ; ;;NO INP
00000C88:             ; ;;NO OUT
00000C88:             ;     ;;we have the heapstart
00000C88:             ;     ;;the end of the heap will be 0x100000 (it will overlap with the stack :) )
00000C88: E59F0190    ;     ldr R0, heaphead ;;stores the mem addr of the start of the heap
00000C8C: E3A01601    ;     ldr R1, =max_addr ;;stores the end of the heap
00000C90: E3A02801    ;     ldr R2, =stack_size
00000C94: E0411002    ;     sub R1, R1, R2
00000C98:             ; 
00000C98: E0411000    ;     sub R1, R1, R0  ;;HEAPEND - HEAPSTART = TOTAL STORAGE (bytes)
00000C9C: E241100C    ;     sub R1, R1, #12 ;;SIZE -= SIZEOF(CRATE) (12 bytes)
00000CA0: E5801008    ;     str R1, [R0, #8] ;;set the size of the crate
00000CA4: E3A01000    ;     mov R1, #0
00000CA8: E5801004    ;     str R1, [R0, #4] ;;set the prev ptr
00000CAC: E5801000    ;     str R1, [R0, #0] ;;set the next ptr
00000CB0:             ; 
00000CB0: E1A0F00E    ;     mov R15, R14
00000CB4:             ; 
00000CB4:             ; ;; The heap is a linked list of free Crates and so find the header and then go though until one
                      ;  satifies the size requirement
00000CB4:             ; ;;  end if next is 0
00000CB4:             ; ;;  once found either take over the crate or split it into two new crates
00000CB4:             ; ;;  align the bytes amount to 8 byte boundry
00000CB4:             ; malloc
00000CB4:             ; ;;INP into R0 bytes to allocate
00000CB4:             ; ;;OUT into R0 the ptr to the memory or 0 for no memory allocated
00000CB4:             ;     ;;step 1 align the bytes
00000CB4:             ;     ;;1001010 & 0111 = 0000010 ;2
00000CB4:             ;     ;;if 0 goto alignend
00000CB4:             ;     ;;1001010 + (8 - 2)
00000CB4: E92D0010    ;     push {R4}
00000CB8:             ; 
00000CB8: E2001007    ;     and R1, R0, #0b0111
00000CBC: E3510000    ;     cmp R1, #0
00000CC0: 0A000002    ;     beq mallignend
00000CC4: E3A03008    ;     mov R3, #0b1000
00000CC8: E0432001    ;     sub R2, R3, R1
00000CCC: E0800002    ;     add R0, R0, R2
00000CD0:             ; 
00000CD0:             ; mallignend
00000CD0: E59F1148    ;     ldr R1, heaphead ;;stores a ptr to the first block
00000CD4:             ;     
00000CD4:             ; checkcrate
00000CD4: E5912008    ;     ldr R2, [R1, #8] ;;Size of the crate
00000CD8: E1500002    ;     cmp R0, R2 ;;bytes needed - bytes in crate
00000CDC: DA000006    ;     ble foundcrate
00000CE0: E5912000    ;     ldr R2, [R1, #0] ;;get the next ptr
00000CE4: E3520000    ;     cmp R2, #0
00000CE8: 0A000001    ;     beq nocrates
00000CEC: E1A01002    ;     mov R1, R2 ;;swap the current crate with the next crate
00000CF0: EAFFFFF7    ;     b checkcrate
00000CF4:             ; nocrates
00000CF4: E3A00000    ;     mov R0, #0
00000CF8: EA000015    ;     b mallocEnd
00000CFC:             ; 
00000CFC:             ; foundcrate
00000CFC:             ;     ;;Once a crate that we can use has been found we need to either split the crate or use the 
                      ; crate
00000CFC:             ;     ;;We should use the whole crate only when its size < bytesneeded + CrateHeader + 8
00000CFC:             ;     ;;This would give the edge case crate 8 bytes
00000CFC:             ;     
00000CFC:             ;     ;;R1 holds the found crate ptr
00000CFC:             ;     ;;R0 is the bytes requested and aligned
00000CFC: E2802014    ;     add R2, R0, #20 ;;A crate header is 12 bytes + the extra 8 bytes minimum
00000D00: E5913008    ;     ldr R3, [R1, #8]
00000D04: E1530002    ;     cmp R3, R2
00000D08: BA00000C    ;     blt usecrate
00000D0C:             ; splitcrate
00000D0C:             ;     ;;In this case we have a large crate that should be split up.
00000D0C:             ;     ;;ATM the crate will just be split up to where the requested memory is at the end of the fr
                      ; ee Crate.
00000D0C:             ; 
00000D0C: E5913008    ;     ldr R3, [R1, #8] ;;The size of the toSplit Crate
00000D10: E0433000    ;     sub R3, R3, R0 ;; size - bytesRequested
00000D14: E243300C    ;     sub R3, R3, #12 ;; size - bytesRequested - sizeof(Crate)
00000D18: E5813008    ;     str R3, [R1, #8] ;;toSplit->size = newSize
00000D1C:             ; 
00000D1C: E0833001    ;     add R3, R3, R1 ;; newSize + toSplit.addr
00000D20: E283400C    ;     add R4, R3, #12 ;; newSize + toSplit.addr + sizeof(Crate) = position of new Crate
00000D24:             ; 
00000D24:             ;     ;;Setup the header for the newCrate
00000D24: E3A02000    ;     mov R2, #0
00000D28: E5842000    ;     str R2, [R4, #0] ;;next = 0
00000D2C: E5842004    ;     str R2, [R4, #4] ;;prev = 0
00000D30: E5840008    ;     str R0, [R4, #8] ;;size = requested and aligned
00000D34:             ; 
00000D34:             ;     ;;MAYBE: can the crates that are taken have a smaller header than those that are free. Take
                      ; n crates need not store the next, prev free nodes
00000D34:             ;     ;;This may complicate things as size would need to be moved around and the size from taken 
                      ; to free would be different. 
00000D34:             ; 
00000D34: E284400C    ;     add R4, R4, #12
00000D38:             ; 
00000D38: E1A00004    ;     mov R0, R4
00000D3C:             ; 
00000D3C: EA000004    ;     b mallocEnd
00000D40:             ; 
00000D40:             ; usecrate
00000D40:             ;     ;; Simplest option as we can just remove it from the list
00000D40:             ;     ;; c1 <-> c2 <-> c3 ==> c1 <-> c3
00000D40: E5912000    ;     ldr R2, [R1, #0] ;;next ptr
00000D44: E5913004    ;     ldr R3, [R1, #4] ;;prev ptr
00000D48: E5823004    ;     str R3, [R2, #4] ;;Store c1 into c3's previous
00000D4C: E5832000    ;     str R2, [R3, #0] ;;Store c3 into c1's next
00000D50:             ; 
00000D50: E1A00001    ;     mov R0, R1 ;;move the found crate's address into the return register ;;The crate header is 
                      ; no longer needed
00000D54:             ; 
00000D54:             ; mallocEnd
00000D54: E8BD0010    ;     pop {R4}
00000D58: E1A0F00E    ;     mov R15, R14
00000D5C:             ; 
00000D5C:             ; free
00000D5C:             ; ;;INP in R0 is the mem addr of the data to be freed
00000D5C:             ; ;;OUT in R0 is the success code - 0 for mem freed, ¬0 for error ;;probably won't be currently 
                      ; used `=(- -)=' 
00000D5C:             ;     ;;In order to free memory we need to add it back to the linked list
00000D5C:             ;     ;;Following K&R's version the linked list will be ordered by address this will make finding
                      ;  consecutive memory locations that should be combined easier
00000D5C:             ; 
00000D5C:             ;     ;;The inputted address of the crate is the address given in malloc and so the start of the 
                      ; crate is that addr - sizeof(Crate) (#12)
00000D5C:             ; 
00000D5C:             ;     ;;heapHead = first Crate
00000D5C:             ;     ;;current = heapHead
00000D5C:             ;     ;;while (toFree.addr > current.addr)
00000D5C:             ;     ;;  current = current.next
00000D5C:             ;     ;;
00000D5C:             ;     ;;//Add the toFree Crate inbetween the current and its previous i.e.  A<->B<->C, toFree = D
                      ;  (addr < C, addr > B) ==> A<->B<->D<->C
00000D5C:             ;     ;;current->prev->next = toFree
00000D5C:             ;     ;;toFree->prev = current.prev
00000D5C:             ;     ;;current->prev = toFree
00000D5C:             ;     ;;toFree->next = current
00000D5C:             ; 
00000D5C:             ;     ;; Crate structure
00000D5C:             ;     ;;  |-ptr to next crate (1 word)
00000D5C:             ;     ;;  |-ptr to prev crate (1 word)
00000D5C:             ;     ;;  `-Size (bytes)      (1 word)
00000D5C:             ; 
00000D5C: E92D01F0    ;     push {R4-R8}
00000D60:             ; 
00000D60: E59F10B8    ;     ldr R1, heaphead ;;R1 will hold the current
00000D64: E240000C    ;     sub R0, R0, #12 ;;subtract sizeof(Crate) to get header pointer
00000D68:             ; freeloop
00000D68: E5912000    ;     ldr R2, [R1, #0] ;;load the ptr to the next
00000D6C: E1520000    ;     cmp R2, R0 ;;compare the address of the toFree to the address of current->next
00000D70:             ; 
00000D70: AA000003    ;     bge freelend ;;current->next.addr >= toFree.addr
00000D74:             ; 
00000D74: E3520000    ;     cmp R2, #0 ;;If there are no more Crates to the right then this could be a new Crate at the
                      ;  end or |F|T| it should merge left 
00000D78: 0A000009    ;     beq freelendEnd
00000D7C:             ; 
00000D7C: E1A01002    ;     mov R1, R2 ;;current = current.next
00000D80:             ; 
00000D80: EAFFFFF8    ;     b freeloop
00000D84:             ; 
00000D84:             ; freelend
00000D84:             ;     ;; R1 holds the current (left)
00000D84:             ;     ;; R2 holds the c->next (right)
00000D84: E5912000    ;     ldr R2, [R1, #0]
00000D88:             ; 
00000D88:             ;     ;;Setup the ptrs for the crates this will help later on   left<->toFree<->right ;;left,righ
                      ; t can be 0
00000D88:             ;     ;;We're just adding the new crate to the linked list
00000D88:             ;     ;;current->next->prev = toFree
00000D88:             ;     ;;toFree->next = current->next
00000D88:             ;     ;;current->next = toFree
00000D88:             ;     ;;toFree->prev = current
00000D88:             ; 
00000D88: E5913000    ;     ldr R3, [R1, #0] ;;holds current->next
00000D8C: E3530000    ;     cmp R3, #0
00000D90: 15830004    ;     strne R0, [R3, #4] ;;current->next->prev = toFree
00000D94: E5803000    ;     str R3, [R0, #0] ;;toFree->next = current->next
00000D98: E5810000    ;     str R0, [R1, #0] ;;current->next = toFree
00000D9C: E5801004    ;     str R1, [R0, #4] ;;toFree->prev = current
00000DA0:             ; 
00000DA0: EA000001    ;     b freeMergeCheck
00000DA4:             ; 
00000DA4:             ; freelendEnd
00000DA4:             ; ;;If there are no more Crates to the right then this could be a new Crate at the end or |F|T| i
                      ; t should merge left 
00000DA4:             ; ;;Found a crate (current) that is to the left of the crate as we ran out of ->next ptrs
00000DA4:             ; ;;Need to set current->next = toFree
00000DA4:             ; ;;            toFree->prev = current
00000DA4: E5801004    ;     str R1, [R0, #4] ;;toFree->prev = current
00000DA8: E5810000    ;     str R0, [R1, #0] ;;current->next = toFree
00000DAC:             ; 
00000DAC:             ; freeMergeCheck
00000DAC:             ;     ;;We have a ptr to current. This should be the closest Crate to the left of toFree
00000DAC:             ;     ;;We also have the next Crate (null or not) which is to the right of toFree
00000DAC:             ;     ;;Both of these crates MAY need to be merged but could also have taken crates in between
00000DAC:             ;     ;;First is to check if the crates are adjacent
00000DAC:             ;     ;;  If they are NOT then create a newCrate
00000DAC:             ;     ;;  If they are     then merge both
00000DAC:             ;     ;;  If only one     then merge either left or right
00000DAC:             ; 
00000DAC:             ;     ;;R1 will be left
00000DAC:             ;     ;;R2 will be right
00000DAC:             ; 
00000DAC: E3510000    ;     cmp R1, #0
00000DB0: 01A01000    ;     moveq R1, R0 ;;If there is no left crate then left=toFree
00000DB4: E3520000    ;     cmp R2, #0
00000DB8: 01A02000    ;     moveq R2, R0 ;;If there is no right crate (more likely) then right=toFree
00000DBC:             ; 
00000DBC:             ; verifyLeft
00000DBC:             ;     ;;Check if the left is adjacent
00000DBC:             ;     ;;It will be if (left.addr + sizeof(Crate) + left.size == toFree.addr)
00000DBC:             ; 
00000DBC: E5913008    ;     ldr R3, [R1, #8]
00000DC0: E283300C    ;     add R3, R3, #12 ;;12 is sizeof(Crate) + toFree.size
00000DC4: E0833001    ;     add R3, R3, R1 ;;left.addr + left->size ??
00000DC8:             ; 
00000DC8: E1530000    ;     cmp R3, R0
00000DCC: 11A01000    ;     movne R1, R0
00000DD0:             ; 
00000DD0:             ; verifyRight
00000DD0:             ;     ;;Going from toFree to Right
00000DD0: E5903008    ;     ldr R3, [R0, #8] ;;get size of toFree
00000DD4: E283300C    ;     add R3, R3, #12 ;;12 is sizeof(Crate) + toFree.size
00000DD8: E0833000    ;     add R3, R3, R0 ;; + toFree.addr
00000DDC:             ; 
00000DDC: E1530002    ;     cmp R3, R2
00000DE0: 11A02000    ;     movne R2, R0
00000DE4:             ; 
00000DE4:             ; merge
00000DE4:             ;     ;;Merge the two Crates given in R1 and R2
00000DE4:             ;     ;;left can be (left) or (toFree)
00000DE4:             ;     ;;right can be (right) or (toFree)
00000DE4:             ;     ;;If left == right: don't merge; create new Crate
00000DE4:             ;     ;;If left != right: then add to left's size
00000DE4:             ; 
00000DE4: E1510002    ;     cmp R1, R2
00000DE8: 0A00000A    ;     beq mergeNew
00000DEC:             ; 
00000DEC:             ;     ;;The new size is right.addr - left.addr + right->size    from right.addr - left.addr - siz
                      ; eof(Crate) + sizeof(Crate) + right->size
00000DEC:             ;     ;;                                                               |left      |right
00000DEC:             ;     ;;                                                               |<12>|size||<12>|size|
00000DEC:             ;     ;;
00000DEC:             ;     ;;                                                               |left      
00000DEC:             ;     ;;                                                               |<12>|size           |
00000DEC:             ;     ;;
00000DEC:             ;     ;;I'm doing it this way as the left and right may not be contiguous i.e. if toFree has a fr
                      ; ee crate on either side
00000DEC:             ; 
00000DEC: E0423001    ;     sub R3, R2, R1
00000DF0: E5924008    ;     ldr R4, [R2, #8]
00000DF4: E0833004    ;     add R3, R3, R4
00000DF8: E5813008    ;     str R3, [R1, #8]
00000DFC:             ; 
00000DFC:             ;     ;;Time to switch some ptrs
00000DFC:             ;     ;;Current state left.prev<->left<->right<->right.next (with left or right = toFree) or left
                      ; .prev<->left<->toFree<->right<->right.next
00000DFC:             ;     ;;New state would be left.prev<->left<->right.next (with left or right = toFree) or left.pr
                      ; ev<->left<->right.next
00000DFC:             ;     ;;Both cases end the same, so get right.next. These could be 0 but it doesn't matter
00000DFC:             ;     ;;Next need to change the prev and next ptrs for adjacent Crates
00000DFC:             ;     ;;i.e. right->next->prev = left
00000DFC:             ; 
00000DFC: E5924000    ;     ldr R4, [R2, #0] ;;right->next
00000E00: E1540001    ;     cmp R4, R1
00000E04: 15814000    ;     strne R4, [R1, #0] ;;left->next = right->next
00000E08: 13A04000    ;     movne R4, #0
00000E0C: 15814000    ;     strne R4, [R1, #0]
00000E10:             ; 
00000E10: E3540000    ;     cmp R4, #0
00000E14: 15841004    ;     strne R1, [R4, #4] ;;right->next->prev = left
00000E18:             ; 
00000E18:             ; mergeNew
00000E18:             ;     ;;The crate has already been setup with its ptrs and had its size as well so don't need to 
                      ; do anything
00000E18:             ; 
00000E18:             ; freeEnd
00000E18: E8BD01F0    ;     pop {R4-R8}
00000E1C: E1A0F00E    ;     mov R15, R14
00000E20:             ; 
00000E20:             ; align
00000E20:             ; ;;Integer defs
00000E20: 00010000    ; heaphead        defw 0x10000 ;;default start changed to addr of heapstart
00000E24: FFFFFFFF    ; offsets         defw -1,-1,-1,0,-1,1,0,-1,0,1,1,-1,1,0,1,1 ;;[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1
00000E28: FFFFFFFF    ; ],[1,-1],[1,0],[1,1]]
00000E2C: FFFFFFFF    ; 
00000E30: 00000000    ; 
00000E34: FFFFFFFF    ; 
00000E38: 00000001    ; 
00000E3C: 00000000    ; 
00000E40: FFFFFFFF    ; 
00000E44: 00000000    ; 
00000E48: 00000001    ; 
00000E4C: 00000001    ; 
00000E50: FFFFFFFF    ; 
00000E54: 00000001    ; 
00000E58: 00000000    ; 
00000E5C: 00000001    ; 
00000E60: 00000001    ; 
00000E64:             ; 
00000E64:             ; ;;Grid addresses
00000E64: 00000000    ; gridA           defw 0
00000E68: 00000000    ; gridB           defw 0
00000E6C:             ; 
00000E6C:             ; ;;options
00000E6C: 00          ; erase_b         defb 0
00000E6D: 00          ; slow_b          defb 0
00000E6E: 00          ; step_b          defb 0
00000E6F: 12          ; width           defb 18
00000E70: 12          ; height          defb 18
00000E71:             ; 
00000E71:             ; ;;String defs -- The naming scheme is bad :(
00000E71: 2D 2D 2D 2D ; welcomemsg      defb "-----------Welcome to JCGOL in ARM32-----------", nl, 0
00000E75: 2D 2D 2D 2D ; 
00000E79: 2D 2D 2D 57 ; 
00000E7D: 65 6C 63 6F ; 
00000E81: 6D 65 20 74 ; 
00000E85: 6F 20 4A 43 ; 
00000E89: 47 4F 4C 20 ; 
00000E8D: 69 6E 20 41 ; 
00000E91: 52 4D 33 32 ; 
00000E95: 2D 2D 2D 2D ; 
00000E99: 2D 2D 2D 2D ; 
00000E9D: 2D 2D 2D 0A ; 
00000EA1: 00          ; 
00000EA2: 54 6F 20 73 ; welcome2msg     defb "To start a new board press n\nTo load a saved board press l\nTo quit pres
00000EA6: 74 61 72 74 ; s q", nl, 0
00000EAA: 20 61 20 6E ; 
00000EAE: 65 77 20 62 ; 
00000EB2: 6F 61 72 64 ; 
00000EB6: 20 70 72 65 ; 
00000EBA: 73 73 20 6E ; 
00000EBE: 0A 54 6F 20 ; 
00000EC2: 6C 6F 61 64 ; 
00000EC6: 20 61 20 73 ; 
00000ECA: 61 76 65 64 ; 
00000ECE: 20 62 6F 61 ; 
00000ED2: 72 64 20 70 ; 
00000ED6: 72 65 73 73 ; 
00000EDA: 20 6C 0A 54 ; 
00000EDE: 6F 20 71 75 ; 
00000EE2: 69 74 20 70 ; 
00000EE6: 72 65 73 73 ; 
00000EEA: 20 71 0A 00 ; 
00000EEE: 49 6E 76 61 ; mainchoicefail  defb "Invalid choice please enter 'n' for new board or 'l' for load a board or 
00000EF2: 6C 69 64 20 ; 'q' to close. Not cases sensative", nl, 0
00000EF6: 63 68 6F 69 ; 
00000EFA: 63 65 20 70 ; 
00000EFE: 6C 65 61 73 ; 
00000F02: 65 20 65 6E ; 
00000F06: 74 65 72 20 ; 
00000F0A: 27 6E 27 20 ; 
00000F0E: 66 6F 72 20 ; 
00000F12: 6E 65 77 20 ; 
00000F16: 62 6F 61 72 ; 
00000F1A: 64 20 6F 72 ; 
00000F1E: 20 27 6C 27 ; 
00000F22: 20 66 6F 72 ; 
00000F26: 20 6C 6F 61 ; 
00000F2A: 64 20 61 20 ; 
00000F2E: 62 6F 61 72 ; 
00000F32: 64 20 6F 72 ; 
00000F36: 20 27 71 27 ; 
00000F3A: 20 74 6F 20 ; 
00000F3E: 63 6C 6F 73 ; 
00000F42: 65 2E 20 4E ; 
00000F46: 6F 74 20 63 ; 
00000F4A: 61 73 65 73 ; 
00000F4E: 20 73 65 6E ; 
00000F52: 73 61 74 69 ; 
00000F56: 76 65 0A 00 ; 
00000F5A: 53 6C 6F 77 ; helpmsg         defb "Slow mode will create a pause between each grid print to make it more rea
00000F5E: 20 6D 6F 64 ; dable - can't use with step mode\nErase mode will erase the previous board before printing the 
00000F62: 65 20 77 69 ; next - [is 2x slower]\n", 0
00000F66: 6C 6C 20 63 ; 
00000F6A: 72 65 61 74 ; 
00000F6E: 65 20 61 20 ; 
00000F72: 70 61 75 73 ; 
00000F76: 65 20 62 65 ; 
00000F7A: 74 77 65 65 ; 
00000F7E: 6E 20 65 61 ; 
00000F82: 63 68 20 67 ; 
00000F86: 72 69 64 20 ; 
00000F8A: 70 72 69 6E ; 
00000F8E: 74 20 74 6F ; 
00000F92: 20 6D 61 6B ; 
00000F96: 65 20 69 74 ; 
00000F9A: 20 6D 6F 72 ; 
00000F9E: 65 20 72 65 ; 
00000FA2: 61 64 61 62 ; 
00000FA6: 6C 65 20 2D ; 
00000FAA: 20 63 61 6E ; 
00000FAE: 27 74 20 75 ; 
00000FB2: 73 65 20 77 ; 
00000FB6: 69 74 68 20 ; 
00000FBA: 73 74 65 70 ; 
00000FBE: 20 6D 6F 64 ; 
00000FC2: 65 0A 45 72 ; 
00000FC6: 61 73 65 20 ; 
00000FCA: 6D 6F 64 65 ; 
00000FCE: 20 77 69 6C ; 
00000FD2: 6C 20 65 72 ; 
00000FD6: 61 73 65 20 ; 
00000FDA: 74 68 65 20 ; 
00000FDE: 70 72 65 76 ; 
00000FE2: 69 6F 75 73 ; 
00000FE6: 20 62 6F 61 ; 
00000FEA: 72 64 20 62 ; 
00000FEE: 65 66 6F 72 ; 
00000FF2: 65 20 70 72 ; 
00000FF6: 69 6E 74 69 ; 
00000FFA: 6E 67 20 74 ; 
00000FFE: 68 65 20 6E ; 
00001002: 65 78 74 20 ; 
00001006: 2D 20 5B 69 ; 
0000100A: 73 20 32 78 ; 
0000100E: 20 73 6C 6F ; 
00001012: 77 65 72 5D ; 
00001016: 0A 00       ; 
00001018: 53 69 6E 67 ; help2msg        defb "Single step mode will prompt for input each time a grid is drawn, you can
0000101C: 6C 65 20 73 ;  (s)ave the current state or (q)uit to menu", 0
00001020: 74 65 70 20 ; 
00001024: 6D 6F 64 65 ; 
00001028: 20 77 69 6C ; 
0000102C: 6C 20 70 72 ; 
00001030: 6F 6D 70 74 ; 
00001034: 20 66 6F 72 ; 
00001038: 20 69 6E 70 ; 
0000103C: 75 74 20 65 ; 
00001040: 61 63 68 20 ; 
00001044: 74 69 6D 65 ; 
00001048: 20 61 20 67 ; 
0000104C: 72 69 64 20 ; 
00001050: 69 73 20 64 ; 
00001054: 72 61 77 6E ; 
00001058: 2C 20 79 6F ; 
0000105C: 75 20 63 61 ; 
00001060: 6E 20 28 73 ; 
00001064: 29 61 76 65 ; 
00001068: 20 74 68 65 ; 
0000106C: 20 63 75 72 ; 
00001070: 72 65 6E 74 ; 
00001074: 20 73 74 61 ; 
00001078: 74 65 20 6F ; 
0000107C: 72 20 28 71 ; 
00001080: 29 75 69 74 ; 
00001084: 20 74 6F 20 ; 
00001088: 6D 65 6E 75 ; 
0000108C: 00          ; 
0000108D: 54 68 61 6E ; mainendmsg      defb "Thank you for playing JCGOL for ARM32", nl, 0
00001091: 6B 20 79 6F ; 
00001095: 75 20 66 6F ; 
00001099: 72 20 70 6C ; 
0000109D: 61 79 69 6E ; 
000010A1: 67 20 4A 43 ; 
000010A5: 47 4F 4C 20 ; 
000010A9: 66 6F 72 20 ; 
000010AD: 41 52 4D 33 ; 
000010B1: 32 0A 00    ; 
000010B4: 57 6F 75 6C ; askdefaults     defb "Would you like to use the default settings? Y/n: ", 0
000010B8: 64 20 79 6F ; 
000010BC: 75 20 6C 69 ; 
000010C0: 6B 65 20 74 ; 
000010C4: 6F 20 75 73 ; 
000010C8: 65 20 74 68 ; 
000010CC: 65 20 64 65 ; 
000010D0: 66 61 75 6C ; 
000010D4: 74 20 73 65 ; 
000010D8: 74 74 69 6E ; 
000010DC: 67 73 3F 20 ; 
000010E0: 59 2F 6E 3A ; 
000010E4: 20 00       ; 
000010E6: 45 6E 61 62 ; askerase        defb "Enable erase mode? Y/n: ", 0
000010EA: 6C 65 20 65 ; 
000010EE: 72 61 73 65 ; 
000010F2: 20 6D 6F 64 ; 
000010F6: 65 3F 20 59 ; 
000010FA: 2F 6E 3A 20 ; 
000010FE: 00          ; 
000010FF: 45 6E 61 62 ; askslow         defb "Enable slow mode? Y/n: ", 0
00001103: 6C 65 20 73 ; 
00001107: 6C 6F 77 20 ; 
0000110B: 6D 6F 64 65 ; 
0000110F: 3F 20 59 2F ; 
00001113: 6E 3A 20 00 ; 
00001117: 45 6E 61 62 ; askstep         defb "Enable step mode? Y/n: ", 0
0000111B: 6C 65 20 73 ; 
0000111F: 74 65 70 20 ; 
00001123: 6D 6F 64 65 ; 
00001127: 3F 20 59 2F ; 
0000112B: 6E 3A 20 00 ; 
0000112F: 43 61 6E 6E ; stepslowwarning defb "Cannot have slow and step mode active at the same time, disabling slow mo
00001133: 6F 74 20 68 ; de", nl, 0
00001137: 61 76 65 20 ; 
0000113B: 73 6C 6F 77 ; 
0000113F: 20 61 6E 64 ; 
00001143: 20 73 74 65 ; 
00001147: 70 20 6D 6F ; 
0000114B: 64 65 20 61 ; 
0000114F: 63 74 69 76 ; 
00001153: 65 20 61 74 ; 
00001157: 20 74 68 65 ; 
0000115B: 20 73 61 6D ; 
0000115F: 65 20 74 69 ; 
00001163: 6D 65 2C 20 ; 
00001167: 64 69 73 61 ; 
0000116B: 62 6C 69 6E ; 
0000116F: 67 20 73 6C ; 
00001173: 6F 77 20 6D ; 
00001177: 6F 64 65 0A ; 
0000117B: 00          ; 
0000117C: 52 65 74 75 ; savedchoice     defb "Return to menu? (n for continue sim) Y/n: ", 0
00001180: 72 6E 20 74 ; 
00001184: 6F 20 6D 65 ; 
00001188: 6E 75 3F 20 ; 
0000118C: 28 6E 20 66 ; 
00001190: 6F 72 20 63 ; 
00001194: 6F 6E 74 69 ; 
00001198: 6E 75 65 20 ; 
0000119C: 73 69 6D 29 ; 
000011A0: 20 59 2F 6E ; 
000011A4: 3A 20 00    ; 
000011A7: 50 6C 65 61 ; askname         defb "Please enter a name for the grid: ", 0
000011AB: 73 65 20 65 ; 
000011AF: 6E 74 65 72 ; 
000011B3: 20 61 20 6E ; 
000011B7: 61 6D 65 20 ; 
000011BB: 66 6F 72 20 ; 
000011BF: 74 68 65 20 ; 
000011C3: 67 72 69 64 ; 
000011C7: 3A 20 00    ; 
000011CA: 45 72 61 73 ; warneraseslow   defb "Erase mode is active it is recommended to also use slow mode", nl, 0
000011CE: 65 20 6D 6F ; 
000011D2: 64 65 20 69 ; 
000011D6: 73 20 61 63 ; 
000011DA: 74 69 76 65 ; 
000011DE: 20 69 74 20 ; 
000011E2: 69 73 20 72 ; 
000011E6: 65 63 6F 6D ; 
000011EA: 6D 65 6E 64 ; 
000011EE: 65 64 20 74 ; 
000011F2: 6F 20 61 6C ; 
000011F6: 73 6F 20 75 ; 
000011FA: 73 65 20 73 ; 
000011FE: 6C 6F 77 20 ; 
00001202: 6D 6F 64 65 ; 
00001206: 0A 00       ; 
00001208: 50 6C 65 61 ; askwid          defb "Please enter a width (1-30): ", 0
0000120C: 73 65 20 65 ; 
00001210: 6E 74 65 72 ; 
00001214: 20 61 20 77 ; 
00001218: 69 64 74 68 ; 
0000121C: 20 28 31 2D ; 
00001220: 33 30 29 3A ; 
00001224: 20 00       ; 
00001226: 50 6C 65 61 ; askhei          defb "Please enter a height (1-30): ", 0
0000122A: 73 65 20 65 ; 
0000122E: 6E 74 65 72 ; 
00001232: 20 61 20 68 ; 
00001236: 65 69 67 68 ; 
0000123A: 74 20 28 31 ; 
0000123E: 2D 33 30 29 ; 
00001242: 3A 20 00    ; 
00001245: 49 6E 76 61 ; getwidfailmsg   defb "Invalid width please enter a value between 1-30 inclusive: ", 0
00001249: 6C 69 64 20 ; 
0000124D: 77 69 64 74 ; 
00001251: 68 20 70 6C ; 
00001255: 65 61 73 65 ; 
00001259: 20 65 6E 74 ; 
0000125D: 65 72 20 61 ; 
00001261: 20 76 61 6C ; 
00001265: 75 65 20 62 ; 
00001269: 65 74 77 65 ; 
0000126D: 65 6E 20 31 ; 
00001271: 2D 33 30 20 ; 
00001275: 69 6E 63 6C ; 
00001279: 75 73 69 76 ; 
0000127D: 65 3A 20 00 ; 
00001281: 49 6E 76 61 ; getheifailmsg   defb "Invalid height please enter a value between 1-30 inclusive: ", 0
00001285: 6C 69 64 20 ; 
00001289: 68 65 69 67 ; 
0000128D: 68 74 20 70 ; 
00001291: 6C 65 61 73 ; 
00001295: 65 20 65 6E ; 
00001299: 74 65 72 20 ; 
0000129D: 61 20 76 61 ; 
000012A1: 6C 75 65 20 ; 
000012A5: 62 65 74 77 ; 
000012A9: 65 65 6E 20 ; 
000012AD: 31 2D 33 30 ; 
000012B1: 20 69 6E 63 ; 
000012B5: 6C 75 73 69 ; 
000012B9: 76 65 3A 20 ; 
000012BD: 00          ; 
000012BE: 55 73 69 6E ; usingDefault    defb "Using default values: dims=(18, 18) slowMode=Off eraseMode=Off stepMode=O
000012C2: 67 20 64 65 ; n", nl, 0
000012C6: 66 61 75 6C ; 
000012CA: 74 20 76 61 ; 
000012CE: 6C 75 65 73 ; 
000012D2: 3A 20 64 69 ; 
000012D6: 6D 73 3D 28 ; 
000012DA: 31 38 2C 20 ; 
000012DE: 31 38 29 20 ; 
000012E2: 73 6C 6F 77 ; 
000012E6: 4D 6F 64 65 ; 
000012EA: 3D 4F 66 66 ; 
000012EE: 20 65 72 61 ; 
000012F2: 73 65 4D 6F ; 
000012F6: 64 65 3D 4F ; 
000012FA: 66 66 20 73 ; 
000012FE: 74 65 70 4D ; 
00001302: 6F 64 65 3D ; 
00001306: 4F 6E 0A 00 ; 
0000130A: 43 68 6F 6F ; askgenoption    defb "Choose between (R)andom generation or (D)rawing the grid", 0
0000130E: 73 65 20 62 ; 
00001312: 65 74 77 65 ; 
00001316: 65 6E 20 28 ; 
0000131A: 52 29 61 6E ; 
0000131E: 64 6F 6D 20 ; 
00001322: 67 65 6E 65 ; 
00001326: 72 61 74 69 ; 
0000132A: 6F 6E 20 6F ; 
0000132E: 72 20 28 44 ; 
00001332: 29 72 61 77 ; 
00001336: 69 6E 67 20 ; 
0000133A: 74 68 65 20 ; 
0000133E: 67 72 69 64 ; 
00001342: 00          ; 
00001343: 49 6E 76 61 ; setupGrdFailmsg defb "Invalid choice, use `R` for random generation and `d` for drawing the gri
00001347: 6C 69 64 20 ; d. Not case sensative: ", 0
0000134B: 63 68 6F 69 ; 
0000134F: 63 65 2C 20 ; 
00001353: 75 73 65 20 ; 
00001357: 60 52 60 20 ; 
0000135B: 66 6F 72 20 ; 
0000135F: 72 61 6E 64 ; 
00001363: 6F 6D 20 67 ; 
00001367: 65 6E 65 72 ; 
0000136B: 61 74 69 6F ; 
0000136F: 6E 20 61 6E ; 
00001373: 64 20 60 64 ; 
00001377: 60 20 66 6F ; 
0000137B: 72 20 64 72 ; 
0000137F: 61 77 69 6E ; 
00001383: 67 20 74 68 ; 
00001387: 65 20 67 72 ; 
0000138B: 69 64 2E 20 ; 
0000138F: 4E 6F 74 20 ; 
00001393: 63 61 73 65 ; 
00001397: 20 73 65 6E ; 
0000139B: 73 61 74 69 ; 
0000139F: 76 65 3A 20 ; 
000013A3: 00          ; 
000013A4: 45 6E 74 65 ; askseed         defb "Enter 4 characters to be used as the seed: ", 0
000013A8: 72 20 34 20 ; 
000013AC: 63 68 61 72 ; 
000013B0: 61 63 74 65 ; 
000013B4: 72 73 20 74 ; 
000013B8: 6F 20 62 65 ; 
000013BC: 20 75 73 65 ; 
000013C0: 64 20 61 73 ; 
000013C4: 20 74 68 65 ; 
000013C8: 20 73 65 65 ; 
000013CC: 64 3A 20 00 ; 
000013D0: 49 6E 76 61 ; drawfailmsg     defb "Invalid input please enter 1 or 0: ", nl, 0
000013D4: 6C 69 64 20 ; 
000013D8: 69 6E 70 75 ; 
000013DC: 74 20 70 6C ; 
000013E0: 65 61 73 65 ; 
000013E4: 20 65 6E 74 ; 
000013E8: 65 72 20 31 ; 
000013EC: 20 6F 72 20 ; 
000013F0: 30 3A 20 0A ; 
000013F4: 00          ; 
000013F5: 47 72 69 64 ; gridfailmsg     defb "Grid was not properly initialised, consider smaller dims", nl, 0
000013F9: 20 77 61 73 ; 
000013FD: 20 6E 6F 74 ; 
00001401: 20 70 72 6F ; 
00001405: 70 65 72 6C ; 
00001409: 79 20 69 6E ; 
0000140D: 69 74 69 61 ; 
00001411: 6C 69 73 65 ; 
00001415: 64 2C 20 63 ; 
00001419: 6F 6E 73 69 ; 
0000141D: 64 65 72 20 ; 
00001421: 73 6D 61 6C ; 
00001425: 6C 65 72 20 ; 
00001429: 64 69 6D 73 ; 
0000142D: 0A 00       ; 
0000142F: 54 68 65 72 ; gridsavefail    defb "There was an error allocating memory for the grid save", nl, 0
00001433: 65 20 77 61 ; 
00001437: 73 20 61 6E ; 
0000143B: 20 65 72 72 ; 
0000143F: 6F 72 20 61 ; 
00001443: 6C 6C 6F 63 ; 
00001447: 61 74 69 6E ; 
0000144B: 67 20 6D 65 ; 
0000144F: 6D 6F 72 79 ; 
00001453: 20 66 6F 72 ; 
00001457: 20 74 68 65 ; 
0000145B: 20 67 72 69 ; 
0000145F: 64 20 73 61 ; 
00001463: 76 65 0A 00 ; 
00001467: 54 68 65 72 ; gridloadempty   defb "There are no saved grids, start a step mode sim and save the grid, return
0000146B: 65 20 61 72 ;  to main menu to load", nl, 0
0000146F: 65 20 6E 6F ; 
00001473: 20 73 61 76 ; 
00001477: 65 64 20 67 ; 
0000147B: 72 69 64 73 ; 
0000147F: 2C 20 73 74 ; 
00001483: 61 72 74 20 ; 
00001487: 61 20 73 74 ; 
0000148B: 65 70 20 6D ; 
0000148F: 6F 64 65 20 ; 
00001493: 73 69 6D 20 ; 
00001497: 61 6E 64 20 ; 
0000149B: 73 61 76 65 ; 
0000149F: 20 74 68 65 ; 
000014A3: 20 67 72 69 ; 
000014A7: 64 2C 20 72 ; 
000014AB: 65 74 75 72 ; 
000014AF: 6E 20 74 6F ; 
000014B3: 20 6D 61 69 ; 
000014B7: 6E 20 6D 65 ; 
000014BB: 6E 75 20 74 ; 
000014BF: 6F 20 6C 6F ; 
000014C3: 61 64 0A 00 ; 
000014C7: 46 6F 75 6E ; gridloadpname   defb "Found a grid called: ", 0
000014CB: 64 20 61 20 ; 
000014CF: 67 72 69 64 ; 
000014D3: 20 63 61 6C ; 
000014D7: 6C 65 64 3A ; 
000014DB: 20 00       ; 
000014DD: 77 69 64 74 ; gridloadpwidth  defb "width: ", 0
000014E1: 68 3A 20 00 ; 
000014E5: 68 65 69 67 ; gridloadpheight defb "height: ", 0
000014E9: 68 74 3A 20 ; 
000014ED: 00          ; 
000014EE: 50 6C 65 61 ; loadboardaski   defb "Please enter the index of the grid to load, or enter a negative index to 
000014F2: 73 65 20 65 ; not load a grid", nl, 0
000014F6: 6E 74 65 72 ; 
000014FA: 20 74 68 65 ; 
000014FE: 20 69 6E 64 ; 
00001502: 65 78 20 6F ; 
00001506: 66 20 74 68 ; 
0000150A: 65 20 67 72 ; 
0000150E: 69 64 20 74 ; 
00001512: 6F 20 6C 6F ; 
00001516: 61 64 2C 20 ; 
0000151A: 6F 72 20 65 ; 
0000151E: 6E 74 65 72 ; 
00001522: 20 61 20 6E ; 
00001526: 65 67 61 74 ; 
0000152A: 69 76 65 20 ; 
0000152E: 69 6E 64 65 ; 
00001532: 78 20 74 6F ; 
00001536: 20 6E 6F 74 ; 
0000153A: 20 6C 6F 61 ; 
0000153E: 64 20 61 20 ; 
00001542: 67 72 69 64 ; 
00001546: 0A 00       ; 
00001548: 52 65 74 75 ; loadboardretmsg defb "Returning to main menu", nl, 0
0000154C: 72 6E 69 6E ; 
00001550: 67 20 74 6F ; 
00001554: 20 6D 61 69 ; 
00001558: 6E 20 6D 65 ; 
0000155C: 6E 75 0A 00 ; 
00001560: 49 6E 76 61 ; loadboardifail  defb "Invalid input given for the index", nl, 0
00001564: 6C 69 64 20 ; 
00001568: 69 6E 70 75 ; 
0000156C: 74 20 67 69 ; 
00001570: 76 65 6E 20 ; 
00001574: 66 6F 72 20 ; 
00001578: 74 68 65 20 ; 
0000157C: 69 6E 64 65 ; 
00001580: 78 0A 00    ; 
00001583: 49 6E 76 61 ; loadboardirerr  defb "Invalid index, out of range", nl, 0
00001587: 6C 69 64 20 ; 
0000158B: 69 6E 64 65 ; 
0000158F: 78 2C 20 6F ; 
00001593: 75 74 20 6F ; 
00001597: 66 20 72 61 ; 
0000159B: 6E 67 65 0A ; 
0000159F: 00          ; 
000015A0: 45 72 72 6F ; loadboardmlcerr defb "Error allocating memory for loaded grid. Returing to main menu", nl, 0
000015A4: 72 20 61 6C ; 
000015A8: 6C 6F 63 61 ; 
000015AC: 74 69 6E 67 ; 
000015B0: 20 6D 65 6D ; 
000015B4: 6F 72 79 20 ; 
000015B8: 66 6F 72 20 ; 
000015BC: 6C 6F 61 64 ; 
000015C0: 65 64 20 67 ; 
000015C4: 72 69 64 2E ; 
000015C8: 20 52 65 74 ; 
000015CC: 75 72 69 6E ; 
000015D0: 67 20 74 6F ; 
000015D4: 20 6D 61 69 ; 
000015D8: 6E 20 6D 65 ; 
000015DC: 6E 75 0A 00 ; 
000015E0: 53 75 63 63 ; loadboardsucmsg defb "Successfully loaded the grid", nl, 0
000015E4: 65 73 73 66 ; 
000015E8: 75 6C 6C 79 ; 
000015EC: 20 6C 6F 61 ; 
000015F0: 64 65 64 20 ; 
000015F4: 74 68 65 20 ; 
000015F8: 67 72 69 64 ; 
000015FC: 0A 00       ; 
000015FE:             ; 
00001600:             ; align
00001600: 00000000    ; heapstart       defw 0 ;;points to the end of the data this is where the heap can then begin
00001604:             ; Remaining literals

Symbol Table: Labels
: max_addr                          00100000  Value
: stack_size                        00010000  Value
: nl                                0000000A  Value
: backspace                         00000008  Value
: minBuffSize                       00000008  Value
: enter                             0000000A  Value
: minSaveSize                       00000008  Value
: sizeofSaveI                       0000000C  Value
: _start                            00000000  Local -- ARM
: main                              00000038  Local -- ARM
: mainmenu                          00000064  Local -- ARM
: mainchoice                        0000007C  Local -- ARM
: newboard                          000000B4  Local -- ARM
: loadboard                         000000DC  Local -- ARM
: loadboardaskindex                 000000F0  Local -- ARM
: loadboardindex                    00000154  Local -- ARM
: loadboardmain                     00000170  Local -- ARM
: loadboardmallocB                  000001D8  Local -- ARM
: loadboardskipB                    000001F4  Local -- ARM
: loadboardmallocfail               00000214  Local -- ARM
: loadboardret                      00000224  Local -- ARM
: loadboardempty                    00000230  Local -- ARM
: loadboarderr                      00000230  Local -- ARM
: loadboardsucc                     00000234  Local -- ARM
: mainloopstart                     00000238  Local -- ARM
: mainloop                          00000268  Local -- ARM
: mainloopskipstep                  000002AC  Local -- ARM
: gridFail                          000002D0  Local -- ARM
: mainEnd                           000002DC  Local -- ARM
: newline                           000002F4  Local -- ARM
: step                              00000300  Local -- ARM
: stependfail                       00000378  Local -- ARM
: stependsucc                       00000380  Local -- ARM
: stepend                           00000384  Local -- ARM
: listGrids                         0000038C  Local -- ARM
: listGridsLoop                     000003A8  Local -- ARM
: listGridsEmpty                    00000414  Local -- ARM
: listGridsLend                     00000420  Local -- ARM
: listGridsEnd                      00000420  Local -- ARM
: saveGrid                          00000428  Local -- ARM
: saveGridResize                    0000044C  Local -- ARM
: saveGridAdd                       00000484  Local -- ARM
: saveGridFailMalloc                000004EC  Local -- ARM
: saveGridSucc                      000004F4  Local -- ARM
: saveGridEnd                       000004F8  Local -- ARM
: erase                             00000500  Local -- ARM
: eraseloop                         00000504  Local -- ARM
: eraseend                          0000051C  Local -- ARM
: slow                              00000520  Local -- ARM
: slowloop                          00000528  Local -- ARM
: slowend                           00000548  Local -- ARM
: heapclean                         0000054C  Local -- ARM
: heapcleanloop                     00000568  Local -- ARM
: heapcleanend                      0000057C  Local -- ARM
: strlen                            00000580  Local -- ARM
: strlenloop                        0000058C  Local -- ARM
: strlenend                         000005A0  Local -- ARM
: strtoi                            000005A8  Local -- ARM
: strtoiloop                        000005E8  Local -- ARM
: strtoilend                        0000061C  Local -- ARM
: strtoifailminus                   00000624  Local -- ARM
: strtoifailoutrange                0000062C  Local -- ARM
: strtoifailnonnum                  00000634  Local -- ARM
: strtoiendfail                     00000638  Local -- ARM
: strtoiendsucc                     00000640  Local -- ARM
: strtoiend                         00000644  Local -- ARM
: memcpy                            0000064C  Local -- ARM
: memcpywordsloop                   00000674  Local -- ARM
: memcpywordslend                   0000068C  Local -- ARM
: memcpyallbytes                    0000069C  Local -- ARM
: memcpybytes                       000006A8  Local -- ARM
: memcpybytesloop                   000006AC  Local -- ARM
: memcpybyteslend                   000006C4  Local -- ARM
: memcpyend                         000006C8  Local -- ARM
: getstring                         000006D0  Local -- ARM
: getstringloop                     000006FC  Local -- ARM
: getstringloopskipsize             0000070C  Local -- ARM
: skipMax                           00000720  Local -- ARM
: getstringlcont                    0000072C  Local -- ARM
: getstringresize                   00000744  Local -- ARM
: getstringlend                     00000774  Local -- ARM
: getstringResizeEnd                00000780  Local -- ARM
: getstringEnd                      000007AC  Local -- ARM
: tolower                           000007C0  Local -- ARM
: setupGrid                         000007C8  Local -- ARM
: setupGridAsk                      00000810  Local -- ARM
: setupdrawing                      00000840  Local -- ARM
: setuprandom                       00000848  Local -- ARM
: setupstart                        00000864  Local -- ARM
: setuprowloop                      00000868  Local -- ARM
: setupcolloop                      00000874  Local -- ARM
: dorandom                          00000888  Local -- ARM
: dodraw                            0000089C  Local -- ARM
: dodrawsucc                        000008C0  Local -- ARM
: setupcollcont                     000008C4  Local -- ARM
: setupcollend                      000008E0  Local -- ARM
: setuprowlend                      000008E8  Local -- ARM
: setupGridFail                     000008E8  Local -- ARM
: setupGridEnd                      000008E8  Local -- ARM
: drawgrid                          000008F0  Local -- ARM
: drawgridrowloop                   00000904  Local -- ARM
: drawgridcolloop                   00000910  Local -- ARM
: drawgridcollend                   00000940  Local -- ARM
: drawgridrowlend                   00000954  Local -- ARM
: drawgridend                       0000095C  Local -- ARM
: setupOptions                      00000964  Local -- ARM
: setupOptionsDSkipDims             000009C0  Local -- ARM
: setupCustom                       000009C8  Local -- ARM
: setupCustomskipslow               00000A6C  Local -- ARM
: setupCustomDimsCheck              00000A74  Local -- ARM
: getwid                            00000A88  Local -- ARM
: getwidFail                        00000ACC  Local -- ARM
: getheisetup                       00000ADC  Local -- ARM
: gethei                            00000AE8  Local -- ARM
: getheiFail                        00000B2C  Local -- ARM
: customend                         00000B3C  Local -- ARM
: updategrid                        00000B44  Local -- ARM
: updategridrowloop                 00000B5C  Local -- ARM
: updategridcolloop                 00000B68  Local -- ARM
: updatealive                       00000B90  Local -- ARM
: updatedead                        00000BAC  Local -- ARM
: updatelcont                       00000BBC  Local -- ARM
: updategridccollend                00000BC4  Local -- ARM
: updategridrowlend                 00000BD0  Local -- ARM
: updategridend                     00000BD0  Local -- ARM
: countneighbours                   00000BD8  Local -- ARM
: countneighboursloop               00000BF8  Local -- ARM
: countneighboursskipadd            00000C3C  Local -- ARM
: countneighbourslend               00000C40  Local -- ARM
: countneighboursend                00000C40  Local -- ARM
: isinrange                         00000C4C  Local -- ARM
: isinrangefail                     00000C80  Local -- ARM
: isinrangeend                      00000C84  Local -- ARM
: setupHeap                         00000C88  Local -- ARM
: malloc                            00000CB4  Local -- ARM
: mallignend                        00000CD0  Local -- ARM
: checkcrate                        00000CD4  Local -- ARM
: nocrates                          00000CF4  Local -- ARM
: foundcrate                        00000CFC  Local -- ARM
: splitcrate                        00000D0C  Local -- ARM
: usecrate                          00000D40  Local -- ARM
: mallocEnd                         00000D54  Local -- ARM
: free                              00000D5C  Local -- ARM
: freeloop                          00000D68  Local -- ARM
: freelend                          00000D84  Local -- ARM
: freelendEnd                       00000DA4  Local -- ARM
: freeMergeCheck                    00000DAC  Local -- ARM
: verifyLeft                        00000DBC  Local -- ARM
: verifyRight                       00000DD0  Local -- ARM
: merge                             00000DE4  Local -- ARM
: mergeNew                          00000E18  Local -- ARM
: freeEnd                           00000E18  Local -- ARM
: heaphead                          00000E20  Local -- ARM
: offsets                           00000E24  Local -- ARM
: gridA                             00000E64  Local -- ARM
: gridB                             00000E68  Local -- ARM
: erase_b                           00000E6C  Local -- ARM
: slow_b                            00000E6D  Local -- ARM
: step_b                            00000E6E  Local -- ARM
: width                             00000E6F  Local -- ARM
: height                            00000E70  Local -- ARM
: welcomemsg                        00000E71  Local -- ARM
: welcome2msg                       00000EA2  Local -- ARM
: mainchoicefail                    00000EEE  Local -- ARM
: helpmsg                           00000F5A  Local -- ARM
: help2msg                          00001018  Local -- ARM
: mainendmsg                        0000108D  Local -- ARM
: askdefaults                       000010B4  Local -- ARM
: askerase                          000010E6  Local -- ARM
: askslow                           000010FF  Local -- ARM
: askstep                           00001117  Local -- ARM
: stepslowwarning                   0000112F  Local -- ARM
: savedchoice                       0000117C  Local -- ARM
: askname                           000011A7  Local -- ARM
: warneraseslow                     000011CA  Local -- ARM
: askwid                            00001208  Local -- ARM
: askhei                            00001226  Local -- ARM
: getwidfailmsg                     00001245  Local -- ARM
: getheifailmsg                     00001281  Local -- ARM
: usingDefault                      000012BE  Local -- ARM
: askgenoption                      0000130A  Local -- ARM
: setupGrdFailmsg                   00001343  Local -- ARM
: askseed                           000013A4  Local -- ARM
: drawfailmsg                       000013D0  Local -- ARM
: gridfailmsg                       000013F5  Local -- ARM
: gridsavefail                      0000142F  Local -- ARM
: gridloadempty                     00001467  Local -- ARM
: gridloadpname                     000014C7  Local -- ARM
: gridloadpwidth                    000014DD  Local -- ARM
: gridloadpheight                   000014E5  Local -- ARM
: loadboardaski                     000014EE  Local -- ARM
: loadboardretmsg                   00001548  Local -- ARM
: loadboardifail                    00001560  Local -- ARM
: loadboardirerr                    00001583  Local -- ARM
: loadboardmlcerr                   000015A0  Local -- ARM
: loadboardsucmsg                   000015E0  Local -- ARM
: heapstart                         00001600  Local -- ARM
