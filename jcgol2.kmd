KMD
00000000:             ; ;;  This is my second rendition of JCGOL in ARM assembly for Komodo
00000000:             ; ;;  
00000000:             ; ;;  This will attempt to follow the ARM 32bit calling convention 
00000000:             ; ;;      R0-3 are argument registers, scratch
00000000:             ; ;;      R4-10 are local variable registers and should be saved before use in a function
00000000:             ; ;;      R11 - FP
00000000:             ; ;;      R12 - IPC
00000000:             ; ;;      R13 - SP
00000000:             ; ;;      R14 - LR
00000000:             ; ;;      R15 - PC
00000000:             ; ;;
00000000:             ; ;;  The plan
00000000:             ; ;;  - Create a simple `heap` allocator for the grid and input
00000000:             ; ;;  - Ask the user
00000000:             ; ;;      |-Use default? Y - skip below
00000000:             ; ;;      |-dims of the grid
00000000:             ; ;;      |   `-Will need a way to get a string input and convert to an integer (make sure to cat
                      ; ch -ve)
00000000:             ; ;;      |-slow mode
00000000:             ; ;;      `-erase mode
00000000:             ; ;;  - ask for generation mode
00000000:             ; ;;      |-If random ask for seed
00000000:             ; ;;      |   `-For generation roll the seed to create a pseudorandom value for each `pixel`
00000000:             ; ;;      `-If draw then get them to draw the grid one `pixel` at a time
00000000:             ; ;;  - Allocate two grids, the pointers to which will swap after a frame. One is used to count t
                      ; he neighbours the other for the new cell value.
00000000:             ; ;;  - loop
00000000:             ; ;;      |-count neighbours
00000000:             ; ;;      |-update inactive grid
00000000:             ; ;;      |-swap grids
00000000:             ; ;;      |-draw active grid
00000000:             ; ;;      `-goto loop
00000000:             ; 
00000000:             ; ;;SINGLE STEP mode allows you to save the current state of the board into a list, also give it 
                      ; a name
00000000:             ; ;;At the main menu you can load a saved grid
00000000:             ; 
00000000:             ; ;;Grid info struct
00000000:             ; ;;  - SaveInfoStruct* array
00000000:             ; ;;  - int max size of arr
00000000:             ; ;;  - int current position in arr
00000000:             ; 
00000000:             ; ;;Save info struct
00000000:             ; ;;  -address of grid [4 BYTES]
00000000:             ; ;;  -char* to the name [4 BYTES]
00000000:             ; ;;  -width of grid (1 BYTE)
00000000:             ; ;;  -height of grid (1 BYTE)
00000000:             ; 
00000000:             ; 
00000000:             ; ;;  CURRENT ISSUES/TODOS
00000000:             ; ;;  |-More testing of malloc & free need to be done
00000000:             ; ;;  `-Think about minimising the fragmentation of the heap - find the best free block instead o
                      ; f the first
00000000:             ;   
00000000:             ; max_addr    EQU  0x100000
00000000:             ; stack_size  EQU  0x10000
00000000:             ; nl      EQU  10
00000000:             ; backspace   EQU  8
00000000:             ; minBuffSize EQU  8
00000000:             ; enter       EQU  nl
00000000:             ; minSaveSize EQU  8
00000000:             ; sizeofSaveI EQU  12 ;;10 bytes + 2 bytes of padding
00000000:             ; 
00000000:             ; _start
00000000:             ;     ;;prepare the stack
00000000: E3A0D601    ;     ldr R13, =max_addr
00000004: E3A0E000    ;     mov R14, #0 ;; allow for `returning` from _start
00000008: E92D4000    ;     push {R14}
0000000C:             ; 
0000000C:             ;     ;;[[temp]] clean the heap
0000000C: EB000234    ;     bl heapclean
00000010:             ; 
00000010:             ;     ;;setup heap
00000010: E28F0D7E    ;     adrl R0, heapstart
00000014: E2800000    ; 
00000018: E58F0920    ;     str R0, heaphead
0000001C: EB000462    ;     bl setupHeap
00000020:             ; 
00000020: E3A0000E    ;     mov R0, #14
00000024: EB00046B    ;     bl malloc
00000028:             ; 
00000028: EB000002    ;     bl main
0000002C:             ; 
0000002C: E8BD4000    ;     pop {R14}
00000030: EF000002    ;     swi 2
00000034: E1A0F00E    ;     mov R15, R14
00000038:             ; 
00000038:             ; main
00000038: E92D4FF0    ;     push {fp, R14, R4-R10} ;;8 registers saved
0000003C:             ; 
0000003C: E28DB01C    ;     add fp, sp, #28 ;;(r - 1) * 4
00000040: E24DD010    ;     sub sp, sp, #16 ;;reserve 12 bytes (4 bytes to align?) on the stack for the pointer to the 
                      ; list of saved grids + the maxSize of the array
00000044:             ; 
00000044:             ;     ;;The gridInfo struct
00000044:             ;     ;;set the current position of the pointer
00000044: E3A00000    ;     mov R0, #0
00000048: E58D0008    ;     str R0, [sp, #8]
0000004C:             ; 
0000004C:             ;     ;;set the number of elements(save info structs) that can be stored in the array at the mome
                      ; nt
0000004C: E3A00008    ;     ldr R0, =minSaveSize
00000050: E58D0004    ;     str R0, [sp, #4]
00000054:             ; 
00000054:             ;     ;;minsize * sizeof(SaveInfo) = number of bytes needed for the array
00000054: E3A0100C    ;     ldr R1, =sizeofSaveI
00000058: E0000190    ;     mul R0, R0, R1
0000005C: EB00045D    ;     bl malloc ;;allocate the array on the heap
00000060:             ; 
00000060: E58D0000    ;     str R0, [sp, #0] ;;store the address
00000064:             ; 
00000064:             ; mainmenu
00000064: E28F0FB6    ;     adrl R0, welcomemsg
00000068: E2800A01    ; 
0000006C: EF000003    ;     swi 3
00000070:             ; 
00000070: E28F00FD    ;     adrl R0, welcome2msg
00000074: E2800C12    ; 
00000078: EF000003    ;     swi 3
0000007C:             ; 
0000007C:             ; mainchoice
0000007C: EF000001    ;     swi 1
00000080: E3800020    ;     orr R0, R0, #32
00000084: E1A04000    ;     mov R4, R0
00000088:             ; 
00000088:             ;     ;;These should really be functions
00000088:             ; 
00000088: E354006E    ;     cmp R4, #'n' ;;new board generation
0000008C: 0A00010D    ;     beq newboard
00000090:             ; 
00000090: E354006C    ;     cmp R4, #'l' ;;load a saved board
00000094: E1A0000D    ;     mov R0, sp ;;load the info ptr
00000098: 0A000114    ;     beq loadboard
0000009C:             ; 
0000009C: E3540068    ;     cmp R4, #'h'
000000A0: 0A000103    ;     beq printhelp
000000A4:             ; 
000000A4: E3540073    ;     cmp R4, #'s'
000000A8: 0A00003E    ;     beq settingsmenu
000000AC:             ; 
000000AC: E3540071    ;     cmp R4, #'q' ;;quit
000000B0: 0A000036    ;     beq mainEnd
000000B4:             ; 
000000B4: E28F0FBE    ;     adrl R0, mainchoicefail
000000B8: E2800A01    ; 
000000BC: EF000003    ;     swi 3
000000C0:             ; 
000000C0: EAFFFFED    ;     b mainchoice
000000C4:             ; 
000000C4:             ;     ;;R4 will hold the active grid, R5 will hold the passive grid
000000C4:             ;     ;;Active is used to count neighbours, passive is used to place updated values in 
000000C4:             ;     ;;either can be drawn, just drawn in a different position
000000C4:             ; 
000000C4:             ; 
000000C4:             ; ;;update loop
000000C4:             ; ;;    - loop
000000C4:             ; ;;      |-count neighbours
000000C4:             ; ;;      |-update inactive grid
000000C4:             ; ;;      |-swap grids
000000C4:             ; ;;      |-draw grid
000000C4:             ; ;;      |-[slow?] - slow() - loops for some time to increase waiting time
000000C4:             ; ;;      |-[step?] - step() - waits for input, s and q will have effects
000000C4:             ; ;;      |-[erase?] - erase() - \b until grid is gone
000000C4:             ; ;;      `-goto loop
000000C4:             ; mainloopstart
000000C4:             ;     ;;load the slow, step, and erase booleans
000000C4: E5DF68C1    ;     ldrb R6, slow_b
000000C8: E5DF78BC    ;     ldrb R7, erase_b
000000CC: E5DF88BA    ;     ldrb R8, step_b
000000D0:             ; 
000000D0: E59F48AC    ;     ldr R4, gridA
000000D4: E59F58AC    ;     ldr R5, gridB
000000D8:             ; 
000000D8:             ;     ;;(width * height) * 2 + 1 + height
000000D8: E5DF08AF    ;     ldrb R0, width
000000DC: E5DF18AC    ;     ldrb R1, height
000000E0: E0000190    ;     mul R0, R0, R1
000000E4: E1A00080    ;     mov R0, R0, lsl #1
000000E8: E2800001    ;     add R0, R0, #1
000000EC: E0800001    ;     add R0, R0, R1
000000F0: E1A09000    ;     mov R9, R0      ;;R9 holds the itterations for erase, so it doesn't have to calc it every t
                      ; ime
000000F4:             ; 
000000F4: E3A0A000    ;     mov R10, #0 ;;This will hold the number of itterations, when it reaches 
000000F8:             ; 
000000F8:             ; mainloop
000000F8: E5DF0893    ;     ldrb R0, maxitters ;;run out of registers @-@
000000FC: E15A0000    ;     cmp R10, R0
00000100: E28AA001    ;     add R10, R10, #1
00000104: 1A000004    ;     bne mainloopcont
00000108:             ; 
00000108: E3A0A000    ;     mov R10, #0
0000010C:             ; 
0000010C: E28F0067    ;     adrl R0, mainloopittsmsg
00000110: E2800C17    ; 
00000114: EF000003    ;     swi 3
00000118:             ; 
00000118: EA000006    ;     b mainloopdostep
0000011C:             ; 
0000011C:             ; mainloopcont
0000011C: E1A00004    ;     mov R0, R4
00000120: E1A01005    ;     mov R1, R5
00000124: EB0003CE    ;     bl updategrid
00000128:             ; 
00000128: E1A00004    ;     mov R0, R4
0000012C: EB000301    ;     bl drawgrid
00000130:             ; 
00000130: E3580001    ;     cmp R8, #1
00000134: 1A000009    ;     bne mainloopskipstep
00000138:             ; 
00000138:             ; mainloopdostep
00000138: E1A0000D    ;     mov R0, sp
0000013C: E1A01004    ;     mov R1, R4 ;;give the active grid
00000140: EB000144    ;     bl step
00000144: E3500000    ;     cmp R0, #0
00000148: 0A000004    ;     beq mainloopskipstep
0000014C:             ;     
0000014C:             ;     ;;If R0 is #1 then free and go to the main menu
0000014C:             ;     ;;free the current grid
0000014C: E59F0830    ;     ldr R0, gridA
00000150: EB00044A    ;     bl free
00000154: E59F082C    ;     ldr R0, gridB
00000158: EB000448    ;     bl free
0000015C:             ; 
0000015C: EAFFFFC0    ;     b mainmenu
00000160:             ; 
00000160:             ; mainloopskipstep
00000160: E3560001    ;     cmp R6, #1
00000164: 0B0001D3    ;     bleq slow
00000168:             ; 
00000168: E3570001    ;     cmp R7, #1
0000016C: 01A00009    ;     moveq R0, R9
00000170: 0B0001C8    ;     bleq erase
00000174:             ; 
00000174: E1A00004    ;     mov R0, R4
00000178: E1A04005    ;     mov R4, R5
0000017C: E1A05000    ;     mov R5, R0 ;;SWAP the active and passive
00000180:             ; 
00000180: EAFFFFDC    ;     b mainloop
00000184:             ; 
00000184:             ; gridFail
00000184: E28F008B    ;     adrl R0, gridfailmsg
00000188: E2800B06    ; 
0000018C: EF000003    ;     swi 3
00000190:             ; 
00000190:             ; mainEnd
00000190:             ;     ;;[[todo]]need to free all of the memory, saved grids (grids + names) + current grids
00000190:             ; 
00000190: E28F00EA    ;     adrl R0, mainendmsg
00000194: E2800C13    ; 
00000198: EF000003    ;     swi 3
0000019C:             ; 
0000019C: E24BD018    ;     sub sp, fp, #24 ;;???
000001A0: E8BD47F0    ;     pop {R14, R4-R10}
000001A4: E1A0F00E    ;     mov R15, R14
000001A8:             ; 
000001A8:             ; settingsmenu
000001A8:             ; ;;https://media.giphy.com/media/jOpLbiGmHR9S0/giphy.gif
000001A8:             ; ;;I think there's a limit on the defined string length
000001A8: E28F00C9    ;     adrl R0, s_m1
000001AC: E2800C1A    ; 
000001B0: EF000003    ;     swi 3
000001B4:             ; 
000001B4: E28F004E    ;     adrl R0, s_m2
000001B8: E2800C1B    ; 
000001BC: EF000003    ;     swi 3
000001C0:             ;     
000001C0: E28F00A6    ;     adrl R0, s_m3
000001C4: E2800C1B    ; 
000001C8: EF000003    ;     swi 3
000001CC:             ; 
000001CC:             ; changesetting
000001CC: E28F004B    ;     adrl R0, s_m
000001D0: E2800B07    ; 
000001D4: EF000003    ;     swi 3
000001D8:             ; 
000001D8:             ; changesettingget
000001D8: E3A0000A    ;     ldr R0, =enter
000001DC: E3A01002    ;     mov R1, #2
000001E0: E3A02001    ;     mov R2, #1
000001E4: EB000237    ;     bl getstring
000001E8:             ; 
000001E8: E1A05000    ;     mov R5, R0
000001EC:             ; 
000001EC: EB0001EB    ;     bl strtoi
000001F0:             ; 
000001F0: E1A04000    ;     mov R4, R0
000001F4: E1A06001    ;     mov R6, R1
000001F8: E1A00005    ;     mov R0, R5
000001FC:             ; 
000001FC: EB00041F    ;     bl free
00000200:             ; 
00000200: EB000111    ;     bl newline
00000204:             ; 
00000204: E3560001    ;     cmp R6, #1
00000208: 0AFFFF95    ;     beq mainmenu
0000020C:             ; 
0000020C: E3560000    ;     cmp R6, #0
00000210: 0A000003    ;     beq changesettingscont
00000214:             ; 
00000214:             ; changesettingserr
00000214: E28F005F    ;     adrl R0, s_m_err
00000218: E2800B07    ; 
0000021C: EF000003    ;     swi 3
00000220:             ; 
00000220: EAFFFFEC    ;     b changesettingget
00000224:             ; 
00000224:             ; changesettingscont
00000224: E3540006    ;     cmp R4, #6
00000228: CAFFFFF9    ;     bgt changesettingserr
0000022C:             ; 
0000022C:             ;     ;;now we have the index we can print the current value and prompt for a new one then loop b
                      ; ack up to the getsetting
0000022C:             ; 
0000022C:             ;     ;;No jump tables \(-__-)/
0000022C: E3540000    ;     cmp R4, #0
00000230: 0A000055    ;     beq changestep
00000234:             ; 
00000234: E3540001    ;     cmp R4, #1
00000238: 0A000059    ;     beq changeslow
0000023C:             ; 
0000023C: E3540002    ;     cmp R4, #2
00000240: 0A00005D    ;     beq changeerase
00000244:             ; 
00000244: E3540003    ;     cmp R4, #3
00000248: 0A00008A    ;     beq changedims
0000024C:             ; 
0000024C: E3540004    ;     cmp R4, #4
00000250: 0A00008F    ;     beq changerange
00000254:             ; 
00000254: E3540005    ;     cmp R4, #5
00000258: 0A000094    ;     beq changeicons
0000025C:             ; 
0000025C: E3540006    ;     cmp R4, #6
00000260: 0A000092    ;     beq changeitter
00000264:             ; 
00000264:             ; changearr
00000264:             ; ;;generic for changedims and change range
00000264:             ; ;;INP in R0 is addr. for x
00000264:             ; ;;INP in R1 is addr. for y
00000264:             ; ;;INP in R2 is boolean for require x < y. 1 for require
00000264: E92D41F0    ;     push {R14, R4-R8}
00000268:             ; 
00000268: E1A06000    ;     mov R6, R0
0000026C: E1A07001    ;     mov R7, R1
00000270: E1A08002    ;     mov R8, R2
00000274:             ; 
00000274: EB00002F    ;     bl printdims
00000278:             ; 
00000278:             ; changearrget
00000278: E28F006B    ;     adrl R0, currentaskx
0000027C: E2800B07    ; 
00000280: EF000003    ;     swi 3
00000284:             ; 
00000284: EB000015    ;     bl changearrgetvalidint
00000288: E1A04000    ;     mov R4, R0
0000028C:             ; 
0000028C: E28F006B    ;     adrl R0, currentasky
00000290: E2800B07    ; 
00000294: EF000003    ;     swi 3
00000298:             ; 
00000298: EB000010    ;     bl changearrgetvalidint
0000029C: E1A05000    ;     mov R5, R0
000002A0:             ; 
000002A0: E3580001    ;     cmp R8, #1
000002A4: 1A000006    ;     bne changearrset
000002A8:             ; 
000002A8: E1540005    ;     cmp R4, R5
000002AC: AA000000    ;     bge changearrsizeerr
000002B0:             ; 
000002B0: EA000003    ;     b changearrset
000002B4:             ; 
000002B4:             ; changearrsizeerr
000002B4: E28F00BE    ;     adrl R0, changearrsizmsg
000002B8: E2800B07    ; 
000002BC: EF000003    ;     swi 3
000002C0:             ; 
000002C0: EAFFFFEC    ;     b changearrget
000002C4:             ; 
000002C4:             ; changearrset
000002C4:             ;     ;;now we have the two valid values so str them back
000002C4: E5464000    ;     strb R4, [R6]
000002C8: E5475000    ;     strb R5, [R7] 
000002CC:             ; 
000002CC: E1A00006    ;     mov R0, R6
000002D0: E1A01007    ;     mov R1, R7
000002D4:             ; 
000002D4: EB000017    ;     bl printdims
000002D8:             ; 
000002D8:             ; changearrend
000002D8: E8BD41F0    ;     pop {R14, R4-R8}
000002DC: E1A0F00E    ;     mov R15, R14
000002E0:             ; 
000002E0:             ; ;;And you thought the naming couldn't get worse \(*0*)/
000002E0:             ; changearrgetvalidint ;;basically an inner function
000002E0:             ; ;;INP --
000002E0:             ; ;;OUT in R0 is the gotten value
000002E0: E92D41F0    ;     push {R14, R4-R8}
000002E4:             ; changearrgetvalidintget
000002E4: E3A0000A    ;     ldr R0, =enter
000002E8: E3A01003    ;     mov R1, #3
000002EC: E3A02001    ;     mov R2, #1
000002F0: EB0001F4    ;     bl getstring
000002F4:             ; 
000002F4: E1A04000    ;     mov R4, R0 ;;save the string to free
000002F8:             ; 
000002F8: EB0001A8    ;     bl strtoi
000002FC:             ; 
000002FC: E1A05000    ;     mov R5, R0 ;;save the int value
00000300: E1A06001    ;     mov R6, R1 ;;save err code
00000304:             ; 
00000304: E1A00004    ;     mov R0, R4
00000308: EB0003DC    ;     bl free
0000030C:             ; 
0000030C: E3560000    ;     cmp R6, #0
00000310: 0A000002    ;     beq changearrgetvalidintcont
00000314:             ; 
00000314:             ; changearrgetvalidinterr
00000314: E24F0008    ;     adrl R0, changearrgetvalidinterr
00000318: EF000003    ;     swi 3
0000031C:             ; 
0000031C: EAFFFFF0    ;     b changearrgetvalidintget
00000320:             ; 
00000320:             ; changearrgetvalidintcont
00000320:             ;     ;;we now have an int value, need to do bounds checks
00000320: E3550000    ;     cmp R5, #0
00000324: DAFFFFFA    ;     ble changearrgetvalidinterr
00000328:             ; 
00000328: E35500FF    ;     cmp R5, #255
0000032C: CAFFFFF8    ;     bgt changearrgetvalidinterr
00000330:             ; 
00000330:             ; changearrgetvalidintend
00000330: E92D41F0    ;     push {R14, R4-R8}
00000334: E1A0F00E    ;     mov R15, R14
00000338:             ; 
00000338:             ; printdims
00000338:             ; ;;INP in R0 is addr. for x
00000338:             ; ;;INP in R1 is addr. for y
00000338:             ; ;;(_, _)
00000338:             ;     
00000338: E1A02000    ;     mov R2, R0
0000033C: E1A03001    ;     mov R3, R1
00000340:             ; 
00000340: E28F006F    ;     adrl R0, currentDims
00000344: E2800C1B    ; 
00000348: EF000003    ;     swi 3
0000034C:             ; 
0000034C: E28F0072    ;     adrl R0, bracket_open
00000350: E2800C1B    ; 
00000354: EF000003    ;     swi 3
00000358:             ; 
00000358: E5520000    ;     ldrb R0, [R2]
0000035C: EF000004    ;     swi 4
00000360:             ; 
00000360: E28F0EB6    ;     adrl R0, comma_space
00000364: E2800A01    ; 
00000368: EF000003    ;     swi 3
0000036C:             ; 
0000036C: E5530000    ;     ldrb R0, [R3]
00000370: EF000004    ;     swi 4
00000374:             ; 
00000374: E28F004F    ;     adrl R0, bracket_close
00000378: E2800C1B    ; 
0000037C: EF000003    ;     swi 3
00000380:             ; 
00000380: E3A0000A    ;     ldr R0, =nl
00000384: EF000000    ;     swi 0
00000388:             ; 
00000388: E1A0F00E    ;     mov R15, R14
0000038C:             ; 
0000038C:             ; changestep
0000038C: E28F0002    ;     adrl R0, step_b_d
00000390: E2800C06    ; 
00000394: E28F1012    ;     adrl R1, currentstep
00000398: E2811C1B    ; 
0000039C:             ; 
0000039C: EB00000C    ;     bl changebool
000003A0:             ; 
000003A0: EAFFFF89    ;     b changesetting
000003A4:             ; 
000003A4:             ; changeslow
000003A4: E28F00E9    ;     adrl R0, slow_b_d
000003A8: E2800C05    ; 
000003AC: E28F10E7    ;     adrl R1, currentslow
000003B0: E2811C1A    ; 
000003B4:             ; 
000003B4: EB000006    ;     bl changebool
000003B8:             ; 
000003B8: EAFFFF83    ;     b changesetting
000003BC:             ; 
000003BC:             ; changeerase
000003BC: E28F0E5D    ;     adrl R0, erase_b_d
000003C0: E2800000    ; 
000003C4: E28F1FB6    ;     adrl R1, currenterase
000003C8: E2811B06    ; 
000003CC:             ; 
000003CC: EB000000    ;     bl changebool
000003D0:             ; 
000003D0: EAFFFF7D    ;     b changesetting
000003D4:             ; 
000003D4:             ; changebool
000003D4:             ; ;;INP in R0 is the address of ___b_d
000003D4:             ; ;;INP in R1 is the address of the printing name
000003D4:             ; ;;OUT --
000003D4: E92D41F0    ;     push {R14, R4-R8}
000003D8:             ; 
000003D8: E1A04000    ;     mov R4, R0
000003DC: E1A05001    ;     mov R5, R1
000003E0:             ; 
000003E0: E1A00001    ;     mov R0, R1
000003E4: EF000003    ;     swi 3
000003E8:             ; 
000003E8: E5540000    ;     ldrb R0, [R4]
000003EC: E3500001    ;     cmp R0, #1
000003F0: 128F0097    ;     adrlne R0, off_msg
000003F4: 12800C1B    ; 
000003F8: 028F0FE3    ;     adrleq R0, on_msg
000003FC: 02800B06    ; 
00000400: EF000003    ;     swi 3
00000404:             ; 
00000404: EB000090    ;     bl newline
00000408:             ; 
00000408: E28F0015    ;     adrl R0, currentasknew_B
0000040C: E2800C1B    ; 
00000410: EF000003    ;     swi 3
00000414:             ; 
00000414:             ; changebool_cont
00000414: EF000001    ;     swi 1
00000418:             ; 
00000418: E2400030    ;     sub R0, R0, #48
0000041C: E3500001    ;     cmp R0, #1
00000420: 0A000006    ;     beq changebool_set
00000424: E3500000    ;     cmp R0, #0
00000428: 0A000004    ;     beq changebool_set
0000042C:             ; 
0000042C: EB000086    ;     bl newline
00000430:             ; 
00000430: E28F0FC2    ;     adrl R0, currentasknew_E
00000434: E2800B06    ; 
00000438: EF000003    ;     swi 3
0000043C:             ; 
0000043C: EAFFFFF4    ;     b changebool_cont
00000440:             ; 
00000440:             ; changebool_set
00000440: E5440000    ;     strb R0, [R4]
00000444:             ; 
00000444: EB000080    ;     bl newline
00000448:             ; 
00000448: E1A00005    ;     mov R0, R5
0000044C: EF000003    ;     swi 3
00000450:             ; 
00000450: E5540000    ;     ldrb R0, [R4]
00000454: E3500001    ;     cmp R0, #1
00000458: 128F002F    ;     adrlne R0, off_msg
0000045C: 12800C1B    ; 
00000460: 028F0FC9    ;     adrleq R0, on_msg
00000464: 02800B06    ; 
00000468: EF000003    ;     swi 3
0000046C:             ; 
0000046C: EB000076    ;     bl newline
00000470:             ; 
00000470:             ; changeboolend
00000470: E8BD41F0    ;     pop {R14, R4-R8}
00000474: E1A0F00E    ;     mov R15, R14
00000478:             ; 
00000478:             ; changedims
00000478:             ; ;;INP in R0 is addr. for x
00000478:             ; ;;INP in R1 is addr. for y
00000478:             ; ;;INP in R2 is boolean for require x < y. 1 for require
00000478: E28F0017    ;     adrl R0, width_d
0000047C: E2800C05    ; 
00000480: E28F1E51    ;     adrl R1, height_d
00000484: E2811000    ; 
00000488: E3A02000    ;     mov R2, #0
0000048C: EBFFFF74    ;     bl changearr
00000490:             ; 
00000490: EAFFFF4D    ;     b changesetting
00000494:             ; 
00000494:             ; changerange
00000494: E28F00FD    ;     adrl R0, range_min_d
00000498: E2800B01    ; 
0000049C: E28F10F6    ;     adrl R1, range_max_d
000004A0: E2811B01    ; 
000004A4: E3A02001    ;     mov R2, #1
000004A8: EBFFFF6D    ;     bl changearr
000004AC:             ; 
000004AC: EAFFFF46    ;     b changesetting
000004B0:             ; 
000004B0:             ; changeicons
000004B0:             ; 
000004B0:             ; changeitter
000004B0:             ; 
000004B0: EAFFFEEB    ;     b mainmenu
000004B4:             ; 
000004B4:             ; printhelp
000004B4: E28F00AF    ;     adrl R0, helpinfomsg
000004B8: E2800C17    ; 
000004BC: EF000003    ;     swi 3
000004C0:             ; 
000004C0: EF000001    ;     swi 1
000004C4:             ; 
000004C4: EAFFFEE6    ;     b mainmenu
000004C8:             ; 
000004C8:             ; newboard
000004C8: E3A00001    ;     mov R0, #1;;should get dims
000004CC: EB000266    ;     bl setupOptions
000004D0:             ; 
000004D0: EB0001BA    ;     bl setupGrid
000004D4:             ;     
000004D4: E59F44A8    ;     ldr R4, gridA
000004D8: E59F54A8    ;     ldr R5, gridB
000004DC:             ; 
000004DC: E3540000    ;     cmp R4, #0
000004E0: 0AFFFF27    ;     beq gridFail
000004E4: E3550000    ;     cmp R5, #0
000004E8: 0AFFFF25    ;     beq gridFail
000004EC:             ; 
000004EC: EAFFFEF4    ;     b mainloopstart
000004F0:             ; 
000004F0:             ; loadboard
000004F0:             ; ;;INP in R0 is the ptr to the SaveInfoHeader struct i.e. ptr to arr, current pos, max size
000004F0:             ; ;;RET in R0 0 for success in which case go to main loop, n/0 for err in which case return to ma
                      ; in menu
000004F0:             ; ;;display the saved grids
000004F0:             ; ;;ask for the index
000004F0:             ; ;;load the grids with the saved info
000004F0:             ; ;;ask the user for the settings
000004F0: E1A04000    ;     mov R4, R0 ;;save the struct ptr
000004F4:             ; 
000004F4:             ;     ;;pass ptr to listgrids
000004F4: EB00007A    ;     bl listGrids
000004F8:             ; 
000004F8: E5940008    ;     ldr R0, [R4, #8] ;;get the current position
000004FC: E3500000    ;     cmp R0, #0
00000500: 0A00004F    ;     beq loadboardempty
00000504:             ; 
00000504:             ; loadboardaskindex
00000504:             ;     ;;The grid has now been printed out we need to get the index to load
00000504: E28F0001    ;     adrl R0, loadboardaski
00000508: E2800C16    ; 
0000050C: EF000003    ;     swi 3
00000510:             ; 
00000510: E3A0000A    ;     ldr R0, =enter
00000514: E3E01000    ;     mov R1, #-1
00000518: E3A02001    ;     mov R2, #1
0000051C: EB000169    ;     bl getstring
00000520: E1A05000    ;     mov R5, R0
00000524:             ; 
00000524: EB000048    ;     bl newline
00000528:             ; 
00000528: E1A00005    ;     mov R0, R5
0000052C: EB00011B    ;     bl strtoi
00000530: E1A06000    ;     mov R6, R0
00000534: E1A07001    ;     mov R7, R1
00000538:             ;     ;;ERR codes
00000538:             ;     ;;  0 is success
00000538:             ;     ;;  1 is attempted -ve
00000538:             ;     ;;  2 is use of non-numeric characters
00000538:             ;     ;;  3 is value out of range of integer
00000538:             ;     ;;  4 is null string given
00000538:             ; 
00000538: E1A00005    ;     mov R0, R5
0000053C: EB00034F    ;     bl free
00000540:             ; 
00000540: E1A00006    ;     mov R0, R6
00000544: E1A01007    ;     mov R1, R7
00000548:             ; 
00000548: E3510001    ;     cmp R1, #1
0000054C: 0A000039    ;     beq loadboardret
00000550:             ; 
00000550: E3510000    ;     cmp R1, #0
00000554: 0A000003    ;     beq loadboardindex
00000558:             ; 
00000558: E28F0037    ;     adrl R0, loadboardifail
0000055C: E2800C16    ; 
00000560: EF000003    ;     swi 3
00000564:             ; 
00000564: EAFFFFE6    ;     b loadboardaskindex
00000568:             ; 
00000568:             ; loadboardindex
00000568:             ; ;;we now have an index lets check if its in range and then load the board
00000568:             ;     ;;should be +ve so don't need to check < 0
00000568: E5941008    ;     ldr R1, [R4, #8] ;;get the current position, this is where things get added so index < curr
                      ; entposition
0000056C: E1500001    ;     cmp R0, R1
00000570: BA000003    ;     blt loadboardmain
00000574:             ; 
00000574: E28F003E    ;     adrl R0, loadboardirerr
00000578: E2800C16    ; 
0000057C: EF000003    ;     swi 3
00000580: EAFFFFDF    ;     b loadboardaskindex
00000584:             ; 
00000584:             ; loadboardmain
00000584:             ; ;;now we know that the index is valid we can load the grid
00000584:             ; ;;
00000584:             ; ;;need to free current grid
00000584:             ; ;;need to create a copy of the snapshot and set gridA to it 
00000584:             ; ;;return to main menu
00000584: E5941000    ;     ldr R1, [R4, #0] ;;get the array of grids
00000588: E3A0200C    ;     ldr R2, =sizeofSaveI
0000058C: E0201290    ;     mla R0, R0, R2, R1 ;;R0 = index * sizeofSaveI + grid.addr
00000590:             ; 
00000590: E5905000    ;     ldr R5, [R0, #0] ;;get the address of that grid
00000594: E5D06008    ;     ldrb R6, [R0, #8] ;;get the width
00000598: E5D07009    ;     ldrb R7, [R0, #9] ;;get the height
0000059C:             ; 
0000059C: E0000796    ;     mul R0, R6, R7 ;;get the required size
000005A0: E1A09000    ;     mov R9, R0 ;;save the number of bytes
000005A4:             ; 
000005A4: EB00030B    ;     bl malloc
000005A8:             ; 
000005A8: E3500000    ;     cmp R0, #0
000005AC: 0A00001D    ;     beq loadboardmallocfail
000005B0:             ; 
000005B0: E1A08000    ;     mov R8, R0 ;;save the new grid arr
000005B4:             ; 
000005B4:             ;     ;;need to copy the saved grid into the new grid
000005B4:             ; 
000005B4: E1A00005    ;     mov R0, R5  ;;src is the saved grid
000005B8: E1A01008    ;     mov R1, R8  ;;dst is the new grid
000005BC: E1A02009    ;     mov R2, R9  ;;bytes is in R9 already from width and height
000005C0: EB00011F    ;     bl memcpy
000005C4:             ; 
000005C4: E59F03B8    ;     ldr R0, gridA
000005C8: EB00032C    ;     bl free
000005CC:             ; 
000005CC: E58F83B0    ;     str R8, gridA
000005D0:             ; 
000005D0:             ;     ;;also need to check if the old gridB is big enough
000005D0: E5DF83B7    ;     ldrb R8, width
000005D4: E5DFA3B4    ;     ldrb R10, height
000005D8: E1560008    ;     cmp R6, R8
000005DC: 1A000002    ;     bne loadboardmallocB
000005E0: E157000A    ;     cmp R7, R10
000005E4: 1A000000    ;     bne loadboardmallocB
000005E8:             ; 
000005E8: EA000006    ;     b loadboardskipB
000005EC:             ; 
000005EC:             ; loadboardmallocB
000005EC: E59F0394    ;     ldr R0, gridB
000005F0: EB000322    ;     bl free
000005F4:             ; 
000005F4: E1A00009    ;     mov R0, R9
000005F8: EB0002F6    ;     bl malloc
000005FC:             ; 
000005FC: E3500000    ;     cmp R0, #0
00000600: 0A000008    ;     beq loadboardmallocfail
00000604:             ; 
00000604: E58F037C    ;     str R0, gridB
00000608:             ; 
00000608:             ; loadboardskipB
00000608: E5CF637F    ;     strb R6, width
0000060C: E5CF737C    ;     strb R7, height ;;overwrite the active grid information
00000610:             ; 
00000610: E28F00FF    ;     adrl R0, loadboardsucmsg
00000614: E2800C15    ; 
00000618: EF000003    ;     swi 3
0000061C:             ; 
0000061C: E3A00000    ;     mov R0, #0 ;;skip asking dims as they've been loaded
00000620: EB000211    ;     bl setupOptions
00000624:             ; 
00000624: EA000007    ;     b loadboardsucc
00000628:             ; 
00000628:             ; loadboardmallocfail
00000628: E28F00A7    ;     adrl R0, loadboardmlcerr
0000062C: E2800C15    ; 
00000630: EF000003    ;     swi 3
00000634:             ; 
00000634: EA000002    ;     b loadboarderr
00000638:             ; 
00000638:             ; loadboardret
00000638: E28F003F    ;     adrl R0, loadboardretmsg
0000063C: E2800C15    ; 
00000640: EF000003    ;     swi 3
00000644:             ; 
00000644:             ; loadboardempty
00000644:             ; loadboarderr
00000644: EAFFFE86    ;     b mainmenu
00000648:             ; loadboardsucc
00000648: EAFFFE9D    ;     b mainloopstart
0000064C:             ; 
0000064C:             ; newline
0000064C: E3A0000A    ;     ldr R0, =nl
00000650: EF000000    ;     swi 0
00000654:             ; 
00000654: E1A0F00E    ;     mov R15, R14
00000658:             ; 
00000658:             ; step
00000658:             ; ;;INP in R0 is the gridHeaderStruct ptr [[todo]]
00000658:             ; ;;INP in R1 is the active grid ptr
00000658:             ; ;;OUT in R0 is 1 if should return to main menu, else 0.
00000658:             ; 
00000658:             ; ;;get user input
00000658:             ; ;;if q -> jump to main menu
00000658:             ; ;;if s -> ask for name, bl saveGrid with name
00000658: E92D41F0    ;     push {R14, R4-R8}
0000065C: E1A04000    ;     mov R4, R0 ;;save the struct 
00000660: E1A05001    ;     mov R5, R1
00000664:             ; 
00000664: EF000001    ;     swi 1
00000668:             ; 
00000668: E3500071    ;     cmp R0, #'q'
0000066C: 0A000017    ;     beq stependfail ;;bad name, shame I can't change it eh
00000670:             ; 
00000670: E3500073    ;     cmp R0, #'s'
00000674: 1A000017    ;     bne stependsucc
00000678:             ; 
00000678: E28F001C    ;     adrl R0, askname
0000067C: E2800A01    ; 
00000680: EF000003    ;     swi 3
00000684:             ; 
00000684: E3A0000A    ;     ldr R0, =enter
00000688: E3E01000    ;     mov R1, #-1
0000068C: E3A02001    ;     mov R2, #1
00000690: EB00010C    ;     bl getstring
00000694:             ; 
00000694: E1A01000    ;     mov R1, R0 ;;char* name
00000698: E1A00004    ;     mov R0, R4 ;;gridinfo* 
0000069C: E1A02005    ;     mov R2, R5 ;;active grid
000006A0: EB000046    ;     bl saveGrid
000006A4:             ; 
000006A4: EBFFFFE8    ;     bl newline
000006A8:             ; 
000006A8: E28F00C1    ;     adrl R0, savedchoice
000006AC: E2800C0F    ; 
000006B0: EF000003    ;     swi 3
000006B4:             ; 
000006B4: EF000001    ;     swi 1
000006B8: EF000000    ;     swi 0
000006BC: E3500059    ;     cmp R0, #'Y'
000006C0:             ; 
000006C0: E3A0000A    ;     ldr R0, =nl
000006C4: EF000000    ;     swi 0
000006C8:             ; 
000006C8: 0A000000    ;     beq stependfail
000006CC: EA000001    ;     b stependsucc
000006D0:             ; 
000006D0:             ; stependfail
000006D0: E3A00001    ;     mov R0, #1
000006D4: EA000000    ;     b stepend
000006D8:             ; 
000006D8:             ; stependsucc
000006D8: E3A00000    ;     mov R0, #0
000006DC:             ; 
000006DC:             ; stepend
000006DC: E8BD41F0    ;     pop {R14, R4-R8}
000006E0: E1A0F00E    ;     mov R15, R14
000006E4:             ; 
000006E4:             ; listGrids
000006E4:             ; ;;INP in R0 is the ptr to the gridInfo struct
000006E4:             ; ;;RET --
000006E4:             ; ;;Grid info struct
000006E4:             ; ;;  - SaveInfoStruct* array
000006E4:             ; ;;  - int max size of arr
000006E4:             ; ;;  - int current position in arr
000006E4:             ; 
000006E4:             ; ;;loops through the array of grids (if any) printing their names, and dims, ask to print grid
000006E4: E92D47F0    ;     push {R14, R4-R10}
000006E8:             ; 
000006E8: E5904000    ;     ldr R4, [R0, #0] ;;get the array ptr
000006EC: E5905008    ;     ldr R5, [R0, #8] ;;current position
000006F0:             ; 
000006F0: E3550000    ;     cmp R5, #0
000006F4: 0A00002C    ;     beq listGridsEmpty
000006F8:             ; 
000006F8:             ; ;;if current position == 1: print("There are no saved grids")
000006F8:             ; ;;for i from 0 to current position
000006F8:             ; ;;  getname(4)
000006F8:             ; ;;  getwidth(8)
000006F8:             ; ;;  getheight(9)
000006F8:             ; ;;  print("There is a grid called %s with dims (%d, %d)")
000006F8: E3A01000    ;     mov R1, #0 ;;i
000006FC: E3A0200C    ;     ldr R2, =sizeofSaveI
00000700:             ; 
00000700: E28F002D    ;     adrl R0, listgridmsg
00000704: E2800C15    ; 
00000708: EF000003    ;     swi 3
0000070C:             ; 
0000070C: E28F0F51    ;     adrl R0, cutoff
00000710: E2800B05    ; 
00000714: EF000003    ;     swi 3
00000718:             ; 
00000718:             ; listGridsLoop
00000718: E1510005    ;     cmp R1, R5
0000071C: 0A000025    ;     beq listGridsLend
00000720:             ; 
00000720: E0234291    ;     mla R3, R1, R2, R4 ;;R3 = i * sizeof(saveInfo) + array
00000724: E5936004    ;     ldr R6, [R3, #4] ;;load the name ptr
00000728: E5D37008    ;     ldrb R7, [R3, #8] ;;load the width
0000072C: E5D38009    ;     ldrb R8, [R3, #9] ;;load the height
00000730:             ; 
00000730: E28F00B1    ;     adrl R0, gridloadpindex
00000734: E2800C13    ; 
00000738: EF000003    ;     swi 3
0000073C:             ; 
0000073C: E3A0003A    ;     mov R0, #':'
00000740: EF000000    ;     swi 0
00000744:             ; 
00000744: E1A00001    ;     mov R0, R1
00000748: EF000004    ;     swi 4
0000074C:             ; 
0000074C: EBFFFFBE    ;     bl newline
00000750:             ; 
00000750: E28F009A    ;     adrl R0, gridloadpname
00000754: E2800C13    ; 
00000758: EF000003    ;     swi 3
0000075C:             ; 
0000075C: E1A00006    ;     mov R0, R6
00000760: EF000003    ;     swi 3
00000764:             ; 
00000764: EBFFFFB8    ;     bl newline
00000768:             ; 
00000768: E28F008A    ;     adrl R0, gridloadpwidth
0000076C: E2800C13    ; 
00000770: EF000003    ;     swi 3
00000774:             ; 
00000774: E1A00007    ;     mov R0, R7
00000778: EF000004    ;     swi 4
0000077C:             ; 
0000077C: EBFFFFB2    ;     bl newline
00000780:             ; 
00000780: E28F007B    ;     adrl R0, gridloadpheight
00000784: E2800C13    ; 
00000788: EF000003    ;     swi 3
0000078C:             ; 
0000078C: E1A00008    ;     mov R0, R8
00000790: EF000004    ;     swi 4
00000794:             ; 
00000794: EBFFFFAC    ;     bl newline
00000798:             ; 
00000798:             ;     ;;[[Prob]  Printing the grid uses the stored width and height, I could change it to use a p
                      ; assed in
00000798:             ;     ;;             version but do the other areas have enough registers to cope? probably not.
00000798:             ;     ;;             Would have to swap the width and height with the loaded versions - I really 
                      ; don't like this idea
00000798:             ; 
00000798: E2811001    ;     add R1, R1, #1
0000079C:             ; 
0000079C: E28F00B4    ;     adrl R0, cutoff
000007A0: E2800B05    ; 
000007A4: EF000003    ;     swi 3
000007A8:             ; 
000007A8: EAFFFFDA    ;     b listGridsLoop
000007AC:             ; 
000007AC:             ; listGridsEmpty
000007AC: E28F00D5    ;     adrl R0, gridloadempty
000007B0: E2800C12    ; 
000007B4: EF000003    ;     swi 3
000007B8:             ; 
000007B8:             ; listGridsLend
000007B8:             ; listGridsEnd
000007B8: E8BD47F0    ;     pop {R14, R4-R10}
000007BC: E1A0F00E    ;     mov R15, R14
000007C0:             ; 
000007C0:             ; saveGrid
000007C0:             ; ;;INP in R0 is the ptr gridInfo struct (in the main's stackframe)
000007C0:             ; ;;INP in R1 is the char* to the name
000007C0:             ; ;;INP in R2 is the active grid
000007C0:             ; ;;RET in R0 is an errcode or 0 for success. 1 for malloc error
000007C0:             ; 
000007C0:             ; ;;if reachedCap -> realloc + inc maxsize
000007C0:             ; ;;copy the current grid to another loc and place info in gridArr
000007C0:             ; ;;inc current index
000007C0: E92D47F0    ;     push {R14, R4-R10}
000007C4:             ; 
000007C4: E1A04000    ;     mov R4, R0
000007C8: E1A05001    ;     mov R5, R1
000007CC: E1A0A002    ;     mov R10, R2
000007D0:             ; 
000007D0: E5942008    ;     ldr R2, [R4, #8] ;;get the current index
000007D4: E5943004    ;     ldr R3, [R4, #4] ;;get the maxsize
000007D8:             ; 
000007D8: E1520003    ;     cmp R2, R3
000007DC: 0A000000    ;     beq saveGridResize
000007E0: EA00000D    ;     b saveGridAdd
000007E4:             ; 
000007E4:             ; saveGridResize
000007E4:             ;     ;;maxsize in R3
000007E4: E1A06083    ;     mov R6, R3, lsl #1 ;;double the capacity
000007E8: E3A0700C    ;     ldr R7, =sizeofSaveI
000007EC: E0070796    ;     mul R7, R6, R7 ;;get the number of bytes
000007F0:             ; 
000007F0: E1A00007    ;     mov R0, R7
000007F4: EB000277    ;     bl malloc ;;get the new grid
000007F8:             ; 
000007F8: E3500000    ;     cmp R0, #0 ;;if malloc failed then don't do any saving
000007FC: 0A000020    ;     beq saveGridFailMalloc
00000800:             ; 
00000800: E1A01000    ;     mov R1, R0
00000804: E1A08000    ;     mov R8, R0 ;;save of ptr
00000808:             ; 
00000808:             ;     ;;now that we have the new grid we need to memcpy the bytes from the original into the new 
                      ; one
00000808: E5940000    ;     ldr R0, [R4, #0] ;;get the array ptr
0000080C:             ;     ;;R1 has the malloced address
0000080C: E1A020A7    ;     mov R2, R7, lsr #1 ;;not great, this is the double cap halfed, means no mul again
00000810: EB00008B    ;     bl memcpy
00000814:             ; 
00000814:             ;     ;;assume success because I didn't give memcpy an err code :)
00000814:             ;     ;;need to store the new size and arr ptr in the gridinfo struct
00000814:             ; 
00000814: E5848000    ;     str R8, [R4, #0]
00000818: E5846004    ;     str R6, [R4, #4]
0000081C:             ; 
0000081C:             ; saveGridAdd
0000081C:             ; ;;add the current grid to the array
0000081C: E5946000    ;     ldr R6, [R4, #0] ;;get the arr ptr
00000820: E5947008    ;     ldr R7, [R4, #8] ;;get current index
00000824:             ; 
00000824:             ;     ;;ptr is 4 bytes
00000824:             ;     ;;we're adding the struct of 
00000824:             ;     ;;  |-grid*     (ptr)
00000824:             ;     ;;  |-char*     (ptr)
00000824:             ;     ;;  |-width     (byte)
00000824:             ;     ;;  `-height    (byte)
00000824:             ; 
00000824:             ;     ;;we need to copy the current array
00000824: E5DF8163    ;     ldrb R8, width
00000828: E5DF9160    ;     ldrb R9, height
0000082C: E0080998    ;     mul R8, R8, R9 ;;get the number of bytes in grid
00000830:             ; 
00000830: E1A00008    ;     mov R0, R8
00000834: EB000267    ;     bl malloc ;;allocate a new grid
00000838:             ; 
00000838: E3500000    ;     cmp R0, #0
0000083C: 0A000010    ;     beq saveGridFailMalloc
00000840:             ; 
00000840: E92D0100    ;     push {R8} ;; :(
00000844:             ; 
00000844: E3A0800C    ;     ldr R8, =sizeofSaveI
00000848: E0266897    ;     mla R6, R7, R8, R6 ;;currentindex * sizeof(Gridinfo) + arrptr
0000084C: E5860000    ;     str R0, [R6, #0] ;;store the grid*
00000850: E5865004    ;     str R5, [R6, #4] ;;store the char*
00000854: E5DF8133    ;     ldrb R8, width
00000858: E5C68008    ;     strb R8, [R6, #8]
0000085C: E5C69009    ;     strb R9, [R6, #9]
00000860:             ; 
00000860: E8BD0100    ;     pop {R8}
00000864:             ; 
00000864: E1A01000    ;     mov R1, R0 ;;dst
00000868: E1A0000A    ;     mov R0, R10 ;;src
0000086C: E1A02008    ;     mov R2, R8 ;;num bytes
00000870: EB000073    ;     bl memcpy ;;copy the grid into the new location
00000874:             ; 
00000874:             ;     ;;inc the position
00000874: E5940008    ;     ldr R0, [R4, #8]
00000878: E2800001    ;     add R0, R0, #1
0000087C: E5840008    ;     str R0, [R4, #8]
00000880:             ; 
00000880: EA000001    ;     b saveGridSucc
00000884:             ; 
00000884:             ; saveGridFailMalloc
00000884: E3A00001    ;     mov R0, #1
00000888: EA000000    ;     b saveGridEnd
0000088C:             ; 
0000088C:             ; saveGridSucc
0000088C: E3A00000    ;     mov R0, #0
00000890:             ; 
00000890:             ; saveGridEnd
00000890: E8BD47F0    ;     pop {R14, R4-R10}
00000894: E1A0F00E    ;     mov R15, R14
00000898:             ; 
00000898:             ; erase
00000898:             ; ;;INP in R0 is the itters
00000898:             ; ;;for (width * height + 1) * 2 + 1
00000898:             ; ;;      print('\b')
00000898: E1A01000    ;     mov R1, R0
0000089C:             ; 
0000089C:             ; eraseloop
0000089C: E3510000    ;     cmp R1, #0
000008A0: 0A000003    ;     beq eraseend
000008A4:             ; 
000008A4: E3A00008    ;     ldr R0, =backspace
000008A8: EF000000    ;     swi 0
000008AC:             ; 
000008AC: E2411001    ;     sub R1, R1, #1
000008B0: EAFFFFF9    ;     b eraseloop
000008B4:             ; 
000008B4:             ; eraseend
000008B4: E1A0F00E    ;     mov R15, R14
000008B8:             ; 
000008B8:             ; slow
000008B8: E3A010FF    ;     mov R1, #0xFF
000008BC: E1A01081    ;     mov R1, R1, lsl #1
000008C0:             ; 
000008C0:             ; slowloop
000008C0: E3510000    ;     cmp R1, #0
000008C4: 0A000005    ;     beq slowend
000008C8:             ; 
000008C8: E3A00020    ;     mov R0, #' '
000008CC: EF000000    ;     swi 0
000008D0: E3A00008    ;     ldr R0, =backspace
000008D4: EF000000    ;     swi 0
000008D8:             ; 
000008D8: E2411001    ;     sub R1, R1, #1
000008DC: EAFFFFF7    ;     b slowloop
000008E0:             ; 
000008E0:             ; slowend
000008E0: E1A0F00E    ;     mov R15, R14
000008E4:             ; 
000008E4:             ; heapclean
000008E4:             ; ;;zero out all memory in the heap (debugging uses)
000008E4: E28F0FAB    ;     adrl R0, heapstart
000008E8: E2800B05    ; 
000008EC: E3A01601    ;     ldr R1, =max_addr ;;stores the end of the heap
000008F0: E3A02801    ;     ldr R2, =stack_size
000008F4: E0411002    ;     sub R1, R1, R2 ;; R1 = max_addr - stack_size which should be the heap end
000008F8: E3C11003    ;     and R1, R1, #-4 ;;align to 4 byte boundry just in case
000008FC: E3A03000    ;     mov R3, #0
00000900:             ; heapcleanloop ;;starting at heapstart
00000900: E1500001    ;     cmp R0, R1
00000904: 0A000002    ;     beq heapcleanend
00000908: E5003000    ;     str R3, [R0] ;;store 0 in loc
0000090C: E2800004    ;     add R0, R0, #4 ;;inc by a word
00000910: EAFFFFFA    ;     b heapcleanloop
00000914:             ; heapcleanend
00000914: E1A0F00E    ;     mov R15, R14
00000918:             ; 
00000918:             ; strlen
00000918:             ; ;;INP in R0 is the address of the string
00000918:             ; ;;OUT in R0 is the length of the null terminated string
00000918:             ; 
00000918:             ; ;;len = 0
00000918:             ; ;;while(inp[len] != \0) {len++;}
00000918:             ; ;;return len
00000918:             ; 
00000918: E3A01000    ;     mov R1, #0 ;;len
0000091C: E3500000    ;     cmp R0, #0
00000920: 0A000004    ;     beq strlenend
00000924:             ; 
00000924:             ; strlenloop
00000924: E7D02001    ;     ldrb R2, [R0, R1]
00000928: E3520000    ;     cmp R2, #0
0000092C: 0A000001    ;     beq strlenend
00000930: E2811001    ;     add R1, R1, #1
00000934: EAFFFFFA    ;     b strlenloop
00000938:             ; 
00000938:             ; strlenend
00000938: E1A00001    ;     mov R0, R1
0000093C: E1A0F00E    ;     mov R15, R14
00000940:             ; 
00000940:             ; 
00000940:             ; align
00000940:             ; ;;;HAD TO MOVE HERE FOR THE RANGE OF LDR
00000940:             ; 
00000940: 00010000    ; heaphead        defw 0x10000 ;;default start changed to addr of heapstart 
00000944:             ; 
00000944:             ; ;;Integer defs
00000944: FFFFFFFF    ; offsets         defw -1,-1,-1,0,-1,1,0,-1,0,1,1,-1,1,0,1,1 ;;[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1
00000948: FFFFFFFF    ; ],[1,-1],[1,0],[1,1]]
0000094C: FFFFFFFF    ; 
00000950: 00000000    ; 
00000954: FFFFFFFF    ; 
00000958: 00000001    ; 
0000095C: 00000000    ; 
00000960: FFFFFFFF    ; 
00000964: 00000000    ; 
00000968: 00000001    ; 
0000096C: 00000001    ; 
00000970: FFFFFFFF    ; 
00000974: 00000001    ; 
00000978: 00000000    ; 
0000097C: 00000001    ; 
00000980: 00000001    ; 
00000984:             ; 
00000984:             ; ;;Grid addresses
00000984: 00000000    ; gridA           defw 0
00000988: 00000000    ; gridB           defw 0
0000098C:             ; 
0000098C:             ; ;;options
0000098C: 00          ; erase_b         defb 0
0000098D: 00          ; slow_b          defb 0
0000098E: 00          ; step_b          defb 0
0000098F: 12          ; width           defb 18
00000990: 12          ; height          defb 18
00000991: 01          ; range_min       defb 1
00000992: 1E          ; range_max       defb 30
00000993: 19          ; maxitters       defb 25
00000994:             ; 
00000994:             ; ;;default options
00000994: 00          ; erase_b_d       defb 0
00000995: 00          ; slow_b_d        defb 0
00000996: 01          ; step_b_d        defb 1
00000997: 12          ; width_d         defb 18
00000998: 12          ; height_d        defb 18
00000999: 01          ; range_min_d     defb 1
0000099A: 1E          ; range_max_d     defb 30
0000099B: 19          ; maxitters_d     defb 25
0000099C:             ; 
0000099C: 58          ; alive_c         defb 'X'
0000099D: 2D          ; dead_c          defb '-'
0000099E: 23          ; ptr_c           defb '#'
0000099F:             ; 
000009A0:             ; align
000009A0:             ; 
000009A0:             ; strtoi
000009A0:             ; ;;INP in R0 is the address of the string
000009A0:             ; ;;OUT in R0 is the value created
000009A0:             ; ;;OUT in R1 is the err code
000009A0:             ; ;;
000009A0:             ; ;;ERR codes
000009A0:             ; ;;  0 is success
000009A0:             ; ;;  1 is attempted -ve
000009A0:             ; ;;  2 is use of non-numeric characters
000009A0:             ; ;;  3 is value out of range of integer
000009A0:             ; ;;  4 is null string given
000009A0:             ; 
000009A0:             ; ;;  example inp
000009A0:             ; ;;  12234       len = 5
000009A0:             ; ;;      ^-find end
000009A0:             ; ;;  tot = 0
000009A0:             ; ;;  for i from end to 0:
000009A0:             ; ;;      tot += inp[i] * (10 ** (len(inp) - i - 1))
000009A0:             ; ;;  +some checks for valid input
000009A0:             ; 
000009A0:             ; ;;This will take in an address to the start of a string and attempt to convert it into an integ
                      ; er
000009A0:             ; ;;String is only valid when all characters are numerical
000009A0:             ; ;;For now it does not accept -ve numbers
000009A0:             ; 
000009A0: E92D41F0    ;     push {R14, R4-R8}
000009A4: E1A04000    ;     mov R4, R0  ;;R4 holds the addr
000009A8:             ; 
000009A8: E3500000    ;     cmp R0, #0
000009AC: 03A01004    ;     moveq R1, #4
000009B0: 0A00001E    ;     beq strtoiendfail ;;null given so err code = 4 and end
000009B4:             ; 
000009B4: EBFFFFD7    ;     bl strlen
000009B8: E1A05000    ;     mov R5, R0  ;;R5 holds the len of the string
000009BC:             ; 
000009BC: E3550000    ;     cmp R5, #0
000009C0: 0A00001C    ;     beq strtoiendsucc ;;if len(string) == 0 then return 0
000009C4:             ; 
000009C4: E5D46000    ;     ldrb R6, [R4, #0]
000009C8: E356002D    ;     cmp R6, #45
000009CC: 0A000012    ;     beq strtoifailminus
000009D0:             ; 
000009D0: E3A06000    ;     mov R6, #0  ;;R6 holds the total
000009D4: E3A07001    ;     mov R7, #1  ;;R7 holds the **
000009D8: E2458001    ;     sub R8, R5, #1  ;;R8 is i which starts at end (len - 1)
000009DC: E3A0300A    ;     mov R3, #10 ;;mul to **
000009E0:             ; 
000009E0:             ; strtoiloop
000009E0: E3580000    ;     cmp R8, #0
000009E4: BA00000A    ;     blt strtoilend
000009E8:             ; 
000009E8: E7D42008    ;     ldrb R2, [R4, R8]
000009EC: E2422030    ;     sub R2, R2, #48
000009F0:             ; 
000009F0: E3520000    ;     cmp R2, #0
000009F4: BA00000C    ;     blt strtoifailnonnum
000009F8: E3520009    ;     cmp R2, #9
000009FC: CA00000A    ;     bgt strtoifailnonnum
00000A00:             ; 
00000A00: E0266792    ;     mla R6, R2, R7, R6 ;;total = (inp[i] * (**)) + total -> total += inp[i] * (**)
00000A04: 6A000006    ;     bvs strtoifailoutrange
00000A08: E0070397    ;     mul R7, R7, R3
00000A0C:             ; 
00000A0C: E2488001    ;     sub R8, R8, #1
00000A10:             ; 
00000A10: EAFFFFF2    ;     b strtoiloop
00000A14:             ; 
00000A14:             ; 
00000A14:             ; ;;branches are expensive - should this just be rep RET? probably doesn't matter at this scale
00000A14:             ; strtoilend
00000A14: E1A00006    ;     mov R0, R6
00000A18: EA000006    ;     b strtoiendsucc
00000A1C:             ; 
00000A1C:             ; strtoifailminus
00000A1C: E3A01001    ;     mov R1, #1
00000A20: EA000002    ;     b strtoiendfail
00000A24:             ; 
00000A24:             ; strtoifailoutrange
00000A24: E3A01003    ;     mov R1, #3
00000A28: EA000000    ;     b strtoiendfail
00000A2C:             ; 
00000A2C:             ; strtoifailnonnum
00000A2C: E3A01002    ;     mov R1, #2
00000A30:             ; 
00000A30:             ; strtoiendfail
00000A30: E3A00000    ;     mov R0, #0
00000A34: EA000000    ;     b strtoiend
00000A38:             ; 
00000A38:             ; strtoiendsucc
00000A38: E3A01000    ;     mov R1, #0
00000A3C:             ; 
00000A3C:             ; strtoiend
00000A3C: E8BD41F0    ;     pop {R14, R4-R8}
00000A40: E1A0F00E    ;     mov R15, R14
00000A44:             ; 
00000A44:             ; memcpy
00000A44:             ; ;;INP in R0 is the addr of src
00000A44:             ; ;;INP in R1 is the addr of dst
00000A44:             ; ;;INP in R2 is the number of bytes to copy
00000A44:             ; 
00000A44:             ; ;;check if src and dst are alliged
00000A44:             ; ;;If different then write bytes
00000A44:             ; ;;If same then go to 4byte boundry
00000A44:             ; ;;  Write words of bytes2copy / 4
00000A44:             ; ;;  Write remaining bytes
00000A44: E92D41F0    ;     push {R14, R4-R8}
00000A48:             ; 
00000A48: E2004003    ;     and R4, R0, #0b11
00000A4C: E2015003    ;     and R5, R1, #0b11
00000A50:             ; 
00000A50: E1540005    ;     cmp R4, R5
00000A54: 1A00000E    ;     bne memcpyallbytes
00000A58:             ; 
00000A58:             ;     ;;If they are the same then cpy R4 bytes and then do words
00000A58: E0422004    ;     sub R2, R2, R4;; bytes2cpy -= bytes we are about to write
00000A5C: E1A03004    ;     mov R3, R4
00000A60: EB00000E    ;     bl memcpybytes
00000A64:             ; 
00000A64:             ;     ;;Now find the number of words that can be written i.e. bytes2cpy / 4 (bytes2cpy >> 2)
00000A64: E3C23003    ;     and R3, R2, #-4 ;;the number of bytes to write that make up the words
00000A68: E3A04000    ;     mov R4, #0 ;;i
00000A6C:             ; memcpywordsloop
00000A6C: E1540003    ;     cmp R4, R3
00000A70: 0A000003    ;     beq memcpywordslend
00000A74:             ; 
00000A74: E7906004    ;     ldr R6, [R0, R4]
00000A78: E7816004    ;     str R6, [R1, R4]
00000A7C:             ;     
00000A7C: E2844004    ;     add R4, R4, #4
00000A80:             ; 
00000A80: EAFFFFF9    ;     b memcpywordsloop
00000A84:             ;     
00000A84:             ; memcpywordslend
00000A84:             ; ;;Now copy the remaining bytes
00000A84: E2022003    ;     and R2, R2, #0b11
00000A88: E1A03002    ;     mov R3, R2
00000A8C: EB000003    ;     bl memcpybytes
00000A90: EA00000A    ;     b memcpyend
00000A94:             ; 
00000A94:             ; memcpyallbytes
00000A94: E1A03002    ;     mov R3, R2
00000A98: EB000000    ;     bl memcpybytes
00000A9C: EA000007    ;     b memcpyend
00000AA0:             ; 
00000AA0:             ; memcpybytes
00000AA0:             ; ;;This is an internal function to memcpy and so doesn't follow the calling convention, it also 
                      ; assumes values are in place from memcpy
00000AA0:             ; ;;for (int i = 0; i < byte2cpy; i++) {
00000AA0:             ; ;;      *(dst + i) = *(src + i)
00000AA0:             ; ;;INP in R3 is the number of bytes to copy
00000AA0: E3A05000    ;     mov R5, #0 ;;i
00000AA4:             ; memcpybytesloop
00000AA4: E1550003    ;     cmp R5, R3
00000AA8: 0A000003    ;     beq memcpybyteslend ;;i < bytes2cpy
00000AAC:             ; 
00000AAC: E7D04005    ;     ldrb R4, [R0, R5]
00000AB0: E7C14005    ;     strb R4, [R1, R5] ;;dst[i] = src[i]
00000AB4:             ; 
00000AB4: E2855001    ;     add R5, R5, #1 ;;i++
00000AB8:             ; 
00000AB8: EAFFFFF9    ;     b memcpybytesloop
00000ABC:             ; 
00000ABC:             ; memcpybyteslend
00000ABC: E1A0F00E    ;     mov R15, R14
00000AC0:             ; 
00000AC0:             ; memcpyend
00000AC0: E8BD41F0    ;     pop {R14, R4-R8}
00000AC4: E1A0F00E    ;     mov R15, R14
00000AC8:             ; 
00000AC8:             ; getstring
00000AC8:             ; ;;INP in R0 the terminator character
00000AC8:             ; ;;INP in R1 the max number of characters or -1 for no max
00000AC8:             ; ;;INP in R2 boolean (non-0/0) for if letters should be printed out as well
00000AC8:             ; ;;RET in R0 a ptr to the memory address
00000AC8:             ; ;;
00000AC8:             ; ;;Dynamically allocate memory to support large string
00000AC8:             ; 
00000AC8:             ; ;;buff = malloc(minBytes)
00000AC8:             ; ;;while (input != terminator && pos < maxchars) 
00000AC8:             ; ;;  buff[pos] = input
00000AC8:             ; ;;  putchar(input)
00000AC8:             ; ;;  if (pos > buffSize)
00000AC8:             ; ;;      nBuff = malloc(buffSize << 1)
00000AC8:             ; ;;      memcpy from buff to nBuff
00000AC8:             ; ;;      free buff
00000AC8:             ; ;;      buff = nBuff
00000AC8:             ; 
00000AC8: E92D47F0    ;     push {R14, R4-R10}
00000ACC:             ; 
00000ACC: E1A08000    ;     mov R8, R0 ;;now holds terminator
00000AD0: E1A09001    ;     mov R9, R1 ;;nax chars
00000AD4: E3590000    ;     cmp R9, #0
00000AD8: 0A000031    ;     beq getstringEnd
00000ADC:             ;     ;sub R9, R9, #1 ;;reduce by 1 to use later
00000ADC: E1A0A002    ;     mov R10, R2 ;;print bool
00000AE0:             ; 
00000AE0: E3A06008    ;     ldr R6, =minBuffSize ;;R6 will hold the current size of the buffer
00000AE4: E1A00006    ;     mov R0, R6
00000AE8: EB0001BA    ;     bl malloc
00000AEC: E1A04000    ;     mov R4, R0 ;;R4 is the address of the buffer
00000AF0:             ; 
00000AF0: E3A05000    ;     mov R5, #0 ;;R5 is the loop counter/index into buffer
00000AF4:             ; getstringloop
00000AF4: E3790001    ;     cmp R9, #-1
00000AF8: 0A000001    ;     beq getstringloopskipsize
00000AFC: E1550009    ;     cmp R5, R9 ;;position - maxsize
00000B00:             ;                       ;;pos 2 means 3 characters written
00000B00: AA000019    ;     bge getstringlend ;;if position >= maxsize
00000B04:             ; getstringloopskipsize
00000B04: EF000001    ;     swi 1 ;;get input
00000B08: E1500008    ;     cmp R0, R8 ;;is input == terminator character
00000B0C: 0A000016    ;     beq getstringlend
00000B10:             ; 
00000B10: E3790001    ;     cmp R9, #-1
00000B14: 0AFFFFFF    ;     beq skipMax
00000B18:             ;     
00000B18:             ; skipMax
00000B18: E1550006    ;     cmp R5, R6
00000B1C: E92D0001    ;     push {R0}
00000B20: AA000005    ;     bge getstringresize
00000B24:             ; 
00000B24:             ; getstringlcont
00000B24: E8BD0001    ;     pop {R0}
00000B28: E7C40005    ;     strb R0, [R4, R5] ;;buff[pos] = input
00000B2C:             ; 
00000B2C: E35A0000    ;     cmp R10, #0
00000B30: 1F000000    ;     swine 0 ;;output the character to the screen if R10 is not 0
00000B34:             ; 
00000B34: E2855001    ;     add R5, R5, #1
00000B38:             ; 
00000B38: EAFFFFED    ;     b getstringloop
00000B3C:             ; 
00000B3C:             ; getstringresize
00000B3C:             ;     ;;r6 will hold new buffer
00000B3C: E1A00086    ;     mov R0, R6, lsl #1
00000B40: EB0001A4    ;     bl malloc
00000B44: E1A07000    ;     mov R7, R0
00000B48:             ; 
00000B48: E1A00004    ;     mov R0, R4 ;;old buff
00000B4C: E1A01007    ;     mov R1, R7 ;;newBuff
00000B50: E1A02005    ;     mov R2, R5 ;;bytes to write
00000B54: EBFFFFBA    ;     bl memcpy
00000B58:             ; 
00000B58: E1A00004    ;     mov R0, R4
00000B5C: EB0001C7    ;     bl free
00000B60: E1A04007    ;     mov R4, R7
00000B64:             ; 
00000B64: E1A06086    ;     mov R6, R6, lsl #1
00000B68:             ; 
00000B68: EAFFFFED    ;     b getstringlcont
00000B6C:             ; 
00000B6C:             ; getstringlend
00000B6C:             ;     ;;need to add a \0
00000B6C:             ;     ;;need to check if the buffer is completely full -> resize buffer to +1? (will be aligned t
                      ; o 8 in malloc!) then copy
00000B6C:             ;     ;;I could have the buffers always leave a space open for the \0? but this is kind of an edg
                      ; e case?
00000B6C: E1550006    ;     cmp R5, R6 ;;position to size of buffer
00000B70: 0A000000    ;     beq getstringResizeEnd
00000B74:             ; 
00000B74: EA00000A    ;     b getstringEnd
00000B78:             ; 
00000B78:             ; getstringResizeEnd
00000B78: E2860001    ;     add R0, R6, #1
00000B7C: EB000195    ;     bl malloc
00000B80: E1A07000    ;     mov R7, R0
00000B84:             ; 
00000B84: E1A00004    ;     mov R0, R4;;old buff
00000B88: E1A01007    ;     mov R1, R7;;new buff
00000B8C: E1A02005    ;     mov R2, R5;;bytes2write
00000B90: EBFFFFAB    ;     bl memcpy
00000B94:             ; 
00000B94: E1A00004    ;     mov R0, R4
00000B98: EB0001B8    ;     bl free
00000B9C: E1A04007    ;     mov R4, R7
00000BA0:             ; 
00000BA0: E2866001    ;     add R6, R6, #1 ;;not needed
00000BA4:             ; 
00000BA4:             ; getstringEnd
00000BA4: E3A00000    ;     mov R0, #0
00000BA8: E7C40005    ;     strb R0, [R4, R5]
00000BAC:             ; 
00000BAC: E1A00004    ;     mov R0, R4
00000BB0:             ; 
00000BB0: E8BD47F0    ;     pop {R14, R4-R10}
00000BB4: E1A0F00E    ;     mov R15, R14
00000BB8:             ; 
00000BB8:             ; tolower
00000BB8:             ; ;;INP in R0 is a character
00000BB8:             ; ;;OUT in R0 is the character.lower()
00000BB8: E3800020    ;     orr R0, R0, #32
00000BBC: E1A0F00E    ;     mov R15, R14
00000BC0:             ; 
00000BC0:             ; setupGrid
00000BC0:             ; ;;INP --
00000BC0:             ; ;;RET --
00000BC0:             ; ;;The values addresses of the grids will now be set, can still be 0
00000BC0:             ; ;; ask for generation mode
00000BC0:             ; ;;      |-If random ask for seed
00000BC0:             ; ;;      |   `-For generation roll the seed to create a pseudorandom value for each `pixel`
00000BC0:             ; ;;      `-If draw then get them to draw the grid one `pixel` at a time
00000BC0: E92D47F0    ;     push {R14, R4-R10}
00000BC4:             ; 
00000BC4:             ;     ;;generate the main grid
00000BC4: E55F623D    ;     ldrb R6, width
00000BC8: E55F7240    ;     ldrb R7, height
00000BCC:             ; 
00000BCC: E0000796    ;     mul R0, R6, R7 ;;width * height = num of bytes to malloc
00000BD0:             ; 
00000BD0: E1A05000    ;     mov R5, R0
00000BD4: EB00017F    ;     bl malloc
00000BD8: E1A04000    ;     mov R4, R0
00000BDC: E50F4260    ;     str R4, gridA
00000BE0:             ; 
00000BE0: E1A00005    ;     mov R0, R5
00000BE4: EB00017B    ;     bl malloc
00000BE8: E50F0268    ;     str R0, gridB
00000BEC:             ; 
00000BEC: E3550000    ;     cmp R5, #0
00000BF0: 0A00004E    ;     beq setupGridFail
00000BF4: E3540000    ;     cmp R4, #0
00000BF8: 0A00004C    ;     beq setupGridFail
00000BFC:             ; 
00000BFC:             ;     ;;R4 holds the gridA addr
00000BFC:             ;     ;;R6 holds the width
00000BFC:             ;     ;;R7 holds the height
00000BFC:             ; 
00000BFC: E28F0ECF    ;     adrl R0, askgenoption
00000C00: E2800000    ; 
00000C04: EF000003    ;     swi 3
00000C08:             ; setupGridAsk
00000C08: EF000001    ;     swi 1
00000C0C: E3800020    ;     orr R0, R0, #32
00000C10:             ; 
00000C10: E1A01000    ;     mov R1, R0
00000C14: EBFFFE8C    ;     bl newline
00000C18:             ; 
00000C18: E3510064    ;     cmp R1, #'d'
00000C1C: 0A000005    ;     beq setupdrawing
00000C20:             ; 
00000C20: E3510072    ;     cmp R1, #'r'
00000C24: 0A000008    ;     beq setuprandom
00000C28:             ; 
00000C28: E28F00FD    ;     adrl R0, setupGrdFailmsg
00000C2C: E2800B03    ; 
00000C30: EF000003    ;     swi 3
00000C34: EAFFFFF3    ;     b setupGridAsk
00000C38:             ; 
00000C38:             ; setupdrawing
00000C38: E3A09000    ;     mov R9, #0
00000C3C:             ; 
00000C3C: E28F0076    ;     adrl R0, drawinfomsg
00000C40: E2800C0D    ; 
00000C44: EF000003    ;     swi 3
00000C48:             ; 
00000C48: EA000009    ;     b setupstart
00000C4C:             ; 
00000C4C:             ; setuprandom
00000C4C: E28F003A    ;     adrl R0, askseed
00000C50: E2800C0D    ; 
00000C54: EF000003    ;     swi 3
00000C58:             ; 
00000C58: E3A00000    ;     mov R0, #0
00000C5C: E3A01004    ;     mov R1, #4
00000C60: E3A02001    ;     mov R2, #1
00000C64: EBFFFF97    ;     bl getstring
00000C68:             ; 
00000C68: E1A08000    ;     mov R8, R0
00000C6C:             ; 
00000C6C: EBFFFE76    ;     bl newline
00000C70:             ; 
00000C70: E3A09001    ;     mov R9, #1
00000C74:             ; 
00000C74:             ; setupstart
00000C74:             ; ;;This is probably not a good way to do it as there is more branching in the middle of a loop t
                      ; hat is executed alot
00000C74:             ; ;;I'm doing it this way `not because it is easy, but because I though it would be easy`
00000C74:             ; ;;Reduces the need for writing another loop :)
00000C74:             ; ;;R9 holds the mode (1 for random, 0 for draw)
00000C74:             ; ;;R8 will hold the seed for random
00000C74:             ; ;;for row from 0 to height - 1
00000C74:             ; ;;  for col from 0 to width - 1
00000C74:             ; ;;      if (random)
00000C74:             ; ;;          grid[row][col] = ((seed rol 1) || row) && 1
00000C74:             ; ;;      else
00000C74:             ; ;;          grid[row][col] = input() == 1
00000C74: E3A05000    ;     mov R5, #0 ;; row
00000C78:             ; setuprowloop
00000C78: E1550007    ;     cmp R5, R7
00000C7C: 0A000027    ;     beq setuprowlend
00000C80:             ; 
00000C80: E3A0A000    ;     mov R10, #0 ;;col
00000C84:             ; setupcolloop
00000C84: E15A0006    ;     cmp R10, R6
00000C88: 0A000022    ;     beq setupcollend
00000C8C:             ; 
00000C8C: E3590001    ;     cmp R9, #1
00000C90: 0A000000    ;     beq dorandom
00000C94: EA000004    ;     b dodrawstart
00000C98:             ; 
00000C98:             ; ;;dorandom and dodraw will get their value for this position and then place it in R2
00000C98:             ; ;;R3 is free at this point
00000C98:             ; dorandom
00000C98:             ;     ;;seed in R8
00000C98: E1A080E8    ;     mov R8, R8, ror #1
00000C9C: E00A3005    ;     and R3, R10, R5
00000CA0: E0288003    ;     eor R8, R8, R3
00000CA4: E2082001    ;     and R2, R8, #1
00000CA8: EA000016    ;     b setupcollcont
00000CAC:             ; 
00000CAC:             ; dodrawstart
00000CAC: E023A695    ;     mla R3, R5, R6, R10 ;;R3 = row * width + col
00000CB0:             ; 
00000CB0: E3A00002    ;     mov R0, #2
00000CB4: E7C40003    ;     strb R0, [R4, R3]
00000CB8:             ; 
00000CB8: E3590000    ;     cmp R9, #0
00000CBC: 01A00004    ;     moveq R0, R4
00000CC0: 0B00001C    ;     bleq drawgrid ;;print the new state of the grid if this is drawing mode
00000CC4:             ; 
00000CC4:             ; dodraw
00000CC4:             ;     ;;get input, validate 1 or 0
00000CC4:             ;     ;;if invalid print error loop back
00000CC4:             ;     ;;-_- I've just realised I want to print the grid each time as well R0-R3 are scratch
00000CC4: EF000001    ;     swi 1
00000CC8:             ; 
00000CC8: E3500031    ;     cmp R0, #'1'
00000CCC: 0A000005    ;     beq dodrawsucc
00000CD0: E3500030    ;     cmp R0, #'0'
00000CD4: 0A000003    ;     beq dodrawsucc
00000CD8:             ; 
00000CD8: E28F0012    ;     adrl R0, drawfailmsg
00000CDC: E2800C0D    ; 
00000CE0: EF000003    ;     swi 3
00000CE4:             ; 
00000CE4: EAFFFFF6    ;     b dodraw
00000CE8:             ; 
00000CE8:             ; dodrawsucc
00000CE8: E92D0001    ;     push {R0}
00000CEC: E0000796    ;     mul R0, R6, R7      ;;I don't like having to do this every time :(
00000CF0: E1A00080    ;     mov R0, R0, lsl #1
00000CF4: E2800001    ;     add R0, R0, #1
00000CF8: E0800007    ;     add R0, R0, R7
00000CFC: EBFFFEE5    ;     bl erase
00000D00: E8BD0001    ;     pop {R0}
00000D04:             ; 
00000D04: E2402030    ;     sub R2, R0, #48 ;;could be xor?
00000D08:             ; 
00000D08:             ; setupcollcont
00000D08:             ;     ;;place the value in R2 into the grid[row][col]
00000D08:             ;     ;;row * width + col
00000D08: E023A695    ;     mla R3, R5, R6, R10 ;;R3 = row * width + col ;;I'm doing this twice \-(*v*)-/
00000D0C: E7C42003    ;     strb R2, [R4, R3] ;;grid offset by R3
00000D10:             ; 
00000D10: E28AA001    ;     add R10, R10, #1
00000D14: EAFFFFDA    ;     b setupcolloop
00000D18:             ; setupcollend
00000D18: E2855001    ;     add R5, R5, #1
00000D1C: EAFFFFD5    ;     b setuprowloop
00000D20:             ; setuprowlend
00000D20:             ;     ;;grid has been setup
00000D20: E3590001    ;     cmp R9, #1
00000D24: 1A000001    ;     bne setupGridEnd
00000D28: E1A00008    ;     mov R0, R8 ;;free the seed
00000D2C: EB000153    ;     bl free
00000D30:             ; 
00000D30:             ; setupGridFail
00000D30:             ; setupGridEnd
00000D30: E8BD47F0    ;     pop {R14, R4-R10}
00000D34: E1A0F00E    ;     mov R15, R14
00000D38:             ; 
00000D38:             ; 
00000D38:             ; ;;[[TODO]] the heap may not be blank (when heapclean is removed) and so need to 0 the mem. Mayb
                      ; e add option to malloc or add calloc (not the same)
00000D38:             ; drawgrid
00000D38:             ; ;;INP in R0 is the grid address to draw
00000D38:             ; 
00000D38:             ; ;;for row from 0 to height - 1
00000D38:             ; ;;  for col from 0 to width - 1
00000D38:             ; ;;      print('X' if grid[row][col] else '_')
00000D38:             ; ;;  print(newline)
00000D38:             ; ;;print(newline)
00000D38: E92D01F0    ;     push {R4-R8}
00000D3C:             ; 
00000D3C: E1A06000    ;     mov R6, R0
00000D40:             ; 
00000D40: E55F43B9    ;     ldrb R4, width
00000D44: E55F53BC    ;     ldrb R5, height
00000D48:             ; 
00000D48: E3A02000    ;     mov R2, #0 ;;row
00000D4C:             ; drawgridrowloop
00000D4C: E1520005    ;     cmp R2, R5
00000D50: 0A000016    ;     beq drawgridrowlend
00000D54:             ; 
00000D54: E3A01000    ;     mov R1, #0 ;;col
00000D58:             ; drawgridcolloop
00000D58: E1510004    ;     cmp R1, R4
00000D5C: 0A00000E    ;     beq drawgridcollend
00000D60:             ; 
00000D60: E0231492    ;     mla R3, R2, R4, R1 ;;R3 = row * width + col
00000D64: E7D63003    ;     ldrb R3, [R6, R3]
00000D68:             ; 
00000D68: E3530002    ;     cmp R3, #2
00000D6C: 0A000004    ;     beq drawgridprintcurrent
00000D70: E3530001    ;     cmp R3, #1
00000D74: 051F03E0    ;     ldreq R0, alive_c
00000D78: 151F03E3    ;     ldrne R0, dead_c
00000D7C:             ; 
00000D7C: EF000000    ;     swi 0
00000D80:             ; 
00000D80: EA000001    ;     b drawgridcollcont
00000D84:             ; 
00000D84:             ; drawgridprintcurrent
00000D84: E51F03EE    ;     ldr R0, ptr_c
00000D88: EF000000    ;     swi 0
00000D8C:             ; 
00000D8C:             ; drawgridcollcont
00000D8C: E3A00020    ;     mov R0, #' '
00000D90: EF000000    ;     swi 0
00000D94:             ; 
00000D94: E2811001    ;     add R1, R1, #1
00000D98: EAFFFFEE    ;     b drawgridcolloop
00000D9C:             ; 
00000D9C:             ; drawgridcollend
00000D9C: E3A01000    ;     mov R1, #0
00000DA0: E2822001    ;     add R2, R2, #1
00000DA4: E3A0000A    ;     mov R0, #10
00000DA8: EF000000    ;     swi 0
00000DAC: EAFFFFE6    ;     b drawgridrowloop
00000DB0:             ; 
00000DB0:             ; drawgridrowlend
00000DB0: E3A0000A    ;     mov R0, #10
00000DB4: EF000000    ;     swi 0
00000DB8:             ; drawgridend
00000DB8: E8BD01F0    ;     pop {R4-R8}
00000DBC: E1A0F00E    ;     mov R15, R14
00000DC0:             ; 
00000DC0:             ; 
00000DC0:             ; printoptions
00000DC0:             ; ;;INP --
00000DC0:             ; ;;OUT --
00000DC0:             ; ;;optionsp_1-5
00000DC0: E28F0075    ;     adrl R0, optionsp_1
00000DC4: E2800C0A    ; 
00000DC8: EF000003    ;     swi 3
00000DCC:             ; 
00000DCC: E55F0445    ;     ldrb R0, width
00000DD0: EF000004    ;     swi 4
00000DD4:             ; 
00000DD4: E28F0079    ;     adrl R0, optionsp_2
00000DD8: E2800C0A    ; 
00000DDC: EF000003    ;     swi 3
00000DE0:             ; 
00000DE0: E55F0458    ;     ldrb R0, height
00000DE4: EF000004    ;     swi 4
00000DE8:             ; 
00000DE8: E28F0F9A    ;     adrl R0, optionsp_3
00000DEC: E2800B02    ; 
00000DF0: EF000003    ;     swi 3
00000DF4:             ; 
00000DF4: E55F046F    ;     ldrb R0, slow_b
00000DF8: E3500001    ;     cmp R0, #1
00000DFC: 128F008B    ;     adrlne R0, off_msg
00000E00: 12800C11    ; 
00000E04: 028F0D46    ;     adrleq R0, on_msg
00000E08: 02800000    ; 
00000E0C: EF000003    ;     swi 3
00000E10:             ; 
00000E10: E28F0F93    ;     adrl R0, optionsp_4
00000E14: E2800B02    ; 
00000E18: EF000003    ;     swi 3
00000E1C:             ; 
00000E1C: E55F0498    ;     ldrb R0, erase_b
00000E20: E3500001    ;     cmp R0, #1
00000E24: 128F0063    ;     adrlne R0, off_msg
00000E28: 12800C11    ; 
00000E2C: 028F0F56    ;     adrleq R0, on_msg
00000E30: 02800A01    ; 
00000E34: EF000003    ;     swi 3
00000E38:             ; 
00000E38: E28F0EA3    ;     adrl R0, optionsp_5
00000E3C: E2800000    ; 
00000E40: EF000003    ;     swi 3
00000E44:             ; 
00000E44: E55F04BE    ;     ldrb R0, step_b
00000E48: E3500001    ;     cmp R0, #1
00000E4C: 128F003B    ;     adrlne R0, off_msg
00000E50: 12800C11    ; 
00000E54: 028F0E13    ;     adrleq R0, on_msg
00000E58: 02800A01    ; 
00000E5C: EF000003    ;     swi 3
00000E60:             ; 
00000E60: E3A0000A    ;     ldr R0, =nl
00000E64: EF000000    ;     swi 0
00000E68:             ; 
00000E68: E1A0F00E    ;     mov R15, R14
00000E6C:             ; 
00000E6C:             ; setupOptions
00000E6C:             ; ;;INP in R0 is 1 if should ask for dims 0 for skip
00000E6C: E92D4010    ;     push {R14, R4}
00000E70: E1A04000    ;     mov R4, R0
00000E74:             ; 
00000E74: E28F002D    ;     adrl R0, askdefaults ;;ask q
00000E78: E2800C07    ; 
00000E7C: EF000003    ;     swi 3
00000E80: EF000001    ;     swi 1   ;;get character answer
00000E84: EF000000    ;     swi 0
00000E88: E3500059    ;     cmp R0, #'Y'
00000E8C: E3A0000A    ;     ldr R0, =nl
00000E90: EF000000    ;     swi 0
00000E94:             ; 
00000E94: 1A00000E    ;     bne setupCustom
00000E98:             ; 
00000E98: E55F050C    ;     ldrb R0, erase_b_d
00000E9C: E54F0518    ;     strb R0, erase_b
00000EA0: E55F0513    ;     ldrb R0, slow_b_d
00000EA4: E54F051F    ;     strb R0, slow_b
00000EA8: E55F051A    ;     ldrb R0, step_b_d
00000EAC: E54F0526    ;     strb R0, step_b
00000EB0:             ; 
00000EB0: E3540000    ;     cmp R4, #0
00000EB4: 0A000003    ;     beq setupOptionsDEnd
00000EB8:             ; 
00000EB8: E55F0529    ;     ldrb R0, width_d
00000EBC: E54F0535    ;     strb R0, width
00000EC0: E55F0530    ;     ldrb R0, height_d
00000EC4: E54F053C    ;     strb R0, height
00000EC8:             ; 
00000EC8:             ; setupOptionsDEnd
00000EC8: EBFFFFBC    ;     bl printoptions
00000ECC:             ; 
00000ECC: E8BD4010    ;     pop {R14, R4}
00000ED0: E1A0F00E    ;     mov R15, R14 ;;RET
00000ED4:             ; 
00000ED4:             ; setupCustom
00000ED4:             ; ;;ask for erase, slow, step, and conditionally dims
00000ED4:             ; 
00000ED4:             ; ;;ask step
00000ED4:             ; ;;ask erase
00000ED4:             ; ;;if (!step)
00000ED4:             ; ;;  if erase
00000ED4:             ; ;;      print(recommend slow)
00000ED4:             ; ;;  ask slow
00000ED4:             ; 
00000ED4: E3A01001    ;     mov R1, #1
00000ED8:             ; 
00000ED8: E28F0FCB    ;     adrl R0, askstep
00000EDC: E2800B01    ; 
00000EE0: EF000003    ;     swi 3
00000EE4: EF000001    ;     swi 1
00000EE8: EF000000    ;     swi 0 
00000EEC: E3500059    ;     cmp R0, #'Y' 
00000EF0: E3A0000A    ;     ldr R0, =nl
00000EF4: EF000000    ;     swi 0
00000EF8: 13A01000    ;     movne R1, #0
00000EFC: E54F1576    ;     strb R1, step_b
00000F00:             ; 
00000F00: E3A01001    ;     mov R1, #1
00000F04:             ; 
00000F04: E28F00CF    ;     adrl R0, askerase
00000F08: E2800C06    ; 
00000F0C: EF000003    ;     swi 3
00000F10: EF000001    ;     swi 1
00000F14: EF000000    ;     swi 0
00000F18: E3500059    ;     cmp R0, #'Y'
00000F1C: E3A0000A    ;     ldr R0, =nl
00000F20: EF000000    ;     swi 0
00000F24: 13A01000    ;     movne R1, #0
00000F28: E54F15A4    ;     strb R1, erase_b
00000F2C:             ; 
00000F2C: E55F05A6    ;     ldrb R0, step_b
00000F30: E3500001    ;     cmp R0, #1
00000F34: 0A00000F    ;     beq setupCustomskipslow
00000F38:             ; 
00000F38: E3510001    ;     cmp R1, #1 ;;if erase is on
00000F3C: E28F007B    ;     adrl R0, warneraseslow
00000F40: E2800C07    ; 
00000F44: 0F000003    ;     swieq 3
00000F48:             ; 
00000F48: E3A01001    ;     mov R1, #1
00000F4C:             ;  
00000F4C: E28F0E6A    ;     adrl R0, askslow
00000F50: E2800000    ; 
00000F54: EF000003    ;     swi 3
00000F58: EF000001    ;     swi 1
00000F5C: EF000000    ;     swi 0 
00000F60: E3500059    ;     cmp R0, #'Y' 
00000F64: E3A0000A    ;     ldr R0, =nl
00000F68: EF000000    ;     swi 0
00000F6C: 13A01000    ;     movne R1, #0
00000F70: E54F15EB    ;     strb R1, slow_b
00000F74:             ; 
00000F74: EA000001    ;     b setupCustomDimsCheck
00000F78:             ; 
00000F78:             ; setupCustomskipslow
00000F78: E3A00000    ;     mov R0, #0
00000F7C: E54F05F7    ;     strb R0, slow_b
00000F80:             ; 
00000F80:             ; setupCustomDimsCheck
00000F80: E3540000    ;     cmp R4, #0
00000F84: 0A000033    ;     beq customend
00000F88:             ; 
00000F88: E28F006D    ;     adrl R0, askwid
00000F8C: E2800C07    ; 
00000F90: EF000003    ;     swi 3
00000F94:             ;     
00000F94:             ; getwid
00000F94: E3A0000A    ;     ldr R0, =enter
00000F98: E3A01002    ;     mov R1, #2
00000F9C: E3A02001    ;     mov R2, #1
00000FA0: EBFFFEC8    ;     bl getstring
00000FA4: E1A04000    ;     mov R4, R0
00000FA8:             ; 
00000FA8: EBFFFE7C    ;     bl strtoi
00000FAC: E1A05000    ;     mov R5, R0
00000FB0:             ;     
00000FB0: E1A00004    ;     mov R0, R4
00000FB4: EB0000B1    ;     bl free ;;free the collected string
00000FB8:             ; 
00000FB8: E1A01005    ;     mov R1, R5
00000FBC:             ; 
00000FBC: EBFFFDA2    ;     bl newline
00000FC0:             ; 
00000FC0: E55F4637    ;     ldrb R4, range_min
00000FC4: E55F563A    ;     ldrb R5, range_max
00000FC8:             ; 
00000FC8: E1510005    ;     cmp R1, R5
00000FCC: CA000003    ;     bgt getwidFail
00000FD0: E1510004    ;     cmp R1, R4
00000FD4: BA000001    ;     blt getwidFail
00000FD8:             ; 
00000FD8: E54F1651    ;     strb R1, width
00000FDC:             ; 
00000FDC: EA000003    ;     b getheisetup
00000FE0:             ; 
00000FE0:             ; getwidFail
00000FE0: E28F0052    ;     adrl R0, getwidfailmsg
00000FE4: E2800C07    ; 
00000FE8: EF000003    ;     swi 3
00000FEC:             ; 
00000FEC: EAFFFFE8    ;     b getwid
00000FF0:             ; 
00000FF0:             ; getheisetup
00000FF0: E28F0023    ;     adrl R0, askhei
00000FF4: E2800C07    ; 
00000FF8: EF000003    ;     swi 3
00000FFC:             ; 
00000FFC:             ; gethei
00000FFC: E3A0000A    ;     ldr R0, =enter
00001000: E3A01002    ;     mov R1, #2
00001004: E3A02001    ;     mov R2, #1
00001008: EBFFFEAE    ;     bl getstring
0000100C: E1A04000    ;     mov R4, R0
00001010:             ; 
00001010: EBFFFE62    ;     bl strtoi
00001014: E1A05000    ;     mov R5, R0
00001018:             ; 
00001018: E1A00004    ;     mov R0, R4
0000101C: EB000097    ;     bl free
00001020:             ; 
00001020: E1A01005    ;     mov R1, R5
00001024:             ; 
00001024: EBFFFD88    ;     bl newline
00001028:             ; 
00001028: E55F469F    ;     ldrb R4, range_min
0000102C: E55F56A2    ;     ldrb R5, range_max
00001030:             ; 
00001030: E1510005    ;     cmp R1, R5
00001034: CA000003    ;     bgt getheiFail
00001038: E1510004    ;     cmp R1, R4
0000103C: BA000001    ;     blt getheiFail
00001040:             ; 
00001040: E54F16B8    ;     strb R1, height
00001044:             ; 
00001044: EA000003    ;     b customend
00001048:             ; 
00001048:             ; getheiFail
00001048: E28F0026    ;     adrl R0, getheifailmsg
0000104C: E2800C07    ; 
00001050: EF000003    ;     swi 3
00001054:             ; 
00001054: EAFFFFE8    ;     b gethei
00001058:             ; 
00001058:             ; customend
00001058: EBFFFF58    ;     bl printoptions
0000105C:             ; 
0000105C: E8BD4010    ;     pop {R14, R4}
00001060: E1A0F00E    ;     mov R15, R14 ;;RET
00001064:             ; 
00001064:             ; 
00001064:             ; updategrid
00001064:             ; ;;INP in R0 is the active grid
00001064:             ; ;;INP in R1 is the passive grid
00001064:             ; ;;passive grid is the one being updated based on the value in the activeGrid
00001064:             ; ;;RET --
00001064:             ; ;;for row from 0 to height - 1
00001064:             ; ;;  for col from 0 to width - 1
00001064:             ; ;;      int n = countNeighbours(activeGrid, row, col)
00001064:             ; ;;      int s = activeGrid[row][col]
00001064:             ; ;;      
00001064:             ; ;;      if (s == alive)
00001064:             ; ;;          passiveGrid[row][col] = n == 3 or n == 2
00001064:             ; ;;      else
00001064:             ; ;;          passiveGrid[row][col] = n == 3
00001064:             ; 
00001064:             ; ;;  R4 holds the row
00001064:             ; ;;  R5 holds the col
00001064:             ; ;;  R6 holds the width
00001064:             ; ;;  R7 holds the height
00001064:             ; ;;  R8 holds the active grid
00001064:             ; ;;  R9 holds the passive grid
00001064:             ; 
00001064: E92D47F0    ;     push {R14, R4-R10}
00001068:             ; 
00001068: E55F66E1    ;     ldrb R6, width
0000106C: E55F76E4    ;     ldrb R7, height
00001070:             ; 
00001070: E1A08000    ;     mov R8, R0
00001074: E1A09001    ;     mov R9, R1
00001078:             ; 
00001078: E3A04000    ;     mov R4, #0 ;;row
0000107C:             ; updategridrowloop
0000107C: E1540007    ;     cmp R4, R7
00001080: 0A00001A    ;     beq updategridrowlend
00001084:             ; 
00001084: E3A05000    ;     mov R5, #0 ;;col
00001088:             ; updategridcolloop
00001088: E1550006    ;     cmp R5, R6
0000108C: 0A000014    ;     beq updategridccollend
00001090:             ; 
00001090: E1A00008    ;     mov R0, R8
00001094: E1A01004    ;     mov R1, R4
00001098: E1A02005    ;     mov R2, R5
0000109C: EB000015    ;     bl countneighbours
000010A0:             ; 
000010A0: E0215694    ;     mla R1, R4, R6, R5 ;;R1 = row * width + col
000010A4: E7D82001    ;     ldrb R2, [R8, R1] ;;grid[R1]
000010A8:             ;     ;;R0 holds the n count
000010A8: E3520000    ;     cmp R2, #0
000010AC: 0A000006    ;     beq updatedead
000010B0:             ; 
000010B0:             ; updatealive
000010B0: E3A03000    ;     mov R3, #0
000010B4: E3500003    ;     cmp R0, #3
000010B8: 03A03001    ;     moveq R3, #1
000010BC: E3500002    ;     cmp R0, #2
000010C0: 03A03001    ;     moveq R3, #1
000010C4: E7C93001    ;     strb R3, [R9, R1]
000010C8: EA000003    ;     b updatelcont
000010CC:             ; 
000010CC:             ; updatedead
000010CC: E3A03001    ;     mov R3, #1
000010D0: E3500003    ;     cmp R0, #3
000010D4: 13A03000    ;     movne R3, #0
000010D8: E7C93001    ;     strb R3, [R9, R1]
000010DC:             ; 
000010DC:             ; updatelcont
000010DC: E2855001    ;     add R5, R5, #1
000010E0: EAFFFFE8    ;     b updategridcolloop
000010E4:             ; 
000010E4:             ; updategridccollend
000010E4: E3A05000    ;     mov R5, #0
000010E8: E2844001    ;     add R4, R4, #1
000010EC: EAFFFFE2    ;     b updategridrowloop
000010F0:             ; 
000010F0:             ; updategridrowlend
000010F0:             ; updategridend
000010F0: E8BD47F0    ;     pop {R14, R4-R10}
000010F4: E1A0F00E    ;     mov R15, R14
000010F8:             ; 
000010F8:             ; 
000010F8:             ; countneighbours
000010F8:             ; ;;INP in R0 is the activeGrid
000010F8:             ; ;;INP in R1 is the row
000010F8:             ; ;;INP in R2 is the col
000010F8:             ; ;;OUT in R0 is the number of neighbours
000010F8:             ; 
000010F8:             ; ;;offsets = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
000010F8:             ; ;;tot = 0
000010F8:             ; ;;for offset in offsets
000010F8:             ; ;;  if (isinrange(row + offset[0], col + offset[1]))
000010F8:             ; ;;      tot += grid[row + offset[0]][col + offset[1]]
000010F8:             ; ;;return tot
000010F8: E92D4FF0    ;     push {R14, R4-R11} ;;I used the fp before I knew it wasn't a general purpose one, its fine 
                      ; in this context anyway
000010FC:             ; 
000010FC: E24F4D1F    ;     adrl R4, offsets ;;holds the offset
00001100: E2444000    ; 
00001104:             ; 
00001104: E1A07000    ;     mov R7, R0
00001108: E1A08001    ;     mov R8, R1
0000110C: E1A09002    ;     mov R9, R2
00001110: E3A0A000    ;     mov R10, #0 ;;R10 holds the total
00001114: E55FB78D    ;     ldrb R11, width;;R11 holds the width of the grid
00001118:             ; 
00001118: E3A03000    ;     mov R3, #0
0000111C:             ; 
0000111C:             ; countneighboursloop
0000111C: E3530008    ;     cmp R3, #8 ;;change this ccheck to be for R4
00001120: 0A00000F    ;     beq countneighbourslend
00001124:             ; 
00001124: E4945004    ;     ldr R5, [R4], #4
00001128: E4946004    ;     ldr R6, [R4], #4
0000112C:             ; 
0000112C: E0880005    ;     add R0, R8, R5
00001130: E0891006    ;     add R1, R9, R6
00001134:             ; 
00001134: E2833001    ;     add R3, R3, #1
00001138:             ; 
00001138: E92D0008    ;     push {R3} ;;I should probably be using a local var on the stack, but I don't yet know how t
                      ; o setup a stack frame properly
0000113C: EB00000B    ;     bl isinrange
00001140: E8BD0008    ;     pop {R3}
00001144:             ; 
00001144: E3500000    ;     cmp R0, #0
00001148: 0A000004    ;     beq countneighboursskipadd
0000114C:             ; 
0000114C: E0880005    ;     add R0, R8, R5 ;;new row
00001150: E0891006    ;     add R1, R9, R6 ;;new col ;;can assume that R0, R1 haven't changed as isinrange doesn't edit
                      ;  them, but I'm going to for now
00001154:             ; 
00001154: E0201B90    ;     mla R0, R0, R11, R1 ;;find offset
00001158: E7D70000    ;     ldrb R0, [R7, R0]
0000115C: E08AA000    ;     add R10, R10, R0 ;;tot += grid[newrow][newcol]
00001160:             ; 
00001160:             ; countneighboursskipadd
00001160: EAFFFFED    ;     b countneighboursloop
00001164:             ; 
00001164:             ; countneighbourslend
00001164:             ; countneighboursend
00001164: E1A0000A    ;     mov R0, R10
00001168: E8BD4FF0    ;     pop {R14, R4-R11}
0000116C: E1A0F00E    ;     mov R15, R14
00001170:             ; 
00001170:             ; 
00001170:             ; isinrange
00001170:             ; ;;INP in R0 is the row
00001170:             ; ;;INP in R1 is the col
00001170:             ; ;;Uses defined width and height
00001170:             ; ;;RET in R0 is 1 if is in range else 0
00001170: E3A02001    ;     mov R2, #1 ;;is valid unless...
00001174:             ; 
00001174: E3500000    ;     cmp R0, #0
00001178: BA000009    ;     blt isinrangefail
0000117C:             ; 
0000117C: E3510000    ;     cmp R1, #0
00001180: BA000007    ;     blt isinrangefail
00001184:             ; 
00001184: E55F37FD    ;     ldrb R3, width
00001188: E1510003    ;     cmp R1, R3
0000118C: AA000004    ;     bge isinrangefail
00001190:             ; 
00001190: E55F3808    ;     ldrb R3, height
00001194: E1500003    ;     cmp R0, R3
00001198: AA000001    ;     bge isinrangefail
0000119C:             ; 
0000119C: E3A00001    ;     mov R0, #1
000011A0: EA000000    ;     b isinrangeend
000011A4:             ; 
000011A4:             ; isinrangefail
000011A4: E3A00000    ;     mov R0, #0
000011A8:             ; 
000011A8:             ; isinrangeend
000011A8: E1A0F00E    ;     mov R15, R14
000011AC:             ; 
000011AC:             ; 
000011AC:             ; ;; The heap will be a linked list of free blocks - unlike the Comodo version which stores both 
                      ; free & taken blocks 
000011AC:             ; ;; This is an idea I'm stealing from the C programming book
000011AC:             ; ;; Crate structure
000011AC:             ; ;;  |-ptr to next crate (1 word)
000011AC:             ; ;;  |-ptr to prev crate (1 word)
000011AC:             ; ;;  `-Size (bytes)      (1 word)
000011AC:             ; ;; 
000011AC:             ; 
000011AC:             ; ;;  Traversal of the heap
000011AC:             ; ;;  Unlink in my Comodo implimentation the heap is not a linked list of all Crates (free or not
                      ; )
000011AC:             ; ;;  That made traversing the heap for debugging purposes very easy, in this case taken crates d
                      ; o not point to the next
000011AC:             ; ;;  Instead could start at head and then just go to addr + sizeof(Crate) + size. This should ta
                      ; ke us to the next crate, free or not
000011AC:             ; ;;  
000011AC:             ; setupHeap
000011AC:             ; ;;NO INP
000011AC:             ; ;;NO OUT
000011AC:             ;     ;;we have the heapstart
000011AC:             ;     ;;the end of the heap will be 0x100000 (it will overlap with the stack :) )
000011AC: E51F0874    ;     ldr R0, heaphead ;;stores the mem addr of the start of the heap
000011B0: E3A01601    ;     ldr R1, =max_addr ;;stores the end of the heap
000011B4: E3A02801    ;     ldr R2, =stack_size
000011B8: E0411002    ;     sub R1, R1, R2
000011BC:             ; 
000011BC: E0411000    ;     sub R1, R1, R0  ;;HEAPEND - HEAPSTART = TOTAL STORAGE (bytes)
000011C0: E241100C    ;     sub R1, R1, #12 ;;SIZE -= SIZEOF(CRATE) (12 bytes)
000011C4: E5801008    ;     str R1, [R0, #8] ;;set the size of the crate
000011C8: E3A01000    ;     mov R1, #0
000011CC: E5801004    ;     str R1, [R0, #4] ;;set the prev ptr
000011D0: E5801000    ;     str R1, [R0, #0] ;;set the next ptr
000011D4:             ; 
000011D4: E1A0F00E    ;     mov R15, R14
000011D8:             ; 
000011D8:             ; ;; The heap is a linked list of free Crates and so find the header and then go though until one
                      ;  satifies the size requirement
000011D8:             ; ;;  end if next is 0
000011D8:             ; ;;  once found either take over the crate or split it into two new crates
000011D8:             ; ;;  align the bytes amount to 8 byte boundry
000011D8:             ; malloc
000011D8:             ; ;;INP into R0 bytes to allocate
000011D8:             ; ;;OUT into R0 the ptr to the memory or 0 for no memory allocated
000011D8:             ;     ;;step 1 align the bytes
000011D8:             ;     ;;1001010 & 0111 = 0000010 ;2
000011D8:             ;     ;;if 0 goto alignend
000011D8:             ;     ;;1001010 + (8 - 2)
000011D8: E92D0010    ;     push {R4}
000011DC:             ; 
000011DC: E2001007    ;     and R1, R0, #0b0111
000011E0: E3510000    ;     cmp R1, #0
000011E4: 0A000002    ;     beq mallignend
000011E8: E3A03008    ;     mov R3, #0b1000
000011EC: E0432001    ;     sub R2, R3, R1
000011F0: E0800002    ;     add R0, R0, R2
000011F4:             ; 
000011F4:             ; mallignend
000011F4: E51F18BC    ;     ldr R1, heaphead ;;stores a ptr to the first block
000011F8:             ;     
000011F8:             ; checkcrate
000011F8: E5912008    ;     ldr R2, [R1, #8] ;;Size of the crate
000011FC: E1500002    ;     cmp R0, R2 ;;bytes needed - bytes in crate
00001200: DA000006    ;     ble foundcrate
00001204: E5912000    ;     ldr R2, [R1, #0] ;;get the next ptr
00001208: E3520000    ;     cmp R2, #0
0000120C: 0A000001    ;     beq nocrates
00001210: E1A01002    ;     mov R1, R2 ;;swap the current crate with the next crate
00001214: EAFFFFF7    ;     b checkcrate
00001218:             ; nocrates
00001218: E3A00000    ;     mov R0, #0
0000121C: EA000015    ;     b mallocEnd
00001220:             ; 
00001220:             ; foundcrate
00001220:             ;     ;;Once a crate that we can use has been found we need to either split the crate or use the 
                      ; crate
00001220:             ;     ;;We should use the whole crate only when its size < bytesneeded + CrateHeader + 8
00001220:             ;     ;;This would give the edge case crate 8 bytes
00001220:             ;     
00001220:             ;     ;;R1 holds the found crate ptr
00001220:             ;     ;;R0 is the bytes requested and aligned
00001220: E2802014    ;     add R2, R0, #20 ;;A crate header is 12 bytes + the extra 8 bytes minimum
00001224: E5913008    ;     ldr R3, [R1, #8]
00001228: E1530002    ;     cmp R3, R2
0000122C: BA00000C    ;     blt usecrate
00001230:             ; splitcrate
00001230:             ;     ;;In this case we have a large crate that should be split up.
00001230:             ;     ;;ATM the crate will just be split up to where the requested memory is at the end of the fr
                      ; ee Crate.
00001230:             ; 
00001230: E5913008    ;     ldr R3, [R1, #8] ;;The size of the toSplit Crate
00001234: E0433000    ;     sub R3, R3, R0 ;; size - bytesRequested
00001238: E243300C    ;     sub R3, R3, #12 ;; size - bytesRequested - sizeof(Crate)
0000123C: E5813008    ;     str R3, [R1, #8] ;;toSplit->size = newSize
00001240:             ; 
00001240: E0833001    ;     add R3, R3, R1 ;; newSize + toSplit.addr
00001244: E283400C    ;     add R4, R3, #12 ;; newSize + toSplit.addr + sizeof(Crate) = position of new Crate
00001248:             ; 
00001248:             ;     ;;Setup the header for the newCrate
00001248: E3A02000    ;     mov R2, #0
0000124C: E5842000    ;     str R2, [R4, #0] ;;next = 0
00001250: E5842004    ;     str R2, [R4, #4] ;;prev = 0
00001254: E5840008    ;     str R0, [R4, #8] ;;size = requested and aligned
00001258:             ; 
00001258:             ;     ;;MAYBE: can the crates that are taken have a smaller header than those that are free. Take
                      ; n crates need not store the next, prev free nodes
00001258:             ;     ;;This may complicate things as size would need to be moved around and the size from taken 
                      ; to free would be different. 
00001258:             ; 
00001258: E284400C    ;     add R4, R4, #12
0000125C:             ; 
0000125C: E1A00004    ;     mov R0, R4
00001260:             ; 
00001260: EA000004    ;     b mallocEnd
00001264:             ; 
00001264:             ; usecrate
00001264:             ;     ;; Simplest option as we can just remove it from the list
00001264:             ;     ;; c1 <-> c2 <-> c3 ==> c1 <-> c3
00001264: E5912000    ;     ldr R2, [R1, #0] ;;next ptr
00001268: E5913004    ;     ldr R3, [R1, #4] ;;prev ptr
0000126C: E5823004    ;     str R3, [R2, #4] ;;Store c1 into c3's previous
00001270: E5832000    ;     str R2, [R3, #0] ;;Store c3 into c1's next
00001274:             ; 
00001274: E1A00001    ;     mov R0, R1 ;;move the found crate's address into the return register ;;The crate header is 
                      ; no longer needed
00001278:             ; 
00001278:             ; mallocEnd
00001278: E8BD0010    ;     pop {R4}
0000127C: E1A0F00E    ;     mov R15, R14
00001280:             ; 
00001280:             ; free
00001280:             ; ;;INP in R0 is the mem addr of the data to be freed
00001280:             ; ;;OUT in R0 is the success code - 0 for mem freed, ¬0 for error ;;probably won't be currently 
                      ; used `=(- -)=' 
00001280:             ;     ;;In order to free memory we need to add it back to the linked list
00001280:             ;     ;;Following K&R's version the linked list will be ordered by address this will make finding
                      ;  consecutive memory locations that should be combined easier
00001280:             ; 
00001280:             ;     ;;The inputted address of the crate is the address given in malloc and so the start of the 
                      ; crate is that addr - sizeof(Crate) (#12)
00001280:             ; 
00001280:             ;     ;;heapHead = first Crate
00001280:             ;     ;;current = heapHead
00001280:             ;     ;;while (toFree.addr > current.addr)
00001280:             ;     ;;  current = current.next
00001280:             ;     ;;
00001280:             ;     ;;//Add the toFree Crate inbetween the current and its previous i.e.  A<->B<->C, toFree = D
                      ;  (addr < C, addr > B) ==> A<->B<->D<->C
00001280:             ;     ;;current->prev->next = toFree
00001280:             ;     ;;toFree->prev = current.prev
00001280:             ;     ;;current->prev = toFree
00001280:             ;     ;;toFree->next = current
00001280:             ; 
00001280:             ;     ;; Crate structure
00001280:             ;     ;;  |-ptr to next crate (1 word)
00001280:             ;     ;;  |-ptr to prev crate (1 word)
00001280:             ;     ;;  `-Size (bytes)      (1 word)
00001280:             ; 
00001280: E92D01F0    ;     push {R4-R8}
00001284:             ; 
00001284: E51F194C    ;     ldr R1, heaphead ;;R1 will hold the current
00001288: E240000C    ;     sub R0, R0, #12 ;;subtract sizeof(Crate) to get header pointer
0000128C:             ; freeloop
0000128C: E5912000    ;     ldr R2, [R1, #0] ;;load the ptr to the next
00001290: E1520000    ;     cmp R2, R0 ;;compare the address of the toFree to the address of current->next
00001294:             ; 
00001294: AA000003    ;     bge freelend ;;current->next.addr >= toFree.addr
00001298:             ; 
00001298: E3520000    ;     cmp R2, #0 ;;If there are no more Crates to the right then this could be a new Crate at the
                      ;  end or |F|T| it should merge left 
0000129C: 0A000009    ;     beq freelendEnd
000012A0:             ; 
000012A0: E1A01002    ;     mov R1, R2 ;;current = current.next
000012A4:             ; 
000012A4: EAFFFFF8    ;     b freeloop
000012A8:             ; 
000012A8:             ; freelend
000012A8:             ;     ;; R1 holds the current (left)
000012A8:             ;     ;; R2 holds the c->next (right)
000012A8: E5912000    ;     ldr R2, [R1, #0]
000012AC:             ; 
000012AC:             ;     ;;Setup the ptrs for the crates this will help later on   left<->toFree<->right ;;left,righ
                      ; t can be 0
000012AC:             ;     ;;We're just adding the new crate to the linked list
000012AC:             ;     ;;current->next->prev = toFree
000012AC:             ;     ;;toFree->next = current->next
000012AC:             ;     ;;current->next = toFree
000012AC:             ;     ;;toFree->prev = current
000012AC:             ; 
000012AC: E5913000    ;     ldr R3, [R1, #0] ;;holds current->next
000012B0: E3530000    ;     cmp R3, #0
000012B4: 15830004    ;     strne R0, [R3, #4] ;;current->next->prev = toFree
000012B8: E5803000    ;     str R3, [R0, #0] ;;toFree->next = current->next
000012BC: E5810000    ;     str R0, [R1, #0] ;;current->next = toFree
000012C0: E5801004    ;     str R1, [R0, #4] ;;toFree->prev = current
000012C4:             ; 
000012C4: EA000001    ;     b freeMergeCheck
000012C8:             ; 
000012C8:             ; freelendEnd
000012C8:             ; ;;If there are no more Crates to the right then this could be a new Crate at the end or |F|T| i
                      ; t should merge left 
000012C8:             ; ;;Found a crate (current) that is to the left of the crate as we ran out of ->next ptrs
000012C8:             ; ;;Need to set current->next = toFree
000012C8:             ; ;;            toFree->prev = current
000012C8: E5801004    ;     str R1, [R0, #4] ;;toFree->prev = current
000012CC: E5810000    ;     str R0, [R1, #0] ;;current->next = toFree
000012D0:             ; 
000012D0:             ; freeMergeCheck
000012D0:             ;     ;;We have a ptr to current. This should be the closest Crate to the left of toFree
000012D0:             ;     ;;We also have the next Crate (null or not) which is to the right of toFree
000012D0:             ;     ;;Both of these crates MAY need to be merged but could also have taken crates in between
000012D0:             ;     ;;First is to check if the crates are adjacent
000012D0:             ;     ;;  If they are NOT then create a newCrate
000012D0:             ;     ;;  If they are     then merge both
000012D0:             ;     ;;  If only one     then merge either left or right
000012D0:             ; 
000012D0:             ;     ;;R1 will be left
000012D0:             ;     ;;R2 will be right
000012D0:             ; 
000012D0: E3510000    ;     cmp R1, #0
000012D4: 01A01000    ;     moveq R1, R0 ;;If there is no left crate then left=toFree
000012D8: E3520000    ;     cmp R2, #0
000012DC: 01A02000    ;     moveq R2, R0 ;;If there is no right crate (more likely) then right=toFree
000012E0:             ; 
000012E0:             ; verifyLeft
000012E0:             ;     ;;Check if the left is adjacent
000012E0:             ;     ;;It will be if (left.addr + sizeof(Crate) + left.size == toFree.addr)
000012E0:             ; 
000012E0: E5913008    ;     ldr R3, [R1, #8]
000012E4: E283300C    ;     add R3, R3, #12 ;;12 is sizeof(Crate) + toFree.size
000012E8: E0833001    ;     add R3, R3, R1 ;;left.addr + left->size ??
000012EC:             ; 
000012EC: E1530000    ;     cmp R3, R0
000012F0: 11A01000    ;     movne R1, R0
000012F4:             ; 
000012F4:             ; verifyRight
000012F4:             ;     ;;Going from toFree to Right
000012F4: E5903008    ;     ldr R3, [R0, #8] ;;get size of toFree
000012F8: E283300C    ;     add R3, R3, #12 ;;12 is sizeof(Crate) + toFree.size
000012FC: E0833000    ;     add R3, R3, R0 ;; + toFree.addr
00001300:             ; 
00001300: E1530002    ;     cmp R3, R2
00001304: 11A02000    ;     movne R2, R0
00001308:             ; 
00001308:             ; merge
00001308:             ;     ;;Merge the two Crates given in R1 and R2
00001308:             ;     ;;left can be (left) or (toFree)
00001308:             ;     ;;right can be (right) or (toFree)
00001308:             ;     ;;If left == right: don't merge; create new Crate
00001308:             ;     ;;If left != right: then add to left's size
00001308:             ; 
00001308: E1510002    ;     cmp R1, R2
0000130C: 0A00000A    ;     beq mergeNew
00001310:             ; 
00001310:             ;     ;;The new size is right.addr - left.addr + right->size    from right.addr - left.addr - siz
                      ; eof(Crate) + sizeof(Crate) + right->size
00001310:             ;     ;;                                                               |left      |right
00001310:             ;     ;;                                                               |<12>|size||<12>|size|
00001310:             ;     ;;
00001310:             ;     ;;                                                               |left      
00001310:             ;     ;;                                                               |<12>|size           |
00001310:             ;     ;;
00001310:             ;     ;;I'm doing it this way as the left and right may not be contiguous i.e. if toFree has a fr
                      ; ee crate on either side
00001310:             ; 
00001310: E0423001    ;     sub R3, R2, R1
00001314: E5924008    ;     ldr R4, [R2, #8]
00001318: E0833004    ;     add R3, R3, R4
0000131C: E5813008    ;     str R3, [R1, #8]
00001320:             ; 
00001320:             ;     ;;Time to switch some ptrs
00001320:             ;     ;;Current state left.prev<->left<->right<->right.next (with left or right = toFree) or left
                      ; .prev<->left<->toFree<->right<->right.next
00001320:             ;     ;;New state would be left.prev<->left<->right.next (with left or right = toFree) or left.pr
                      ; ev<->left<->right.next
00001320:             ;     ;;Both cases end the same, so get right.next. These could be 0 but it doesn't matter
00001320:             ;     ;;Next need to change the prev and next ptrs for adjacent Crates
00001320:             ;     ;;i.e. right->next->prev = left
00001320:             ; 
00001320: E5924000    ;     ldr R4, [R2, #0] ;;right->next
00001324: E1540001    ;     cmp R4, R1
00001328: 15814000    ;     strne R4, [R1, #0] ;;left->next = right->next
0000132C: 13A04000    ;     movne R4, #0
00001330: 15814000    ;     strne R4, [R1, #0]
00001334:             ; 
00001334: E3540000    ;     cmp R4, #0
00001338: 15841004    ;     strne R1, [R4, #4] ;;right->next->prev = left
0000133C:             ; 
0000133C:             ; mergeNew
0000133C:             ;     ;;The crate has already been setup with its ptrs and had its size as well so don't need to 
                      ; do anything
0000133C:             ; 
0000133C:             ; freeEnd
0000133C: E8BD01F0    ;     pop {R4-R8}
00001340: E1A0F00E    ;     mov R15, R14
00001344:             ; 
00001344:             ; align
00001344:             ; 
00001344:             ; ;;String defs -- The naming scheme is bad :(
00001344: 2D 2D 2D 2D ; welcomemsg      defb "-----------Welcome to JCGOL in ARM32-----------", nl, 0
00001348: 2D 2D 2D 2D ; 
0000134C: 2D 2D 2D 57 ; 
00001350: 65 6C 63 6F ; 
00001354: 6D 65 20 74 ; 
00001358: 6F 20 4A 43 ; 
0000135C: 47 4F 4C 20 ; 
00001360: 69 6E 20 41 ; 
00001364: 52 4D 33 32 ; 
00001368: 2D 2D 2D 2D ; 
0000136C: 2D 2D 2D 2D ; 
00001370: 2D 2D 2D 0A ; 
00001374: 00          ; 
00001375: 28 4E 29 65 ; welcome2msg     defb "(N)ew board\n(L)oad a saved board\n(H)elp msg\n(S)ettings\n(Q)uit", nl, 0
00001379: 77 20 62 6F ; 
0000137D: 61 72 64 0A ; 
00001381: 28 4C 29 6F ; 
00001385: 61 64 20 61 ; 
00001389: 20 73 61 76 ; 
0000138D: 65 64 20 62 ; 
00001391: 6F 61 72 64 ; 
00001395: 0A 28 48 29 ; 
00001399: 65 6C 70 20 ; 
0000139D: 6D 73 67 0A ; 
000013A1: 28 53 29 65 ; 
000013A5: 74 74 69 6E ; 
000013A9: 67 73 0A 28 ; 
000013AD: 51 29 75 69 ; 
000013B1: 74 0A 00    ; 
000013B4: 49 6E 76 61 ; mainchoicefail  defb "Invalid choice please enter 'n' for new board, 'l' for load a board, 'h' 
000013B8: 6C 69 64 20 ; to view help message, 's' to view settings, or 'q' to close. Not cases sensative", nl, 0
000013BC: 63 68 6F 69 ; 
000013C0: 63 65 20 70 ; 
000013C4: 6C 65 61 73 ; 
000013C8: 65 20 65 6E ; 
000013CC: 74 65 72 20 ; 
000013D0: 27 6E 27 20 ; 
000013D4: 66 6F 72 20 ; 
000013D8: 6E 65 77 20 ; 
000013DC: 62 6F 61 72 ; 
000013E0: 64 2C 20 27 ; 
000013E4: 6C 27 20 66 ; 
000013E8: 6F 72 20 6C ; 
000013EC: 6F 61 64 20 ; 
000013F0: 61 20 62 6F ; 
000013F4: 61 72 64 2C ; 
000013F8: 20 27 68 27 ; 
000013FC: 20 74 6F 20 ; 
00001400: 76 69 65 77 ; 
00001404: 20 68 65 6C ; 
00001408: 70 20 6D 65 ; 
0000140C: 73 73 61 67 ; 
00001410: 65 2C 20 27 ; 
00001414: 73 27 20 74 ; 
00001418: 6F 20 76 69 ; 
0000141C: 65 77 20 73 ; 
00001420: 65 74 74 69 ; 
00001424: 6E 67 73 2C ; 
00001428: 20 6F 72 20 ; 
0000142C: 27 71 27 20 ; 
00001430: 74 6F 20 63 ; 
00001434: 6C 6F 73 65 ; 
00001438: 2E 20 4E 6F ; 
0000143C: 74 20 63 61 ; 
00001440: 73 65 73 20 ; 
00001444: 73 65 6E 73 ; 
00001448: 61 74 69 76 ; 
0000144C: 65 0A 00    ; 
0000144F: 53 6C 6F 77 ; helpmsg         defb "Slow mode will create a pause between each grid print to make it more rea
00001453: 20 6D 6F 64 ; dable - can't use with step mode\nErase mode will erase the previous board before printing the 
00001457: 65 20 77 69 ; next - [is 2x slower]\n", 0
0000145B: 6C 6C 20 63 ; 
0000145F: 72 65 61 74 ; 
00001463: 65 20 61 20 ; 
00001467: 70 61 75 73 ; 
0000146B: 65 20 62 65 ; 
0000146F: 74 77 65 65 ; 
00001473: 6E 20 65 61 ; 
00001477: 63 68 20 67 ; 
0000147B: 72 69 64 20 ; 
0000147F: 70 72 69 6E ; 
00001483: 74 20 74 6F ; 
00001487: 20 6D 61 6B ; 
0000148B: 65 20 69 74 ; 
0000148F: 20 6D 6F 72 ; 
00001493: 65 20 72 65 ; 
00001497: 61 64 61 62 ; 
0000149B: 6C 65 20 2D ; 
0000149F: 20 63 61 6E ; 
000014A3: 27 74 20 75 ; 
000014A7: 73 65 20 77 ; 
000014AB: 69 74 68 20 ; 
000014AF: 73 74 65 70 ; 
000014B3: 20 6D 6F 64 ; 
000014B7: 65 0A 45 72 ; 
000014BB: 61 73 65 20 ; 
000014BF: 6D 6F 64 65 ; 
000014C3: 20 77 69 6C ; 
000014C7: 6C 20 65 72 ; 
000014CB: 61 73 65 20 ; 
000014CF: 74 68 65 20 ; 
000014D3: 70 72 65 76 ; 
000014D7: 69 6F 75 73 ; 
000014DB: 20 62 6F 61 ; 
000014DF: 72 64 20 62 ; 
000014E3: 65 66 6F 72 ; 
000014E7: 65 20 70 72 ; 
000014EB: 69 6E 74 69 ; 
000014EF: 6E 67 20 74 ; 
000014F3: 68 65 20 6E ; 
000014F7: 65 78 74 20 ; 
000014FB: 2D 20 5B 69 ; 
000014FF: 73 20 32 78 ; 
00001503: 20 73 6C 6F ; 
00001507: 77 65 72 5D ; 
0000150B: 0A 00       ; 
0000150D: 53 69 6E 67 ; help2msg        defb "Single step mode will prompt for input each time a grid is drawn, you can
00001511: 6C 65 20 73 ;  (s)ave the current state or (q)uit to menu", 0
00001515: 74 65 70 20 ; 
00001519: 6D 6F 64 65 ; 
0000151D: 20 77 69 6C ; 
00001521: 6C 20 70 72 ; 
00001525: 6F 6D 70 74 ; 
00001529: 20 66 6F 72 ; 
0000152D: 20 69 6E 70 ; 
00001531: 75 74 20 65 ; 
00001535: 61 63 68 20 ; 
00001539: 74 69 6D 65 ; 
0000153D: 20 61 20 67 ; 
00001541: 72 69 64 20 ; 
00001545: 69 73 20 64 ; 
00001549: 72 61 77 6E ; 
0000154D: 2C 20 79 6F ; 
00001551: 75 20 63 61 ; 
00001555: 6E 20 28 73 ; 
00001559: 29 61 76 65 ; 
0000155D: 20 74 68 65 ; 
00001561: 20 63 75 72 ; 
00001565: 72 65 6E 74 ; 
00001569: 20 73 74 61 ; 
0000156D: 74 65 20 6F ; 
00001571: 72 20 28 71 ; 
00001575: 29 75 69 74 ; 
00001579: 20 74 6F 20 ; 
0000157D: 6D 65 6E 75 ; 
00001581: 00          ; 
00001582: 54 68 61 6E ; mainendmsg      defb "Thank you for playing JCGOL for ARM32", nl, 0
00001586: 6B 20 79 6F ; 
0000158A: 75 20 66 6F ; 
0000158E: 72 20 70 6C ; 
00001592: 61 79 69 6E ; 
00001596: 67 20 4A 43 ; 
0000159A: 47 4F 4C 20 ; 
0000159E: 66 6F 72 20 ; 
000015A2: 41 52 4D 33 ; 
000015A6: 32 0A 00    ; 
000015A9: 57 6F 75 6C ; askdefaults     defb "Would you like to use the default settings? Y/n: ", 0
000015AD: 64 20 79 6F ; 
000015B1: 75 20 6C 69 ; 
000015B5: 6B 65 20 74 ; 
000015B9: 6F 20 75 73 ; 
000015BD: 65 20 74 68 ; 
000015C1: 65 20 64 65 ; 
000015C5: 66 61 75 6C ; 
000015C9: 74 20 73 65 ; 
000015CD: 74 74 69 6E ; 
000015D1: 67 73 3F 20 ; 
000015D5: 59 2F 6E 3A ; 
000015D9: 20 00       ; 
000015DB: 45 6E 61 62 ; askerase        defb "Enable erase mode? Y/n: ", 0
000015DF: 6C 65 20 65 ; 
000015E3: 72 61 73 65 ; 
000015E7: 20 6D 6F 64 ; 
000015EB: 65 3F 20 59 ; 
000015EF: 2F 6E 3A 20 ; 
000015F3: 00          ; 
000015F4: 45 6E 61 62 ; askslow         defb "Enable slow mode? Y/n: ", 0
000015F8: 6C 65 20 73 ; 
000015FC: 6C 6F 77 20 ; 
00001600: 6D 6F 64 65 ; 
00001604: 3F 20 59 2F ; 
00001608: 6E 3A 20 00 ; 
0000160C: 45 6E 61 62 ; askstep         defb "Enable step mode? Y/n: ", 0
00001610: 6C 65 20 73 ; 
00001614: 74 65 70 20 ; 
00001618: 6D 6F 64 65 ; 
0000161C: 3F 20 59 2F ; 
00001620: 6E 3A 20 00 ; 
00001624: 43 61 6E 6E ; stepslowwarning defb "Cannot have slow and step mode active at the same time, disabling slow mo
00001628: 6F 74 20 68 ; de", nl, 0
0000162C: 61 76 65 20 ; 
00001630: 73 6C 6F 77 ; 
00001634: 20 61 6E 64 ; 
00001638: 20 73 74 65 ; 
0000163C: 70 20 6D 6F ; 
00001640: 64 65 20 61 ; 
00001644: 63 74 69 76 ; 
00001648: 65 20 61 74 ; 
0000164C: 20 74 68 65 ; 
00001650: 20 73 61 6D ; 
00001654: 65 20 74 69 ; 
00001658: 6D 65 2C 20 ; 
0000165C: 64 69 73 61 ; 
00001660: 62 6C 69 6E ; 
00001664: 67 20 73 6C ; 
00001668: 6F 77 20 6D ; 
0000166C: 6F 64 65 0A ; 
00001670: 00          ; 
00001671: 52 65 74 75 ; savedchoice     defb "Return to menu? (n for continue sim) Y/n: ", 0
00001675: 72 6E 20 74 ; 
00001679: 6F 20 6D 65 ; 
0000167D: 6E 75 3F 20 ; 
00001681: 28 6E 20 66 ; 
00001685: 6F 72 20 63 ; 
00001689: 6F 6E 74 69 ; 
0000168D: 6E 75 65 20 ; 
00001691: 73 69 6D 29 ; 
00001695: 20 59 2F 6E ; 
00001699: 3A 20 00    ; 
0000169C: 50 6C 65 61 ; askname         defb "Please enter a name for the grid: ", 0
000016A0: 73 65 20 65 ; 
000016A4: 6E 74 65 72 ; 
000016A8: 20 61 20 6E ; 
000016AC: 61 6D 65 20 ; 
000016B0: 66 6F 72 20 ; 
000016B4: 74 68 65 20 ; 
000016B8: 67 72 69 64 ; 
000016BC: 3A 20 00    ; 
000016BF: 45 72 61 73 ; warneraseslow   defb "Erase mode is active it is recommended to also use slow mode", nl, 0
000016C3: 65 20 6D 6F ; 
000016C7: 64 65 20 69 ; 
000016CB: 73 20 61 63 ; 
000016CF: 74 69 76 65 ; 
000016D3: 20 69 74 20 ; 
000016D7: 69 73 20 72 ; 
000016DB: 65 63 6F 6D ; 
000016DF: 6D 65 6E 64 ; 
000016E3: 65 64 20 74 ; 
000016E7: 6F 20 61 6C ; 
000016EB: 73 6F 20 75 ; 
000016EF: 73 65 20 73 ; 
000016F3: 6C 6F 77 20 ; 
000016F7: 6D 6F 64 65 ; 
000016FB: 0A 00       ; 
000016FD: 50 6C 65 61 ; askwid          defb "Please enter a width (1-30): ", 0
00001701: 73 65 20 65 ; 
00001705: 6E 74 65 72 ; 
00001709: 20 61 20 77 ; 
0000170D: 69 64 74 68 ; 
00001711: 20 28 31 2D ; 
00001715: 33 30 29 3A ; 
00001719: 20 00       ; 
0000171B: 50 6C 65 61 ; askhei          defb "Please enter a height (1-30): ", 0
0000171F: 73 65 20 65 ; 
00001723: 6E 74 65 72 ; 
00001727: 20 61 20 68 ; 
0000172B: 65 69 67 68 ; 
0000172F: 74 20 28 31 ; 
00001733: 2D 33 30 29 ; 
00001737: 3A 20 00    ; 
0000173A: 49 6E 76 61 ; getwidfailmsg   defb "Invalid width please enter a value between 1-30 inclusive: ", 0
0000173E: 6C 69 64 20 ; 
00001742: 77 69 64 74 ; 
00001746: 68 20 70 6C ; 
0000174A: 65 61 73 65 ; 
0000174E: 20 65 6E 74 ; 
00001752: 65 72 20 61 ; 
00001756: 20 76 61 6C ; 
0000175A: 75 65 20 62 ; 
0000175E: 65 74 77 65 ; 
00001762: 65 6E 20 31 ; 
00001766: 2D 33 30 20 ; 
0000176A: 69 6E 63 6C ; 
0000176E: 75 73 69 76 ; 
00001772: 65 3A 20 00 ; 
00001776: 49 6E 76 61 ; getheifailmsg   defb "Invalid height please enter a value between 1-30 inclusive: ", 0
0000177A: 6C 69 64 20 ; 
0000177E: 68 65 69 67 ; 
00001782: 68 74 20 70 ; 
00001786: 6C 65 61 73 ; 
0000178A: 65 20 65 6E ; 
0000178E: 74 65 72 20 ; 
00001792: 61 20 76 61 ; 
00001796: 6C 75 65 20 ; 
0000179A: 62 65 74 77 ; 
0000179E: 65 65 6E 20 ; 
000017A2: 31 2D 33 30 ; 
000017A6: 20 69 6E 63 ; 
000017AA: 6C 75 73 69 ; 
000017AE: 76 65 3A 20 ; 
000017B2: 00          ; 
000017B3:             ; 
000017B3:             ; ;;[[todo]] change to printing the current options
000017B3: 55 73 69 6E ; usingDefault    defb "Using default values: dims=(18, 18) slowMode=Off eraseMode=Off stepMode=O
000017B7: 67 20 64 65 ; n", nl, 0
000017BB: 66 61 75 6C ; 
000017BF: 74 20 76 61 ; 
000017C3: 6C 75 65 73 ; 
000017C7: 3A 20 64 69 ; 
000017CB: 6D 73 3D 28 ; 
000017CF: 31 38 2C 20 ; 
000017D3: 31 38 29 20 ; 
000017D7: 73 6C 6F 77 ; 
000017DB: 4D 6F 64 65 ; 
000017DF: 3D 4F 66 66 ; 
000017E3: 20 65 72 61 ; 
000017E7: 73 65 4D 6F ; 
000017EB: 64 65 3D 4F ; 
000017EF: 66 66 20 73 ; 
000017F3: 74 65 70 4D ; 
000017F7: 6F 64 65 3D ; 
000017FB: 4F 6E 0A 00 ; 
000017FF: 55 73 69 6E ; usingDefWODims  defb "Using default values: slowMode=Off eraseMode=Off stepMode=On", nl, 0
00001803: 67 20 64 65 ; 
00001807: 66 61 75 6C ; 
0000180B: 74 20 76 61 ; 
0000180F: 6C 75 65 73 ; 
00001813: 3A 20 73 6C ; 
00001817: 6F 77 4D 6F ; 
0000181B: 64 65 3D 4F ; 
0000181F: 66 66 20 65 ; 
00001823: 72 61 73 65 ; 
00001827: 4D 6F 64 65 ; 
0000182B: 3D 4F 66 66 ; 
0000182F: 20 73 74 65 ; 
00001833: 70 4D 6F 64 ; 
00001837: 65 3D 4F 6E ; 
0000183B: 0A 00       ; 
0000183D:             ; 
0000183D: 43 75 72 72 ; optionsp_1      defb "Current options: dims=(", 0 ;;width
00001841: 65 6E 74 20 ; 
00001845: 6F 70 74 69 ; 
00001849: 6F 6E 73 3A ; 
0000184D: 20 64 69 6D ; 
00001851: 73 3D 28 00 ; 
00001855: 2C 20 00    ; optionsp_2      defb ", ", 0 ;;height
00001858: 29 20 73 6C ; optionsp_3      defb ") slowMode=", 0 ;;OFF/ON
0000185C: 6F 77 4D 6F ; 
00001860: 64 65 3D 00 ; 
00001864: 20 65 72 61 ; optionsp_4      defb " eraseMode=", 0 ;;^
00001868: 73 65 4D 6F ; 
0000186C: 64 65 3D 00 ; 
00001870: 20 73 74 65 ; optionsp_5      defb " stepMode=", 0  ;;^
00001874: 70 4D 6F 64 ; 
00001878: 65 3D 00    ; 
0000187B:             ; 
0000187B: 59 6F 75 27 ; mainloopittsmsg defb "You've reached the max itterations before waiting for input. You can chan
0000187F: 76 65 20 72 ; ge this in settings. Press any key to continue", nl, 0
00001883: 65 61 63 68 ; 
00001887: 65 64 20 74 ; 
0000188B: 68 65 20 6D ; 
0000188F: 61 78 20 69 ; 
00001893: 74 74 65 72 ; 
00001897: 61 74 69 6F ; 
0000189B: 6E 73 20 62 ; 
0000189F: 65 66 6F 72 ; 
000018A3: 65 20 77 61 ; 
000018A7: 69 74 69 6E ; 
000018AB: 67 20 66 6F ; 
000018AF: 72 20 69 6E ; 
000018B3: 70 75 74 2E ; 
000018B7: 20 59 6F 75 ; 
000018BB: 20 63 61 6E ; 
000018BF: 20 63 68 61 ; 
000018C3: 6E 67 65 20 ; 
000018C7: 74 68 69 73 ; 
000018CB: 20 69 6E 20 ; 
000018CF: 73 65 74 74 ; 
000018D3: 69 6E 67 73 ; 
000018D7: 2E 20 50 72 ; 
000018DB: 65 73 73 20 ; 
000018DF: 61 6E 79 20 ; 
000018E3: 6B 65 79 20 ; 
000018E7: 74 6F 20 63 ; 
000018EB: 6F 6E 74 69 ; 
000018EF: 6E 75 65 0A ; 
000018F3: 00          ; 
000018F4:             ; 
000018F4: 43 68 6F 6F ; askgenoption    defb "Choose between (R)andom generation or (D)rawing the grid", 0
000018F8: 73 65 20 62 ; 
000018FC: 65 74 77 65 ; 
00001900: 65 6E 20 28 ; 
00001904: 52 29 61 6E ; 
00001908: 64 6F 6D 20 ; 
0000190C: 67 65 6E 65 ; 
00001910: 72 61 74 69 ; 
00001914: 6F 6E 20 6F ; 
00001918: 72 20 28 44 ; 
0000191C: 29 72 61 77 ; 
00001920: 69 6E 67 20 ; 
00001924: 74 68 65 20 ; 
00001928: 67 72 69 64 ; 
0000192C: 00          ; 
0000192D: 49 6E 76 61 ; setupGrdFailmsg defb "Invalid choice, use `R` for random generation and `d` for drawing the gri
00001931: 6C 69 64 20 ; d. Not case sensative: ", 0
00001935: 63 68 6F 69 ; 
00001939: 63 65 2C 20 ; 
0000193D: 75 73 65 20 ; 
00001941: 60 52 60 20 ; 
00001945: 66 6F 72 20 ; 
00001949: 72 61 6E 64 ; 
0000194D: 6F 6D 20 67 ; 
00001951: 65 6E 65 72 ; 
00001955: 61 74 69 6F ; 
00001959: 6E 20 61 6E ; 
0000195D: 64 20 60 64 ; 
00001961: 60 20 66 6F ; 
00001965: 72 20 64 72 ; 
00001969: 61 77 69 6E ; 
0000196D: 67 20 74 68 ; 
00001971: 65 20 67 72 ; 
00001975: 69 64 2E 20 ; 
00001979: 4E 6F 74 20 ; 
0000197D: 63 61 73 65 ; 
00001981: 20 73 65 6E ; 
00001985: 73 61 74 69 ; 
00001989: 76 65 3A 20 ; 
0000198D: 00          ; 
0000198E: 45 6E 74 65 ; askseed         defb "Enter 4 characters to be used as the seed: ", 0
00001992: 72 20 34 20 ; 
00001996: 63 68 61 72 ; 
0000199A: 61 63 74 65 ; 
0000199E: 72 73 20 74 ; 
000019A2: 6F 20 62 65 ; 
000019A6: 20 75 73 65 ; 
000019AA: 64 20 61 73 ; 
000019AE: 20 74 68 65 ; 
000019B2: 20 73 65 65 ; 
000019B6: 64 3A 20 00 ; 
000019BA: 55 73 69 6E ; drawinfomsg     defb "Using '1' and '0' choose the value of the current cell", nl, 0
000019BE: 67 20 27 31 ; 
000019C2: 27 20 61 6E ; 
000019C6: 64 20 27 30 ; 
000019CA: 27 20 63 68 ; 
000019CE: 6F 6F 73 65 ; 
000019D2: 20 74 68 65 ; 
000019D6: 20 76 61 6C ; 
000019DA: 75 65 20 6F ; 
000019DE: 66 20 74 68 ; 
000019E2: 65 20 63 75 ; 
000019E6: 72 72 65 6E ; 
000019EA: 74 20 63 65 ; 
000019EE: 6C 6C 0A 00 ; 
000019F2: 49 6E 76 61 ; drawfailmsg     defb "Invalid input please enter 1 or 0: ", nl, 0
000019F6: 6C 69 64 20 ; 
000019FA: 69 6E 70 75 ; 
000019FE: 74 20 70 6C ; 
00001A02: 65 61 73 65 ; 
00001A06: 20 65 6E 74 ; 
00001A0A: 65 72 20 31 ; 
00001A0E: 20 6F 72 20 ; 
00001A12: 30 3A 20 0A ; 
00001A16: 00          ; 
00001A17: 47 72 69 64 ; gridfailmsg     defb "Grid was not properly initialised, consider smaller dims", nl, 0
00001A1B: 20 77 61 73 ; 
00001A1F: 20 6E 6F 74 ; 
00001A23: 20 70 72 6F ; 
00001A27: 70 65 72 6C ; 
00001A2B: 79 20 69 6E ; 
00001A2F: 69 74 69 61 ; 
00001A33: 6C 69 73 65 ; 
00001A37: 64 2C 20 63 ; 
00001A3B: 6F 6E 73 69 ; 
00001A3F: 64 65 72 20 ; 
00001A43: 73 6D 61 6C ; 
00001A47: 6C 65 72 20 ; 
00001A4B: 64 69 6D 73 ; 
00001A4F: 0A 00       ; 
00001A51: 54 68 65 72 ; gridsavefail    defb "There was an error allocating memory for the grid save", nl, 0
00001A55: 65 20 77 61 ; 
00001A59: 73 20 61 6E ; 
00001A5D: 20 65 72 72 ; 
00001A61: 6F 72 20 61 ; 
00001A65: 6C 6C 6F 63 ; 
00001A69: 61 74 69 6E ; 
00001A6D: 67 20 6D 65 ; 
00001A71: 6D 6F 72 79 ; 
00001A75: 20 66 6F 72 ; 
00001A79: 20 74 68 65 ; 
00001A7D: 20 67 72 69 ; 
00001A81: 64 20 73 61 ; 
00001A85: 76 65 0A 00 ; 
00001A89: 54 68 65 72 ; gridloadempty   defb "There are no saved grids, start a step mode sim and save the grid, return
00001A8D: 65 20 61 72 ;  to main menu to load", nl, 0
00001A91: 65 20 6E 6F ; 
00001A95: 20 73 61 76 ; 
00001A99: 65 64 20 67 ; 
00001A9D: 72 69 64 73 ; 
00001AA1: 2C 20 73 74 ; 
00001AA5: 61 72 74 20 ; 
00001AA9: 61 20 73 74 ; 
00001AAD: 65 70 20 6D ; 
00001AB1: 6F 64 65 20 ; 
00001AB5: 73 69 6D 20 ; 
00001AB9: 61 6E 64 20 ; 
00001ABD: 73 61 76 65 ; 
00001AC1: 20 74 68 65 ; 
00001AC5: 20 67 72 69 ; 
00001AC9: 64 2C 20 72 ; 
00001ACD: 65 74 75 72 ; 
00001AD1: 6E 20 74 6F ; 
00001AD5: 20 6D 61 69 ; 
00001AD9: 6E 20 6D 65 ; 
00001ADD: 6E 75 20 74 ; 
00001AE1: 6F 20 6C 6F ; 
00001AE5: 61 64 0A 00 ; 
00001AE9: 7C 69 6E 64 ; gridloadpindex  defb "|index: ", 0
00001AED: 65 78 3A 20 ; 
00001AF1: 00          ; 
00001AF2: 7C 6E 61 6D ; gridloadpname   defb "|name: ", 0
00001AF6: 65 3A 20 00 ; 
00001AFA: 7C 77 69 64 ; gridloadpwidth  defb "|width: ", 0
00001AFE: 74 68 3A 20 ; 
00001B02: 00          ; 
00001B03: 7C 68 65 69 ; gridloadpheight defb "|height: ", 0
00001B07: 67 68 74 3A ; 
00001B0B: 20 00       ; 
00001B0D: 50 6C 65 61 ; loadboardaski   defb "Please enter the index of the grid to load, or enter a negative index to 
00001B11: 73 65 20 65 ; not load a grid. (press enter to input)", nl, 0
00001B15: 6E 74 65 72 ; 
00001B19: 20 74 68 65 ; 
00001B1D: 20 69 6E 64 ; 
00001B21: 65 78 20 6F ; 
00001B25: 66 20 74 68 ; 
00001B29: 65 20 67 72 ; 
00001B2D: 69 64 20 74 ; 
00001B31: 6F 20 6C 6F ; 
00001B35: 61 64 2C 20 ; 
00001B39: 6F 72 20 65 ; 
00001B3D: 6E 74 65 72 ; 
00001B41: 20 61 20 6E ; 
00001B45: 65 67 61 74 ; 
00001B49: 69 76 65 20 ; 
00001B4D: 69 6E 64 65 ; 
00001B51: 78 20 74 6F ; 
00001B55: 20 6E 6F 74 ; 
00001B59: 20 6C 6F 61 ; 
00001B5D: 64 20 61 20 ; 
00001B61: 67 72 69 64 ; 
00001B65: 2E 20 28 70 ; 
00001B69: 72 65 73 73 ; 
00001B6D: 20 65 6E 74 ; 
00001B71: 65 72 20 74 ; 
00001B75: 6F 20 69 6E ; 
00001B79: 70 75 74 29 ; 
00001B7D: 0A 00       ; 
00001B7F: 52 65 74 75 ; loadboardretmsg defb "Returning to main menu", nl, 0
00001B83: 72 6E 69 6E ; 
00001B87: 67 20 74 6F ; 
00001B8B: 20 6D 61 69 ; 
00001B8F: 6E 20 6D 65 ; 
00001B93: 6E 75 0A 00 ; 
00001B97: 49 6E 76 61 ; loadboardifail  defb "Invalid input given for the index", nl, 0
00001B9B: 6C 69 64 20 ; 
00001B9F: 69 6E 70 75 ; 
00001BA3: 74 20 67 69 ; 
00001BA7: 76 65 6E 20 ; 
00001BAB: 66 6F 72 20 ; 
00001BAF: 74 68 65 20 ; 
00001BB3: 69 6E 64 65 ; 
00001BB7: 78 0A 00    ; 
00001BBA: 49 6E 76 61 ; loadboardirerr  defb "Invalid index, out of range", nl, 0
00001BBE: 6C 69 64 20 ; 
00001BC2: 69 6E 64 65 ; 
00001BC6: 78 2C 20 6F ; 
00001BCA: 75 74 20 6F ; 
00001BCE: 66 20 72 61 ; 
00001BD2: 6E 67 65 0A ; 
00001BD6: 00          ; 
00001BD7: 45 72 72 6F ; loadboardmlcerr defb "Error allocating memory for loaded grid. Returing to main menu", nl, 0
00001BDB: 72 20 61 6C ; 
00001BDF: 6C 6F 63 61 ; 
00001BE3: 74 69 6E 67 ; 
00001BE7: 20 6D 65 6D ; 
00001BEB: 6F 72 79 20 ; 
00001BEF: 66 6F 72 20 ; 
00001BF3: 6C 6F 61 64 ; 
00001BF7: 65 64 20 67 ; 
00001BFB: 72 69 64 2E ; 
00001BFF: 20 52 65 74 ; 
00001C03: 75 72 69 6E ; 
00001C07: 67 20 74 6F ; 
00001C0B: 20 6D 61 69 ; 
00001C0F: 6E 20 6D 65 ; 
00001C13: 6E 75 0A 00 ; 
00001C17: 53 75 63 63 ; loadboardsucmsg defb "Successfully loaded the grid", nl, 0
00001C1B: 65 73 73 66 ; 
00001C1F: 75 6C 6C 79 ; 
00001C23: 20 6C 6F 61 ; 
00001C27: 64 65 64 20 ; 
00001C2B: 74 68 65 20 ; 
00001C2F: 67 72 69 64 ; 
00001C33: 0A 00       ; 
00001C35: 4C 69 73 74 ; listgridmsg     defb "Listing all availible saved grids", nl, 0
00001C39: 69 6E 67 20 ; 
00001C3D: 61 6C 6C 20 ; 
00001C41: 61 76 61 69 ; 
00001C45: 6C 69 62 6C ; 
00001C49: 65 20 73 61 ; 
00001C4D: 76 65 64 20 ; 
00001C51: 67 72 69 64 ; 
00001C55: 73 0A 00    ; 
00001C58: 2D 2D 2D 2D ; cutoff          defb "-----------------", nl, 0
00001C5C: 2D 2D 2D 2D ; 
00001C60: 2D 2D 2D 2D ; 
00001C64: 2D 2D 2D 2D ; 
00001C68: 2D 0A 00    ; 
00001C6B: 5B 5B 61 64 ; helpinfomsg     defb "[[add]]"
00001C6F: 64 5D 5D    ; 
00001C72: 5B 5B 61 64 ; settingsmsg     defb "[[add]]"
00001C76: 64 5D 5D    ; 
00001C79:             ; 
00001C79: 53 65 74 74 ; s_m1            defb "Settings", nl, "|-[0] stepMode_d     - The following 4 settings are the d
00001C7D: 69 6E 67 73 ; efault values for the options", nl, "|-[1] slowMode_d", nl, "|-[2] eraseMode_d", nl, "|-[3] Dim
00001C81: 0A 7C 2D 5B ; s_d", nl, 0
00001C85: 30 5D 20 73 ; 
00001C89: 74 65 70 4D ; 
00001C8D: 6F 64 65 5F ; 
00001C91: 64 20 20 20 ; 
00001C95: 20 20 2D 20 ; 
00001C99: 54 68 65 20 ; 
00001C9D: 66 6F 6C 6C ; 
00001CA1: 6F 77 69 6E ; 
00001CA5: 67 20 34 20 ; 
00001CA9: 73 65 74 74 ; 
00001CAD: 69 6E 67 73 ; 
00001CB1: 20 61 72 65 ; 
00001CB5: 20 74 68 65 ; 
00001CB9: 20 64 65 66 ; 
00001CBD: 61 75 6C 74 ; 
00001CC1: 20 76 61 6C ; 
00001CC5: 75 65 73 20 ; 
00001CC9: 66 6F 72 20 ; 
00001CCD: 74 68 65 20 ; 
00001CD1: 6F 70 74 69 ; 
00001CD5: 6F 6E 73 0A ; 
00001CD9: 7C 2D 5B 31 ; 
00001CDD: 5D 20 73 6C ; 
00001CE1: 6F 77 4D 6F ; 
00001CE5: 64 65 5F 64 ; 
00001CE9: 0A 7C 2D 5B ; 
00001CED: 32 5D 20 65 ; 
00001CF1: 72 61 73 65 ; 
00001CF5: 4D 6F 64 65 ; 
00001CF9: 5F 64 0A 7C ; 
00001CFD: 2D 5B 33 5D ; 
00001D01: 20 44 69 6D ; 
00001D05: 73 5F 64 0A ; 
00001D09: 00          ; 
00001D0A: 7C 2D 5B 34 ; s_m2            defb "|-[4] range          - The range of values that the dims can have (1-255 
00001D0E: 5D 20 72 61 ; && range_min < range_max)", nl, 0
00001D12: 6E 67 65 20 ; 
00001D16: 20 20 20 20 ; 
00001D1A: 20 20 20 20 ; 
00001D1E: 20 2D 20 54 ; 
00001D22: 68 65 20 72 ; 
00001D26: 61 6E 67 65 ; 
00001D2A: 20 6F 66 20 ; 
00001D2E: 76 61 6C 75 ; 
00001D32: 65 73 20 74 ; 
00001D36: 68 61 74 20 ; 
00001D3A: 74 68 65 20 ; 
00001D3E: 64 69 6D 73 ; 
00001D42: 20 63 61 6E ; 
00001D46: 20 68 61 76 ; 
00001D4A: 65 20 28 31 ; 
00001D4E: 2D 32 35 35 ; 
00001D52: 20 26 26 20 ; 
00001D56: 72 61 6E 67 ; 
00001D5A: 65 5F 6D 69 ; 
00001D5E: 6E 20 3C 20 ; 
00001D62: 72 61 6E 67 ; 
00001D66: 65 5F 6D 61 ; 
00001D6A: 78 29 0A 00 ; 
00001D6E: 7C 2D 5B 35 ; s_m3            defb "|-[5] Icons          - The characters printed for an alive/dead/ptr cell"
00001D72: 5D 20 49 63 ; ,nl, "`-[6] itters         - The number of itterations in the non-step version before it will w
00001D76: 6F 6E 73 20 ; ait for input", nl, 0
00001D7A: 20 20 20 20 ; 
00001D7E: 20 20 20 20 ; 
00001D82: 20 2D 20 54 ; 
00001D86: 68 65 20 63 ; 
00001D8A: 68 61 72 61 ; 
00001D8E: 63 74 65 72 ; 
00001D92: 73 20 70 72 ; 
00001D96: 69 6E 74 65 ; 
00001D9A: 64 20 66 6F ; 
00001D9E: 72 20 61 6E ; 
00001DA2: 20 61 6C 69 ; 
00001DA6: 76 65 2F 64 ; 
00001DAA: 65 61 64 2F ; 
00001DAE: 70 74 72 20 ; 
00001DB2: 63 65 6C 6C ; 
00001DB6: 0A 60 2D 5B ; 
00001DBA: 36 5D 20 69 ; 
00001DBE: 74 74 65 72 ; 
00001DC2: 73 20 20 20 ; 
00001DC6: 20 20 20 20 ; 
00001DCA: 20 20 2D 20 ; 
00001DCE: 54 68 65 20 ; 
00001DD2: 6E 75 6D 62 ; 
00001DD6: 65 72 20 6F ; 
00001DDA: 66 20 69 74 ; 
00001DDE: 74 65 72 61 ; 
00001DE2: 74 69 6F 6E ; 
00001DE6: 73 20 69 6E ; 
00001DEA: 20 74 68 65 ; 
00001DEE: 20 6E 6F 6E ; 
00001DF2: 2D 73 74 65 ; 
00001DF6: 70 20 76 65 ; 
00001DFA: 72 73 69 6F ; 
00001DFE: 6E 20 62 65 ; 
00001E02: 66 6F 72 65 ; 
00001E06: 20 69 74 20 ; 
00001E0A: 77 69 6C 6C ; 
00001E0E: 20 77 61 69 ; 
00001E12: 74 20 66 6F ; 
00001E16: 72 20 69 6E ; 
00001E1A: 70 75 74 0A ; 
00001E1E: 00          ; 
00001E1F: 45 6E 74 65 ; s_m             defb "Enter the index of the setting to edit or -1 to return to the menu (press
00001E23: 72 20 74 68 ;  enter to input): ", 0
00001E27: 65 20 69 6E ; 
00001E2B: 64 65 78 20 ; 
00001E2F: 6F 66 20 74 ; 
00001E33: 68 65 20 73 ; 
00001E37: 65 74 74 69 ; 
00001E3B: 6E 67 20 74 ; 
00001E3F: 6F 20 65 64 ; 
00001E43: 69 74 20 6F ; 
00001E47: 72 20 2D 31 ; 
00001E4B: 20 74 6F 20 ; 
00001E4F: 72 65 74 75 ; 
00001E53: 72 6E 20 74 ; 
00001E57: 6F 20 74 68 ; 
00001E5B: 65 20 6D 65 ; 
00001E5F: 6E 75 20 28 ; 
00001E63: 70 72 65 73 ; 
00001E67: 73 20 65 6E ; 
00001E6B: 74 65 72 20 ; 
00001E6F: 74 6F 20 69 ; 
00001E73: 6E 70 75 74 ; 
00001E77: 29 3A 20 00 ; 
00001E7B: 45 72 72 6F ; s_m_err         defb "Error invalid index. Re-enter: ", 0
00001E7F: 72 20 69 6E ; 
00001E83: 76 61 6C 69 ; 
00001E87: 64 20 69 6E ; 
00001E8B: 64 65 78 2E ; 
00001E8F: 20 52 65 2D ; 
00001E93: 65 6E 74 65 ; 
00001E97: 72 3A 20 00 ; 
00001E9B:             ; 
00001E9B: 53 6C 6F 77 ; currentslow     defb "Slow_d: ", 0
00001E9F: 5F 64 3A 20 ; 
00001EA3: 00          ; 
00001EA4: 45 72 61 73 ; currenterase    defb "Erase_d: ", 0
00001EA8: 65 5F 64 3A ; 
00001EAC: 20 00       ; 
00001EAE: 53 74 65 70 ; currentstep     defb "Step_d: ", 0
00001EB2: 5F 64 3A 20 ; 
00001EB6: 00          ; 
00001EB7: 44 69 6D 73 ; currentDims     defb "Dims: ", 0
00001EBB: 3A 20 00    ; 
00001EBE: 52 61 6E 67 ; currentRange    defb "Range: ", 0
00001EC2: 65 3A 20 00 ; 
00001EC6: 28 00       ; bracket_open    defb "(", 0
00001EC8: 2C 20 00    ; comma_space     defb ", ", 0
00001ECB: 29 00       ; bracket_close   defb ")", 0
00001ECD: 41 6C 69 76 ; currenticons_1  defb "Alive: ", 0
00001ED1: 65 3A 20 00 ; 
00001ED5: 44 65 61 64 ; currenticons_2  defb "Dead: ", 0
00001ED9: 3A 20 00    ; 
00001EDC: 50 74 72 3A ; currenticons_3  defb "Ptr: ", 0
00001EE0: 20 00       ; 
00001EE2: 49 74 74 65 ; currentitter    defb "Itters: ", 0
00001EE6: 72 73 3A 20 ; 
00001EEA: 00          ; 
00001EEB: 45 6E 74 65 ; currentaskx     defb "Enter value for x: ", 0
00001EEF: 72 20 76 61 ; 
00001EF3: 6C 75 65 20 ; 
00001EF7: 66 6F 72 20 ; 
00001EFB: 78 3A 20 00 ; 
00001EFF: 45 6E 74 65 ; currentasky     defb "Enter value for y: ", 0
00001F03: 72 20 76 61 ; 
00001F07: 6C 75 65 20 ; 
00001F0B: 66 6F 72 20 ; 
00001F0F: 79 3A 20 00 ; 
00001F13: 45 6E 74 65 ; currentasknew   defb "Enter new value: ", 0
00001F17: 72 20 6E 65 ; 
00001F1B: 77 20 76 61 ; 
00001F1F: 6C 75 65 3A ; 
00001F23: 20 00       ; 
00001F25: 45 6E 74 65 ; currentasknew_B defb "Enter new value (0 or 1): ", 0
00001F29: 72 20 6E 65 ; 
00001F2D: 77 20 76 61 ; 
00001F31: 6C 75 65 20 ; 
00001F35: 28 30 20 6F ; 
00001F39: 72 20 31 29 ; 
00001F3D: 3A 20 00    ; 
00001F40: 45 72 72 6F ; currentasknew_E defb "Error invalid re-enter: ", 0
00001F44: 72 20 69 6E ; 
00001F48: 76 61 6C 69 ; 
00001F4C: 64 20 72 65 ; 
00001F50: 2D 65 6E 74 ; 
00001F54: 65 72 3A 20 ; 
00001F58: 00          ; 
00001F59: 49 6E 76 61 ; currentarrerr   defb "Invalid value entered re-enter: ", 0
00001F5D: 6C 69 64 20 ; 
00001F61: 76 61 6C 75 ; 
00001F65: 65 20 65 6E ; 
00001F69: 74 65 72 65 ; 
00001F6D: 64 20 72 65 ; 
00001F71: 2D 65 6E 74 ; 
00001F75: 65 72 3A 20 ; 
00001F79: 00          ; 
00001F7A: 49 6E 76 61 ; changearrsizmsg defb "Invalid, x >= y.", nl, 0
00001F7E: 6C 69 64 2C ; 
00001F82: 20 78 20 3E ; 
00001F86: 3D 20 79 2E ; 
00001F8A: 0A 00       ; 
00001F8C:             ; 
00001F8C: 4F 4E 00    ; on_msg          defb "ON", 0
00001F8F: 4F 46 46 00 ; off_msg         defb "OFF", 0
00001F93: 2C 00       ; comma           defb ",", 0
00001F95:             ; 
00001F98:             ; align
00001F98: 00000000    ; heapstart       defw 0 ;;points to the end of the data this is where the heap can then begin
00001F9C:             ; Remaining literals

Symbol Table: Labels
: max_addr                          00100000  Value
: stack_size                        00010000  Value
: nl                                0000000A  Value
: backspace                         00000008  Value
: minBuffSize                       00000008  Value
: enter                             0000000A  Value
: minSaveSize                       00000008  Value
: sizeofSaveI                       0000000C  Value
: _start                            00000000  Local -- ARM
: main                              00000038  Local -- ARM
: mainmenu                          00000064  Local -- ARM
: mainchoice                        0000007C  Local -- ARM
: mainloopstart                     000000C4  Local -- ARM
: mainloop                          000000F8  Local -- ARM
: mainloopcont                      0000011C  Local -- ARM
: mainloopdostep                    00000138  Local -- ARM
: mainloopskipstep                  00000160  Local -- ARM
: gridFail                          00000184  Local -- ARM
: mainEnd                           00000190  Local -- ARM
: settingsmenu                      000001A8  Local -- ARM
: changesetting                     000001CC  Local -- ARM
: changesettingget                  000001D8  Local -- ARM
: changesettingserr                 00000214  Local -- ARM
: changesettingscont                00000224  Local -- ARM
: changearr                         00000264  Local -- ARM
: changearrget                      00000278  Local -- ARM
: changearrsizeerr                  000002B4  Local -- ARM
: changearrset                      000002C4  Local -- ARM
: changearrend                      000002D8  Local -- ARM
: changearrgetvalidint              000002E0  Local -- ARM
: changearrgetvalidintget           000002E4  Local -- ARM
: changearrgetvalidinterr           00000314  Local -- ARM
: changearrgetvalidintcont          00000320  Local -- ARM
: changearrgetvalidintend           00000330  Local -- ARM
: printdims                         00000338  Local -- ARM
: changestep                        0000038C  Local -- ARM
: changeslow                        000003A4  Local -- ARM
: changeerase                       000003BC  Local -- ARM
: changebool                        000003D4  Local -- ARM
: changebool_cont                   00000414  Local -- ARM
: changebool_set                    00000440  Local -- ARM
: changeboolend                     00000470  Local -- ARM
: changedims                        00000478  Local -- ARM
: changerange                       00000494  Local -- ARM
: changeicons                       000004B0  Local -- ARM
: changeitter                       000004B0  Local -- ARM
: printhelp                         000004B4  Local -- ARM
: newboard                          000004C8  Local -- ARM
: loadboard                         000004F0  Local -- ARM
: loadboardaskindex                 00000504  Local -- ARM
: loadboardindex                    00000568  Local -- ARM
: loadboardmain                     00000584  Local -- ARM
: loadboardmallocB                  000005EC  Local -- ARM
: loadboardskipB                    00000608  Local -- ARM
: loadboardmallocfail               00000628  Local -- ARM
: loadboardret                      00000638  Local -- ARM
: loadboardempty                    00000644  Local -- ARM
: loadboarderr                      00000644  Local -- ARM
: loadboardsucc                     00000648  Local -- ARM
: newline                           0000064C  Local -- ARM
: step                              00000658  Local -- ARM
: stependfail                       000006D0  Local -- ARM
: stependsucc                       000006D8  Local -- ARM
: stepend                           000006DC  Local -- ARM
: listGrids                         000006E4  Local -- ARM
: listGridsLoop                     00000718  Local -- ARM
: listGridsEmpty                    000007AC  Local -- ARM
: listGridsLend                     000007B8  Local -- ARM
: listGridsEnd                      000007B8  Local -- ARM
: saveGrid                          000007C0  Local -- ARM
: saveGridResize                    000007E4  Local -- ARM
: saveGridAdd                       0000081C  Local -- ARM
: saveGridFailMalloc                00000884  Local -- ARM
: saveGridSucc                      0000088C  Local -- ARM
: saveGridEnd                       00000890  Local -- ARM
: erase                             00000898  Local -- ARM
: eraseloop                         0000089C  Local -- ARM
: eraseend                          000008B4  Local -- ARM
: slow                              000008B8  Local -- ARM
: slowloop                          000008C0  Local -- ARM
: slowend                           000008E0  Local -- ARM
: heapclean                         000008E4  Local -- ARM
: heapcleanloop                     00000900  Local -- ARM
: heapcleanend                      00000914  Local -- ARM
: strlen                            00000918  Local -- ARM
: strlenloop                        00000924  Local -- ARM
: strlenend                         00000938  Local -- ARM
: heaphead                          00000940  Local -- ARM
: offsets                           00000944  Local -- ARM
: gridA                             00000984  Local -- ARM
: gridB                             00000988  Local -- ARM
: erase_b                           0000098C  Local -- ARM
: slow_b                            0000098D  Local -- ARM
: step_b                            0000098E  Local -- ARM
: width                             0000098F  Local -- ARM
: height                            00000990  Local -- ARM
: range_min                         00000991  Local -- ARM
: range_max                         00000992  Local -- ARM
: maxitters                         00000993  Local -- ARM
: erase_b_d                         00000994  Local -- ARM
: slow_b_d                          00000995  Local -- ARM
: step_b_d                          00000996  Local -- ARM
: width_d                           00000997  Local -- ARM
: height_d                          00000998  Local -- ARM
: range_min_d                       00000999  Local -- ARM
: range_max_d                       0000099A  Local -- ARM
: maxitters_d                       0000099B  Local -- ARM
: alive_c                           0000099C  Local -- ARM
: dead_c                            0000099D  Local -- ARM
: ptr_c                             0000099E  Local -- ARM
: strtoi                            000009A0  Local -- ARM
: strtoiloop                        000009E0  Local -- ARM
: strtoilend                        00000A14  Local -- ARM
: strtoifailminus                   00000A1C  Local -- ARM
: strtoifailoutrange                00000A24  Local -- ARM
: strtoifailnonnum                  00000A2C  Local -- ARM
: strtoiendfail                     00000A30  Local -- ARM
: strtoiendsucc                     00000A38  Local -- ARM
: strtoiend                         00000A3C  Local -- ARM
: memcpy                            00000A44  Local -- ARM
: memcpywordsloop                   00000A6C  Local -- ARM
: memcpywordslend                   00000A84  Local -- ARM
: memcpyallbytes                    00000A94  Local -- ARM
: memcpybytes                       00000AA0  Local -- ARM
: memcpybytesloop                   00000AA4  Local -- ARM
: memcpybyteslend                   00000ABC  Local -- ARM
: memcpyend                         00000AC0  Local -- ARM
: getstring                         00000AC8  Local -- ARM
: getstringloop                     00000AF4  Local -- ARM
: getstringloopskipsize             00000B04  Local -- ARM
: skipMax                           00000B18  Local -- ARM
: getstringlcont                    00000B24  Local -- ARM
: getstringresize                   00000B3C  Local -- ARM
: getstringlend                     00000B6C  Local -- ARM
: getstringResizeEnd                00000B78  Local -- ARM
: getstringEnd                      00000BA4  Local -- ARM
: tolower                           00000BB8  Local -- ARM
: setupGrid                         00000BC0  Local -- ARM
: setupGridAsk                      00000C08  Local -- ARM
: setupdrawing                      00000C38  Local -- ARM
: setuprandom                       00000C4C  Local -- ARM
: setupstart                        00000C74  Local -- ARM
: setuprowloop                      00000C78  Local -- ARM
: setupcolloop                      00000C84  Local -- ARM
: dorandom                          00000C98  Local -- ARM
: dodrawstart                       00000CAC  Local -- ARM
: dodraw                            00000CC4  Local -- ARM
: dodrawsucc                        00000CE8  Local -- ARM
: setupcollcont                     00000D08  Local -- ARM
: setupcollend                      00000D18  Local -- ARM
: setuprowlend                      00000D20  Local -- ARM
: setupGridFail                     00000D30  Local -- ARM
: setupGridEnd                      00000D30  Local -- ARM
: drawgrid                          00000D38  Local -- ARM
: drawgridrowloop                   00000D4C  Local -- ARM
: drawgridcolloop                   00000D58  Local -- ARM
: drawgridprintcurrent              00000D84  Local -- ARM
: drawgridcollcont                  00000D8C  Local -- ARM
: drawgridcollend                   00000D9C  Local -- ARM
: drawgridrowlend                   00000DB0  Local -- ARM
: drawgridend                       00000DB8  Local -- ARM
: printoptions                      00000DC0  Local -- ARM
: setupOptions                      00000E6C  Local -- ARM
: setupOptionsDEnd                  00000EC8  Local -- ARM
: setupCustom                       00000ED4  Local -- ARM
: setupCustomskipslow               00000F78  Local -- ARM
: setupCustomDimsCheck              00000F80  Local -- ARM
: getwid                            00000F94  Local -- ARM
: getwidFail                        00000FE0  Local -- ARM
: getheisetup                       00000FF0  Local -- ARM
: gethei                            00000FFC  Local -- ARM
: getheiFail                        00001048  Local -- ARM
: customend                         00001058  Local -- ARM
: updategrid                        00001064  Local -- ARM
: updategridrowloop                 0000107C  Local -- ARM
: updategridcolloop                 00001088  Local -- ARM
: updatealive                       000010B0  Local -- ARM
: updatedead                        000010CC  Local -- ARM
: updatelcont                       000010DC  Local -- ARM
: updategridccollend                000010E4  Local -- ARM
: updategridrowlend                 000010F0  Local -- ARM
: updategridend                     000010F0  Local -- ARM
: countneighbours                   000010F8  Local -- ARM
: countneighboursloop               0000111C  Local -- ARM
: countneighboursskipadd            00001160  Local -- ARM
: countneighbourslend               00001164  Local -- ARM
: countneighboursend                00001164  Local -- ARM
: isinrange                         00001170  Local -- ARM
: isinrangefail                     000011A4  Local -- ARM
: isinrangeend                      000011A8  Local -- ARM
: setupHeap                         000011AC  Local -- ARM
: malloc                            000011D8  Local -- ARM
: mallignend                        000011F4  Local -- ARM
: checkcrate                        000011F8  Local -- ARM
: nocrates                          00001218  Local -- ARM
: foundcrate                        00001220  Local -- ARM
: splitcrate                        00001230  Local -- ARM
: usecrate                          00001264  Local -- ARM
: mallocEnd                         00001278  Local -- ARM
: free                              00001280  Local -- ARM
: freeloop                          0000128C  Local -- ARM
: freelend                          000012A8  Local -- ARM
: freelendEnd                       000012C8  Local -- ARM
: freeMergeCheck                    000012D0  Local -- ARM
: verifyLeft                        000012E0  Local -- ARM
: verifyRight                       000012F4  Local -- ARM
: merge                             00001308  Local -- ARM
: mergeNew                          0000133C  Local -- ARM
: freeEnd                           0000133C  Local -- ARM
: welcomemsg                        00001344  Local -- ARM
: welcome2msg                       00001375  Local -- ARM
: mainchoicefail                    000013B4  Local -- ARM
: helpmsg                           0000144F  Local -- ARM
: help2msg                          0000150D  Local -- ARM
: mainendmsg                        00001582  Local -- ARM
: askdefaults                       000015A9  Local -- ARM
: askerase                          000015DB  Local -- ARM
: askslow                           000015F4  Local -- ARM
: askstep                           0000160C  Local -- ARM
: stepslowwarning                   00001624  Local -- ARM
: savedchoice                       00001671  Local -- ARM
: askname                           0000169C  Local -- ARM
: warneraseslow                     000016BF  Local -- ARM
: askwid                            000016FD  Local -- ARM
: askhei                            0000171B  Local -- ARM
: getwidfailmsg                     0000173A  Local -- ARM
: getheifailmsg                     00001776  Local -- ARM
: usingDefault                      000017B3  Local -- ARM
: usingDefWODims                    000017FF  Local -- ARM
: optionsp_1                        0000183D  Local -- ARM
: optionsp_2                        00001855  Local -- ARM
: optionsp_3                        00001858  Local -- ARM
: optionsp_4                        00001864  Local -- ARM
: optionsp_5                        00001870  Local -- ARM
: mainloopittsmsg                   0000187B  Local -- ARM
: askgenoption                      000018F4  Local -- ARM
: setupGrdFailmsg                   0000192D  Local -- ARM
: askseed                           0000198E  Local -- ARM
: drawinfomsg                       000019BA  Local -- ARM
: drawfailmsg                       000019F2  Local -- ARM
: gridfailmsg                       00001A17  Local -- ARM
: gridsavefail                      00001A51  Local -- ARM
: gridloadempty                     00001A89  Local -- ARM
: gridloadpindex                    00001AE9  Local -- ARM
: gridloadpname                     00001AF2  Local -- ARM
: gridloadpwidth                    00001AFA  Local -- ARM
: gridloadpheight                   00001B03  Local -- ARM
: loadboardaski                     00001B0D  Local -- ARM
: loadboardretmsg                   00001B7F  Local -- ARM
: loadboardifail                    00001B97  Local -- ARM
: loadboardirerr                    00001BBA  Local -- ARM
: loadboardmlcerr                   00001BD7  Local -- ARM
: loadboardsucmsg                   00001C17  Local -- ARM
: listgridmsg                       00001C35  Local -- ARM
: cutoff                            00001C58  Local -- ARM
: helpinfomsg                       00001C6B  Local -- ARM
: settingsmsg                       00001C72  Local -- ARM
: s_m1                              00001C79  Local -- ARM
: s_m2                              00001D0A  Local -- ARM
: s_m3                              00001D6E  Local -- ARM
: s_m                               00001E1F  Local -- ARM
: s_m_err                           00001E7B  Local -- ARM
: currentslow                       00001E9B  Local -- ARM
: currenterase                      00001EA4  Local -- ARM
: currentstep                       00001EAE  Local -- ARM
: currentDims                       00001EB7  Local -- ARM
: currentRange                      00001EBE  Local -- ARM
: bracket_open                      00001EC6  Local -- ARM
: comma_space                       00001EC8  Local -- ARM
: bracket_close                     00001ECB  Local -- ARM
: currenticons_1                    00001ECD  Local -- ARM
: currenticons_2                    00001ED5  Local -- ARM
: currenticons_3                    00001EDC  Local -- ARM
: currentitter                      00001EE2  Local -- ARM
: currentaskx                       00001EEB  Local -- ARM
: currentasky                       00001EFF  Local -- ARM
: currentasknew                     00001F13  Local -- ARM
: currentasknew_B                   00001F25  Local -- ARM
: currentasknew_E                   00001F40  Local -- ARM
: currentarrerr                     00001F59  Local -- ARM
: changearrsizmsg                   00001F7A  Local -- ARM
: on_msg                            00001F8C  Local -- ARM
: off_msg                           00001F8F  Local -- ARM
: comma                             00001F93  Local -- ARM
: heapstart                         00001F98  Local -- ARM
