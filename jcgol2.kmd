KMD
00000000:             ; ;;  This is my second rendition of JCGOL in ARM assembly for Komodo
00000000:             ; ;;  
00000000:             ; ;;  This will attempt to follow the ARM 32bit calling convention 
00000000:             ; ;;      R0-3 are argument registers, scratch
00000000:             ; ;;      R4-11 are local variable registers and should be saved before use in a function
00000000:             ; ;;      R12 - IPC
00000000:             ; ;;      R13 - SP
00000000:             ; ;;      R14 - LR
00000000:             ; ;;      R15 - PC
00000000:             ; ;;
00000000:             ; ;;  The plan
00000000:             ; ;;  - Create a simple `heap` allocator for the grid and input
00000000:             ; ;;  - Ask the user
00000000:             ; ;;      |-Use default? Y - skip below
00000000:             ; ;;      |-dims of the grid
00000000:             ; ;;      |   `-Will need a way to get a string input and convert to an integer (make sure to cat
                      ; ch -ve)
00000000:             ; ;;      |-slow mode
00000000:             ; ;;      `-erase mode
00000000:             ; ;;  - ask for generation mode
00000000:             ; ;;      |-If random ask for seed
00000000:             ; ;;      |   `-For generation roll the seed to create a pseudorandom value for each `pixel`
00000000:             ; ;;      `-If draw then get them to draw the grid one `pixel` at a time
00000000:             ; ;;  - Allocate two grids, the pointers to which will swap after a frame. One is used to count t
                      ; he neighbours the other for the new cell value.
00000000:             ; ;;  - loop
00000000:             ; ;;      |-count neighbours
00000000:             ; ;;      |-update inactive grid
00000000:             ; ;;      |-swap grids
00000000:             ; ;;      |-draw active grid
00000000:             ; ;;      `-goto loop
00000000:             ; 
00000000:             ; 
00000000:             ; ;;  CURRENT ISSUES/TODOS
00000000:             ; ;;      |-Free is looping crates, making them point at themselves
00000000:             ; ;;      |-Have not tested getstring due to ^, prob doesn't word
00000000:             ; ;;      `-haven't tested memcpy             --^
00000000:             ; 
00000000:             ; max_addr    EQU  0x100000
00000000:             ; stack_size  EQU  0x10000
00000000:             ; nlchar      EQU  10
00000000:             ; minBuffSize EQU  8
00000000:             ; enter       EQU  nlchar
00000000:             ; 
00000000:             ; _start
00000000:             ;     ;;prepare the stack
00000000: E3A0D601    ;     ldr R13, =max_addr
00000004: E3A0E000    ;     mov R14, #0 ;; allow for `returning` from _start
00000008: E92D4000    ;     push {R14}
0000000C:             ; 
0000000C:             ;     ;;[[temp]] clean the heap
0000000C: EB000015    ;     bl heapclean
00000010:             ; 
00000010:             ;     ;;setup heap
00000010: E28F00A4    ;     adrl R0, heapstart
00000014: E2800B01    ; 
00000018: E58F0494    ;     str R0, heaphead
0000001C: EB000096    ;     bl setupHeap
00000020:             ; 
00000020: E3A0000E    ;     mov R0, #14
00000024: EB00009F    ;     bl malloc
00000028:             ; 
00000028: EB000002    ;     bl main
0000002C:             ; 
0000002C: E8BD4000    ;     pop {R14}
00000030: EF000002    ;     swi 2
00000034: E1A0F00E    ;     mov R15, R14
00000038:             ; 
00000038:             ; main
00000038: E92D41F0    ;     push {R14, R4-R8}
0000003C:             ; 
0000003C: EB000071    ;     bl setupOptions
00000040:             ; 
00000040:             ; 
00000040: E3A0000A    ;     ldr R0, =enter
00000044: E3E01000    ;     mov R1, #-1
00000048: E3A02001    ;     mov R2, #1
0000004C: EB000032    ;     bl getstring
00000050:             ; 
00000050: EF000003    ;     swi 3
00000054:             ; 
00000054: E8BD41F0    ;     pop {R14, R4-R8}
00000058: E1A0F00E    ;     mov R15, R14
0000005C:             ; 
0000005C:             ; newline
0000005C: E3A0000A    ;     ldr R0, =nlchar
00000060: EF000000    ;     swi 0
00000064:             ; 
00000064: E1A0F00E    ;     mov R15, R14
00000068:             ; 
00000068:             ; heapclean
00000068:             ; ;;zero out all memory in the heap (debugging uses)
00000068: E59F044C    ;     ldr R0, =heapstart
0000006C: E3A01601    ;     ldr R1, =max_addr ;;stores the end of the heap
00000070: E3A02801    ;     ldr R2, =stack_size
00000074: E0411002    ;     sub R1, R1, R2
00000078: E3C11003    ;     and R1, R1, #-4
0000007C: E3A03000    ;     mov R3, #0
00000080:             ; heapcleanloop
00000080: E1500001    ;     cmp R0, R1
00000084: 0A000002    ;     beq heapcleanend
00000088: E5003000    ;     str R3, [R0]
0000008C: E2800004    ;     add R0, R0, #4
00000090: EAFFFFFA    ;     b heapcleanloop
00000094:             ; heapcleanend
00000094: E1A0F00E    ;     mov R15, R14
00000098:             ; 
00000098:             ; memcpy
00000098:             ; ;;INP in R0 is the addr of src
00000098:             ; ;;INP in R1 is the addr of dst
00000098:             ; ;;INP in R2 is the number of bytes to copy
00000098:             ; 
00000098:             ; ;;check if src and dst are alliged
00000098:             ; ;;If different then write bytes
00000098:             ; ;;If same then go to 4byte boundry
00000098:             ; ;;  Write words of bytes2copy / 4
00000098:             ; ;;  Write remaining bytes
00000098: E92D41F0    ;     push {R14, R4-R8}
0000009C:             ; 
0000009C: E2004003    ;     and R4, R0, #0b11
000000A0: E2015003    ;     and R5, R1, #0b11
000000A4:             ; 
000000A4: E1540005    ;     cmp R4, R5
000000A8: 1A00000E    ;     bne memcpyallbytes
000000AC:             ; 
000000AC:             ;     ;;If they are the same then cpy R4 bytes and then do words
000000AC: E0422004    ;     sub R2, R2, R4;; bytes2cpy -= bytes we are about to write
000000B0: E1A03004    ;     mov R3, R4
000000B4: EB00000E    ;     bl memcpybytes
000000B8:             ; 
000000B8:             ;     ;;Now find the number of words that can be written i.e. bytes2cpy / 4 (bytes2cpy >> 2)
000000B8: E3C23003    ;     and R3, R2, #-4 ;;the number of bytes to write that make up the words
000000BC: E3A04000    ;     mov R4, #0 ;;i
000000C0:             ; memcpywordsloop
000000C0: E1540003    ;     cmp R4, R3
000000C4: 0A000003    ;     beq memcpywordslend
000000C8:             ; 
000000C8: E7906004    ;     ldr R6, [R0, R4]
000000CC: E7816004    ;     str R6, [R1, R4]
000000D0:             ;     
000000D0: E2844004    ;     add R4, R4, #4
000000D4:             ; 
000000D4: EAFFFFF9    ;     b memcpywordsloop
000000D8:             ;     
000000D8:             ; memcpywordslend
000000D8:             ; ;;Now copy the remaining bytes
000000D8: E2022003    ;     and R2, R2, #0b11
000000DC: E1A03002    ;     mov R3, R2
000000E0: EB000003    ;     bl memcpybytes
000000E4: EA00000A    ;     b memcpyend
000000E8:             ; 
000000E8:             ; memcpyallbytes
000000E8: E1A03002    ;     mov R3, R2
000000EC: EB000000    ;     bl memcpybytes
000000F0: EA000007    ;     b memcpyend
000000F4:             ; 
000000F4:             ; memcpybytes
000000F4:             ; ;;This is an internal function to memcpy and so doesn't follow the calling convention, it also 
                      ; assumes values are in place from memcpy
000000F4:             ; ;;for (int i = 0; i < byte2cpy; i++) {
000000F4:             ; ;;      *(dst + i) = *(src + i)
000000F4:             ; ;;INP in R3 is the number of bytes to copy
000000F4: E3A05000    ;     mov R5, #0 ;;i
000000F8:             ; memcpybytesloop
000000F8: E1550003    ;     cmp R5, R3
000000FC: 0A000003    ;     beq memcpybyteslend ;;i < bytes2cpy
00000100:             ; 
00000100: E7D04005    ;     ldrb R4, [R0, R5]
00000104: E7C14005    ;     strb R4, [R1, R5] ;;dst[i] = src[i]
00000108:             ; 
00000108: E2855001    ;     add R5, R5, #1 ;;i++
0000010C:             ; 
0000010C: EAFFFFF9    ;     b memcpybytesloop
00000110:             ; 
00000110:             ; memcpybyteslend
00000110: E1A0F00E    ;     mov R15, R14
00000114:             ; 
00000114:             ; memcpyend
00000114: E8BD41F0    ;     pop {R14, R4-R8}
00000118: E1A0F00E    ;     mov R15, R14
0000011C:             ; 
0000011C:             ; getstring
0000011C:             ; ;;INP in R0 the terminator character
0000011C:             ; ;;INP in R1 the max number of characters or -1 for no max
0000011C:             ; ;;INP in R2 boolean (non-0/0) for if letters should be printed out as well
0000011C:             ; ;;RET in R0 a ptr to the memory address
0000011C:             ; ;;
0000011C:             ; ;;Dynamically allocate memory to support large string
0000011C:             ; 
0000011C:             ; ;;buff = malloc(minBytes)
0000011C:             ; ;;while (input != terminator && pos < maxchars) 
0000011C:             ; ;;  buff[pos] = input
0000011C:             ; ;;  putchar(input)
0000011C:             ; ;;  if (pos > buffSize)
0000011C:             ; ;;      nBuff = malloc(buffSize << 1)
0000011C:             ; ;;      memcpy from buff to nBuff
0000011C:             ; ;;      free buff
0000011C:             ; ;;      buff = nBuff
0000011C:             ; 
0000011C: E92D47F0    ;     push {R14, R4-R10}
00000120:             ; 
00000120: E1A08000    ;     mov R8, R0 ;;now holds terminator
00000124: E1A09001    ;     mov R9, R1 ;;nax chars
00000128: E3590000    ;     cmp R9, #0
0000012C: 0A000030    ;     beq getstringEnd
00000130: E2499001    ;     sub R9, R9, #1 ;;reduce by 1 to use later
00000134: E1A0A002    ;     mov R10, R2 ;;print bool
00000138:             ; 
00000138: E3A06008    ;     ldr R6, =minBuffSize ;;R6 will hold the current size of the buffer
0000013C: E1A00006    ;     mov R0, R6
00000140: EB000058    ;     bl malloc
00000144: E1A04000    ;     mov R4, R0 ;;R4 is the address of the buffer
00000148:             ; 
00000148: E3A05000    ;     mov R5, #0 ;;R5 is the loop counter/index into buffer
0000014C:             ; getstringloop
0000014C: EF000001    ;     swi 1 ;;get input
00000150: E1500008    ;     cmp R0, R8 ;;is input == terminator character
00000154: 0A000018    ;     beq getstringlend
00000158:             ; 
00000158: E3790002    ;     cmp R9, #-2
0000015C: 0A000001    ;     beq skipMax
00000160:             ; 
00000160: E1550009    ;     cmp R5, R9 ;;position - maxsize
00000164:             ;                       ;;pos 2 means 3 characters written
00000164: AA000014    ;     bge getstringlend ;;if position >= maxsize - 1
00000168:             ; 
00000168:             ; skipMax
00000168: E1550006    ;     cmp R5, R6
0000016C: E92D0001    ;     push {R0}
00000170: AA000005    ;     bge getstringresize
00000174:             ; 
00000174:             ; getstringlcont
00000174: E8BD0001    ;     pop {R0}
00000178: E7C40005    ;     strb R0, [R4, R5] ;;buff[pos] = input
0000017C:             ; 
0000017C: E35A0000    ;     cmp R10, #0
00000180: 1F000000    ;     swine 0 ;;output the character to the screen if R10 is not 0
00000184:             ; 
00000184: E2855001    ;     add R5, R5, #1
00000188:             ; 
00000188: EAFFFFEF    ;     b getstringloop
0000018C:             ; 
0000018C:             ; getstringresize
0000018C:             ;     ;;r6 will hold new buffer
0000018C: E1A00086    ;     mov R0, R6, lsl #1
00000190: EB000044    ;     bl malloc
00000194: E1A07000    ;     mov R7, R0
00000198:             ; 
00000198: E1A00004    ;     mov R0, R4 ;;old buff
0000019C: E1A01007    ;     mov R1, R7 ;;newBuff
000001A0: E1A02005    ;     mov R2, R5 ;;bytes to write
000001A4: EBFFFFBB    ;     bl memcpy
000001A8:             ; 
000001A8: E1A00004    ;     mov R0, R4
000001AC: EB000067    ;     bl free
000001B0: E1A04007    ;     mov R4, R7
000001B4:             ; 
000001B4: E1A06086    ;     mov R6, R6, lsl #1
000001B8:             ; 
000001B8: EAFFFFED    ;     b getstringlcont
000001BC:             ; 
000001BC:             ; getstringlend
000001BC:             ;     ;;need to add a \0
000001BC:             ;     ;;need to check if the buffer is completely full -> resize buffer to +1? then copy
000001BC:             ;     ;;I could have the buffers always leave a space open for the \0? but this is kind of an edg
                      ; e case?
000001BC: E1550006    ;     cmp R5, R6 ;;position to size of buffer
000001C0: 0A000000    ;     beq getstringResizeEnd
000001C4:             ; 
000001C4: EA00000A    ;     b getstringEnd
000001C8:             ; 
000001C8:             ; getstringResizeEnd
000001C8: E2860001    ;     add R0, R6, #1
000001CC: EB000035    ;     bl malloc
000001D0: E1A07000    ;     mov R7, R0
000001D4:             ; 
000001D4: E1A00004    ;     mov R0, R4;;old buff
000001D8: E1A01007    ;     mov R1, R7;;new buff
000001DC: E1A02005    ;     mov R2, R5;;bytes2write
000001E0: EBFFFFAC    ;     bl memcpy
000001E4:             ; 
000001E4: E1A00004    ;     mov R0, R4
000001E8: EB000058    ;     bl free
000001EC: E1A04007    ;     mov R4, R7
000001F0:             ; 
000001F0: E2866001    ;     add R6, R6, #1 ;;not needed
000001F4:             ; 
000001F4:             ; getstringEnd
000001F4: E3A00000    ;     mov R0, #0
000001F8: E7C40005    ;     strb R0, [R4, R5]
000001FC:             ; 
000001FC: E1A00004    ;     mov R0, R4
00000200:             ; 
00000200: E8BD47F0    ;     pop {R14, R4-R10}
00000204: E1A0F00E    ;     mov R15, R14
00000208:             ; 
00000208:             ; setupOptions
00000208: E28F0F81    ;     adrl R0, askdefaults ;;ask q
0000020C: EF000003    ;     swi 3
00000210: EF000001    ;     swi 1   ;;get character answer
00000214: EF000000    ;     swi 0
00000218: E3500059    ;     cmp R0, #'Y'
0000021C: E3A0000A    ;     ldr R0, =nlchar
00000220: EF000000    ;     swi 0
00000224:             ; 
00000224: 1A000000    ;     bne setupCustom
00000228:             ; 
00000228: E1A0F00E    ;     mov R15, R14 ;;RET
0000022C:             ; 
0000022C:             ; setupCustom
0000022C:             ; ;;ask for erase, slow, dims
0000022C: E3A01001    ;     mov R1, #1
00000230:             ; 
00000230: E28F000E    ;     adrl R0, askerase
00000234: E2800C02    ; 
00000238: EF000003    ;     swi 3
0000023C: EF000001    ;     swi 1
00000240: EF000000    ;     swi 0
00000244: E3500059    ;     cmp R0, #'Y'
00000248: E3A0000A    ;     ldr R0, =nlchar
0000024C: EF000000    ;     swi 0
00000250: 05CF1260    ;     streqb R1, erase_b
00000254:             ;  
00000254: E28F0003    ;     adrl R0, askslow
00000258: E2800C02    ; 
0000025C: EF000003    ;     swi 3
00000260: EF000001    ;     swi 1
00000264: EF000000    ;     swi 0 
00000268: E3500059    ;     cmp R0, #'Y' 
0000026C: E3A0000A    ;     ldr R0, =nlchar
00000270: EF000000    ;     swi 0
00000274: 05CF123D    ;     streqb R1, slow_b
00000278:             ; 
00000278: E1A0F00E    ;     mov R15, R14 ;;RET
0000027C:             ; 
0000027C:             ; ;; The heap will be a linked list of free blocks - unlike the Comodo version which stores both 
                      ; free & taken blocks 
0000027C:             ; ;; This is an idea I'm stealing from the C programming book
0000027C:             ; ;; Crate structure
0000027C:             ; ;;  |-ptr to next crate (1 word)
0000027C:             ; ;;  |-ptr to prev crate (1 word)
0000027C:             ; ;;  `-Size (bytes)      (1 word)
0000027C:             ; ;; 
0000027C:             ; 
0000027C:             ; ;;  Traversal of the heap
0000027C:             ; ;;  Unlink in my Comodo implimentation the heap is not a linked list of all Crates (free or not
                      ; )
0000027C:             ; ;;  That made traversing the heap for debugging purposes very easy, in this case taken crates d
                      ; o not point to the next
0000027C:             ; ;;  Instead could start at head and then just go to addr + sizeof(Crate) + size. This should ta
                      ; ke us to the next crate, free or not
0000027C:             ; ;;  
0000027C:             ; setupHeap
0000027C:             ; ;;NO INP
0000027C:             ; ;;NO OUT
0000027C:             ;     ;;we have the heapstart
0000027C:             ;     ;;the end of the heap will be 0x100000 (it will overlap with the stack :) )
0000027C: E59F0230    ;     ldr R0, heaphead ;;stores the mem addr of the start of the heap
00000280: E3A01601    ;     ldr R1, =max_addr ;;stores the end of the heap
00000284: E3A02801    ;     ldr R2, =stack_size
00000288: E0411002    ;     sub R1, R1, R2
0000028C:             ; 
0000028C: E0411000    ;     sub R1, R1, R0  ;;HEAPEND - HEAPSTART = TOTAL STORAGE (bytes)
00000290: E241100C    ;     sub R1, R1, #12 ;;SIZE -= SIZEOF(CRATE) (12 bytes)
00000294: E5801008    ;     str R1, [R0, #8] ;;set the size of the crate
00000298: E3A01000    ;     mov R1, #0
0000029C: E5801004    ;     str R1, [R0, #4] ;;set the prev ptr
000002A0: E5801000    ;     str R1, [R0, #0] ;;set the next ptr
000002A4:             ; 
000002A4: E1A0F00E    ;     mov R15, R14
000002A8:             ; 
000002A8:             ; ;; The heap is a linked list of free Crates and so find the header and then go though until one
                      ;  satifies the size requirement
000002A8:             ; ;;  end if next is 0
000002A8:             ; ;;  once found either take over the crate or split it into two new crates
000002A8:             ; ;;  align the bytes amount to 8 byte boundry
000002A8:             ; malloc
000002A8:             ; ;;INP into R0 bytes to allocate
000002A8:             ; ;;OUT into R0 the ptr to the memory or 0 for no memory allocated
000002A8:             ;     ;;step 1 align the bytes
000002A8:             ;     ;;1001010 & 0111 = 0000010 ;2
000002A8:             ;     ;;if 0 goto alignend
000002A8:             ;     ;;1001010 + (8 - 2)
000002A8: E92D0010    ;     push {R4}
000002AC:             ; 
000002AC: E2001007    ;     and R1, R0, #0b0111
000002B0: E3510000    ;     cmp R1, #0
000002B4: 0A000002    ;     beq mallignend
000002B8: E3A03008    ;     mov R3, #0b1000
000002BC: E0432001    ;     sub R2, R3, R1
000002C0: E0800002    ;     add R0, R0, R2
000002C4:             ; 
000002C4:             ; mallignend
000002C4: E59F11E8    ;     ldr R1, heaphead ;;stores a ptr to the first block
000002C8:             ;     
000002C8:             ; checkcrate
000002C8: E5912008    ;     ldr R2, [R1, #8] ;;Size of the crate
000002CC: E1500002    ;     cmp R0, R2 ;;bytes needed - bytes in crate
000002D0: DA000006    ;     ble foundcrate
000002D4: E5912000    ;     ldr R2, [R1, #0] ;;get the next ptr
000002D8: E3520000    ;     cmp R2, #0
000002DC: 0A000001    ;     beq nocrates
000002E0: E1A01002    ;     mov R1, R2 ;;swap the current crate with the next crate
000002E4: EAFFFFF7    ;     b checkcrate
000002E8:             ; nocrates
000002E8: E3A00000    ;     mov R0, #0
000002EC: EA000015    ;     b mallocEnd
000002F0:             ; 
000002F0:             ; foundcrate
000002F0:             ;     ;;Once a crate that we can use has been found we need to either split the crate or use the 
                      ; crate
000002F0:             ;     ;;We should use the whole crate only when its size < bytesneeded + CrateHeader + 8
000002F0:             ;     ;;This would give the edge case crate 8 bytes
000002F0:             ;     
000002F0:             ;     ;;R1 holds the found crate ptr
000002F0:             ;     ;;R0 is the bytes requested and aligned
000002F0: E2802014    ;     add R2, R0, #20 ;;A crate header is 12 bytes + the extra 8 bytes minimum
000002F4: E5913008    ;     ldr R3, [R1, #8]
000002F8: E1530002    ;     cmp R3, R2
000002FC: BA00000C    ;     blt usecrate
00000300:             ; splitcrate
00000300:             ;     ;;In this case we have a large crate that should be split up.
00000300:             ;     ;;ATM the crate will just be split up to where the requested memory is at the end of the fr
                      ; ee Crate.
00000300:             ; 
00000300: E5913008    ;     ldr R3, [R1, #8] ;;The size of the toSplit Crate
00000304: E0433000    ;     sub R3, R3, R0 ;; size - bytesRequested
00000308: E243300C    ;     sub R3, R3, #12 ;; size - bytesRequested - sizeof(Crate)
0000030C: E5813008    ;     str R3, [R1, #8] ;;toSplit->size = newSize
00000310:             ; 
00000310: E0833001    ;     add R3, R3, R1 ;; newSize + toSplit.addr
00000314: E283400C    ;     add R4, R3, #12 ;; newSize + toSplit.addr + sizeof(Crate) = position of new Crate
00000318:             ; 
00000318:             ;     ;;Setup the header for the newCrate
00000318: E3A02000    ;     mov R2, #0
0000031C: E5842000    ;     str R2, [R4, #0] ;;next = 0
00000320: E5842004    ;     str R2, [R4, #4] ;;prev = 0
00000324: E5840008    ;     str R0, [R4, #8] ;;size = requested and aligned
00000328:             ; 
00000328:             ;     ;;MAYBE: can the crates that are taken have a smaller header than those that are free. Take
                      ; n crates need not store the next, prev free nodes
00000328:             ;     ;;This may complicate things as size would need to be moved around and the size from taken 
                      ; to free would be different. 
00000328:             ; 
00000328: E284400C    ;     add R4, R4, #12
0000032C:             ; 
0000032C: E1A00004    ;     mov R0, R4
00000330:             ; 
00000330: EA000004    ;     b mallocEnd
00000334:             ; 
00000334:             ; usecrate
00000334:             ;     ;; Simplest option as we can just remove it from the list
00000334:             ;     ;; c1 <-> c2 <-> c3 ==> c1 <-> c3
00000334: E5912000    ;     ldr R2, [R1, #0] ;;next ptr
00000338: E5913004    ;     ldr R3, [R1, #4] ;;prev ptr
0000033C: E5823004    ;     str R3, [R2, #4] ;;Store c1 into c3's previous
00000340: E5832000    ;     str R2, [R3, #0] ;;Store c3 into c1's next
00000344:             ; 
00000344: E1A00001    ;     mov R0, R1 ;;move the found crate's address into the return register ;;The crate header is 
                      ; no longer needed
00000348:             ; 
00000348:             ; mallocEnd
00000348: E8BD0010    ;     pop {R4}
0000034C: E1A0F00E    ;     mov R15, R14
00000350:             ; 
00000350:             ; free
00000350:             ; ;;INP in R0 is the mem addr of the data to be freed
00000350:             ; ;;OUT in R0 is the success code - 0 for mem freed, ¬0 for error ;;probably won't be currently 
                      ; used `=(- -)=' 
00000350:             ;     ;;In order to free memory we need to add it back to the linked list
00000350:             ;     ;;Following K&R's version the linked list will be ordered by address this will make finding
                      ;  consecutive memory locations that should be combined easier
00000350:             ; 
00000350:             ;     ;;The inputted address of the crate is the address given in malloc and so the start of the 
                      ; crate is that addr - sizeof(Crate) (#12)
00000350:             ; 
00000350:             ;     ;;heapHead = first Crate
00000350:             ;     ;;current = heapHead
00000350:             ;     ;;while (toFree.addr > current.addr)
00000350:             ;     ;;  current = current.next
00000350:             ;     ;;
00000350:             ;     ;;//Add the toFree Crate inbetween the current and its previous i.e.  A<->B<->C, toFree = D
                      ;  (addr < C, addr > B) ==> A<->B<->D<->C
00000350:             ;     ;;current->prev->next = toFree
00000350:             ;     ;;toFree->prev = current.prev
00000350:             ;     ;;current->prev = toFree
00000350:             ;     ;;toFree->next = current
00000350:             ; 
00000350:             ;     ;; Crate structure
00000350:             ;     ;;  |-ptr to next crate (1 word)
00000350:             ;     ;;  |-ptr to prev crate (1 word)
00000350:             ;     ;;  `-Size (bytes)      (1 word)
00000350:             ; 
00000350: E92D01F0    ;     push {R4-R8}
00000354:             ; 
00000354: E59F1158    ;     ldr R1, heaphead ;;R1 will hold the current
00000358: E240000C    ;     sub R0, R0, #12 ;;subtract sizeof(Crate) to get header pointer
0000035C:             ; freeloop
0000035C: E5912000    ;     ldr R2, [R1, #0] ;;load the ptr to the next
00000360: E1520000    ;     cmp R2, R0 ;;compare the address of the toFree to the address of current->next
00000364:             ; 
00000364: AA000003    ;     bge freelend ;;current->next.addr >= toFree.addr
00000368:             ; 
00000368: E3520000    ;     cmp R2, #0 ;;If there are no more Crates to the right then this could be a new Crate at the
                      ;  end or |F|T| it should merge left 
0000036C: 0A000009    ;     beq freelendEnd
00000370:             ; 
00000370: E1A01002    ;     mov R1, R2 ;;current = current.next
00000374:             ; 
00000374: EAFFFFF8    ;     b freeloop
00000378:             ; 
00000378:             ; freelend
00000378:             ;     ;; R1 holds the current (left)
00000378:             ;     ;; R2 holds the c->next (right)
00000378: E5912000    ;     ldr R2, [R1, #0]
0000037C:             ; 
0000037C:             ;     ;;Setup the ptrs for the crates this will help later on   left<->toFree<->right ;;left,righ
                      ; t can be 0
0000037C:             ;     ;;We're just adding the new crate to the linked list
0000037C:             ;     ;;current->next->prev = toFree
0000037C:             ;     ;;toFree->next = current->next
0000037C:             ;     ;;current->next = toFree
0000037C:             ;     ;;toFree->prev = current
0000037C:             ; 
0000037C: E5913000    ;     ldr R3, [R1, #0] ;;holds current->next
00000380: E3530000    ;     cmp R3, #0
00000384: 15830004    ;     strne R0, [R3, #4] ;;current->next->prev = toFree
00000388: E5803000    ;     str R3, [R0, #0] ;;toFree->next = current->next
0000038C: E5810000    ;     str R0, [R1, #0] ;;current->next = toFree
00000390: E5801004    ;     str R1, [R0, #4] ;;toFree->prev = current
00000394:             ; 
00000394: EA000001    ;     b freeMergeCheck
00000398:             ; 
00000398:             ; freelendEnd
00000398:             ; ;;If there are no more Crates to the right then this could be a new Crate at the end or |F|T| i
                      ; t should merge left 
00000398:             ; ;;Found a crate (current) that is to the left of the crate as we ran out of ->next ptrs
00000398:             ; ;;Need to set current->next = toFree
00000398:             ; ;;            toFree->prev = current
00000398: E5801004    ;     str R1, [R0, #4] ;;toFree->prev = current
0000039C: E5810000    ;     str R0, [R1, #0] ;;current->next = toFree
000003A0:             ; 
000003A0:             ; freeMergeCheck
000003A0:             ;     ;;We have a ptr to current. This should be the closest Crate to the left of toFree
000003A0:             ;     ;;We also have the next Crate (null or not) which is to the right of toFree
000003A0:             ;     ;;Both of these crates MAY need to be merged but could also have taken crates in between
000003A0:             ;     ;;First is to check if the crates are adjacent
000003A0:             ;     ;;  If they are NOT then create a newCrate
000003A0:             ;     ;;  If they are     then merge both
000003A0:             ;     ;;  If only one     then merge either left or right
000003A0:             ; 
000003A0:             ;     ;;R1 will be left
000003A0:             ;     ;;R2 will be right
000003A0:             ; 
000003A0: E3510000    ;     cmp R1, #0
000003A4: 01A01000    ;     moveq R1, R0 ;;If there is no left crate then left=toFree
000003A8: E3520000    ;     cmp R2, #0
000003AC: 01A02000    ;     moveq R2, R0 ;;If there is no right crate (more likely) then right=toFree
000003B0:             ; 
000003B0:             ; verifyLeft
000003B0:             ;     ;;Check if the left is adjacent
000003B0:             ;     ;;It will be if (left.addr + sizeof(Crate) + left.size == toFree.addr)
000003B0:             ; 
000003B0: E5913008    ;     ldr R3, [R1, #8]
000003B4: E283300C    ;     add R3, R3, #12 ;;12 is sizeof(Crate) + toFree.size
000003B8: E0833001    ;     add R3, R3, R1 ;;left.addr + left->size ??
000003BC:             ; 
000003BC: E1530000    ;     cmp R3, R0
000003C0: 11A01000    ;     movne R1, R0
000003C4:             ; 
000003C4:             ; verifyRight
000003C4:             ;     ;;Going from toFree to Right
000003C4: E5903008    ;     ldr R3, [R0, #8] ;;get size of toFree
000003C8: E283300C    ;     add R3, R3, #12 ;;12 is sizeof(Crate) + toFree.size
000003CC: E0833000    ;     add R3, R3, R0 ;; + toFree.addr
000003D0:             ; 
000003D0: E1530002    ;     cmp R3, R2
000003D4: 11A02000    ;     movne R2, R0
000003D8:             ; 
000003D8:             ; merge
000003D8:             ;     ;;Merge the two Crates given in R1 and R2
000003D8:             ;     ;;left can be (left) or (toFree)
000003D8:             ;     ;;right can be (right) or (toFree)
000003D8:             ;     ;;If left == right: don't merge; create new Crate
000003D8:             ;     ;;If left != right: then add to left's size
000003D8:             ; 
000003D8: E1510002    ;     cmp R1, R2
000003DC: 0A00000A    ;     beq mergeNew
000003E0:             ; 
000003E0:             ;     ;;The new size is right.addr - left.addr + right->size    from right.addr - left.addr - siz
                      ; eof(Crate) + sizeof(Crate) + right->size
000003E0:             ;     ;;                                                               |left      |right
000003E0:             ;     ;;                                                               |<12>|size||<12>|size|
000003E0:             ;     ;;
000003E0:             ;     ;;                                                               |left      
000003E0:             ;     ;;                                                               |<12>|size           |
000003E0:             ;     ;;
000003E0:             ;     ;;I'm doing it this way as the left and right may not be contiguous i.e. if toFree has a fr
                      ; ee crate on either side
000003E0:             ; 
000003E0: E0423001    ;     sub R3, R2, R1
000003E4: E5924008    ;     ldr R4, [R2, #8]
000003E8: E0833004    ;     add R3, R3, R4
000003EC: E5813008    ;     str R3, [R1, #8]
000003F0:             ; 
000003F0:             ;     ;;Time to switch some ptrs
000003F0:             ;     ;;Current state left.prev<->left<->right<->right.next (with left or right = toFree) or left
                      ; .prev<->left<->toFree<->right<->right.next
000003F0:             ;     ;;New state would be left.prev<->left<->right.next (with left or right = toFree) or left.pr
                      ; ev<->left<->right.next
000003F0:             ;     ;;Both cases end the same, so get right.next. These could be 0 but it doesn't matter
000003F0:             ;     ;;Next need to change the prev and next ptrs for adjacent Crates
000003F0:             ;     ;;i.e. right->next->prev = left
000003F0:             ; 
000003F0: E5924000    ;     ldr R4, [R2, #0] ;;right->next
000003F4: E1540001    ;     cmp R4, R1
000003F8: 15814000    ;     strne R4, [R1, #0] ;;left->next = right->next
000003FC: 13A04000    ;     movne R4, #0
00000400: 15814000    ;     strne R4, [R1, #0]
00000404:             ; 
00000404: E3540000    ;     cmp R4, #0
00000408: 15841004    ;     strne R1, [R4, #4] ;;right->next->prev = left
0000040C:             ; 
0000040C:             ; mergeNew
0000040C:             ;     ;;The crate has already been setup with its ptrs and had its size as well so don't need to 
                      ; do anything
0000040C:             ; 
0000040C:             ; freeEnd
0000040C: E8BD01F0    ;     pop {R4-R8}
00000410: E1A0F00E    ;     mov R15, R14
00000414:             ; 
00000414:             ; ;;String defs
00000414: 57 6F 75 6C ; askdefaults defb "Would you like to use the default settings? Y/n: ", 0
00000418: 64 20 79 6F ; 
0000041C: 75 20 6C 69 ; 
00000420: 6B 65 20 74 ; 
00000424: 6F 20 75 73 ; 
00000428: 65 20 74 68 ; 
0000042C: 65 20 64 65 ; 
00000430: 66 61 75 6C ; 
00000434: 74 20 73 65 ; 
00000438: 74 74 69 6E ; 
0000043C: 67 73 3F 20 ; 
00000440: 59 2F 6E 3A ; 
00000444: 20 00       ; 
00000446: 45 6E 61 62 ; askerase    defb "Enable erase mode? Y/n: ", 0
0000044A: 6C 65 20 65 ; 
0000044E: 72 61 73 65 ; 
00000452: 20 6D 6F 64 ; 
00000456: 65 3F 20 59 ; 
0000045A: 2F 6E 3A 20 ; 
0000045E: 00          ; 
0000045F: 45 6E 61 62 ; askslow     defb "Enable slow mode? Y/n: ", 0
00000463: 6C 65 20 73 ; 
00000467: 6C 6F 77 20 ; 
0000046B: 6D 6F 64 65 ; 
0000046F: 3F 20 59 2F ; 
00000473: 6E 3A 20 00 ; 
00000477: 50 6C 65 61 ; askwid      defb "Please enter a width (1-30): ", 0
0000047B: 73 65 20 65 ; 
0000047F: 6E 74 65 72 ; 
00000483: 20 61 20 77 ; 
00000487: 69 64 74 68 ; 
0000048B: 20 28 31 2D ; 
0000048F: 33 30 29 3A ; 
00000493: 20 00       ; 
00000495: 50 6C 65 61 ; askhei      defb "Please enter a height (1-30): ", 0
00000499: 73 65 20 65 ; 
0000049D: 6E 74 65 72 ; 
000004A1: 20 61 20 68 ; 
000004A5: 65 69 67 68 ; 
000004A9: 74 20 28 31 ; 
000004AD: 2D 33 30 29 ; 
000004B1: 3A 20 00    ; 
000004B4:             ; 
000004B4:             ; align
000004B4:             ; ;;Integer defs
000004B4: 00010000    ; heaphead defw 0x10000 ;;default start
000004B8:             ; 
000004B8:             ; ;;options
000004B8: 00          ; erase_b defb 0
000004B9: 00          ; slow_b  defb 0
000004BA: 12          ; width   defb 18
000004BB: 12          ; height  defb 18
000004BC:             ; 
000004BC:             ; align
000004BC:             ; heapstart ;;points to the end of the data this is where the heap can then begin
000004BC:             ; 
000004BC: 000004BC    ; Remaining literals

Symbol Table: Labels
: max_addr                          00100000  Value
: stack_size                        00010000  Value
: nlchar                            0000000A  Value
: minBuffSize                       00000008  Value
: enter                             0000000A  Value
: _start                            00000000  Local -- ARM
: main                              00000038  Local -- ARM
: newline                           0000005C  Local -- ARM
: heapclean                         00000068  Local -- ARM
: heapcleanloop                     00000080  Local -- ARM
: heapcleanend                      00000094  Local -- ARM
: memcpy                            00000098  Local -- ARM
: memcpywordsloop                   000000C0  Local -- ARM
: memcpywordslend                   000000D8  Local -- ARM
: memcpyallbytes                    000000E8  Local -- ARM
: memcpybytes                       000000F4  Local -- ARM
: memcpybytesloop                   000000F8  Local -- ARM
: memcpybyteslend                   00000110  Local -- ARM
: memcpyend                         00000114  Local -- ARM
: getstring                         0000011C  Local -- ARM
: getstringloop                     0000014C  Local -- ARM
: skipMax                           00000168  Local -- ARM
: getstringlcont                    00000174  Local -- ARM
: getstringresize                   0000018C  Local -- ARM
: getstringlend                     000001BC  Local -- ARM
: getstringResizeEnd                000001C8  Local -- ARM
: getstringEnd                      000001F4  Local -- ARM
: setupOptions                      00000208  Local -- ARM
: setupCustom                       0000022C  Local -- ARM
: setupHeap                         0000027C  Local -- ARM
: malloc                            000002A8  Local -- ARM
: mallignend                        000002C4  Local -- ARM
: checkcrate                        000002C8  Local -- ARM
: nocrates                          000002E8  Local -- ARM
: foundcrate                        000002F0  Local -- ARM
: splitcrate                        00000300  Local -- ARM
: usecrate                          00000334  Local -- ARM
: mallocEnd                         00000348  Local -- ARM
: free                              00000350  Local -- ARM
: freeloop                          0000035C  Local -- ARM
: freelend                          00000378  Local -- ARM
: freelendEnd                       00000398  Local -- ARM
: freeMergeCheck                    000003A0  Local -- ARM
: verifyLeft                        000003B0  Local -- ARM
: verifyRight                       000003C4  Local -- ARM
: merge                             000003D8  Local -- ARM
: mergeNew                          0000040C  Local -- ARM
: freeEnd                           0000040C  Local -- ARM
: askdefaults                       00000414  Local -- ARM
: askerase                          00000446  Local -- ARM
: askslow                           0000045F  Local -- ARM
: askwid                            00000477  Local -- ARM
: askhei                            00000495  Local -- ARM
: heaphead                          000004B4  Local -- ARM
: erase_b                           000004B8  Local -- ARM
: slow_b                            000004B9  Local -- ARM
: width                             000004BA  Local -- ARM
: height                            000004BB  Local -- ARM
: heapstart                         000004BC  Local -- ARM
